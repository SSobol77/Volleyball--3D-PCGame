E:\Project\Kopia (5) VBEngine\Ai\AStarSolver.cpp

#include "..\config.h"

#include <memory.h>
#include <assert.h>

#include "..\utility\defines.h"
#include "..\Utility\Misc.h"
#include "..\utility\singleton.h"
#include "..\utility\event.h"
#include "..\utility\eventmanager.h"
#include "..\utility\eventhandler.h"
#include "..\utility\CTime.h"
#include "..\utility\logger.h"
#include "..\utility\Tools.h"
#include "..\utility\vbmath.h"

#ifdef DEBUG

//#include "..\graphics\camera.h"
#include "..\utility\singleton.h"
#include "..\graphics\MeshManager.h"

#include <crtdbg.h>
#endif

#include "..\graphics\camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\SceneObject.h"
#include "..\graphics\AnimationManager.h"
#include "..\graphics\Animation.h"

#include "state.h"
#include "statemanager.h"

#include "..\core\team.h"
#include "..\core\zawodnik.h"

#include "AStarSolver.h"

#define FILL_STEP 2


// struktura przekszta³caj¹ca ró¿nice x i y na k¹ty stateów
Direction DeltaToDir[3][3] = 
{
 {ANGLE_45 , ANGLE_90  , ANGLE_135},
 {ANGLE_0  , ANGLE_0   , ANGLE_180},
 {ANGLE_315, ANGLE_270 , ANGLE_225} 
};

// odpowiadaj¹ce kierunkom Direction wektory jednostkowe
CVector3 CDV[8] = 
  {
    CVector3(0.0f,         -1.0f,        0.0f),
    CVector3(-0.70710678f, -0.70710678f, 0.0f),
    CVector3(-1.0f,         0.0f,        0.0f),
    CVector3(-0.70710678f,  0.70710678f, 0.0f),
    CVector3(0.0f,          1.0f,        0.0f),
    CVector3(0.70710678f,   0.70710678f, 0.0f),
    CVector3(1.0f,          0.0f,        0.0f),
    CVector3(0.70710678f,  -0.70710678f, 0.0f),
  };

// konwerter pozycji na indeks w tabeli
#define get_index_from_pos(x , y) (((y) * WIDTH) + (x))


AStarSolver::AStarSolver(CTeam *team)
{
 this->mParentTeam = team;
// czyœcimy wszystko
 memset(this->mMapList,0,sizeof(mMapList));
 memset(&this->FixedObstacles,0,sizeof(AStarMap));
 this->mCurrentMap = 0;

 { // siatka jest nie do przejœcia
    unsigned char minx = 0;//XOFFSET + ROUND(-9.5f/CELL_SIZE);
    unsigned char maxx = WIDTH;//XOFFSET + ROUND( 9.5f/CELL_SIZE);
    unsigned char miny = YOFFSET;// + ROUND(-0.0f/CELL_SIZE);
    unsigned char maxy = YOFFSET;// + 3;//ROUND( 0.3f/CELL_SIZE);
    int offset = 0;

    for (int j = miny ; j < maxy ; j++)
    {
      offset = j * WIDTH;
      for (int i = minx ; i < maxx ; i++)
      {
        this->FixedObstacles.map[offset + i] = 1;
      }
    }
    // sêdziowie liniowi te¿
    minx = XOFFSET + ROUND( 4.0f/CELL_SIZE);
    maxx = XOFFSET + ROUND( 5.0f/CELL_SIZE);
    miny = YOFFSET + ROUND(11.0f/CELL_SIZE);
    maxy = YOFFSET + ROUND(12.0f/CELL_SIZE);
    for (int j = miny ; j < maxy ; j++)
    {
      offset = j * WIDTH;
      for (int i = minx ; i < maxx ; i++)
      {
        this->FixedObstacles.map[offset + i] = 1;
      }
    }
  }
// wype³nij wszystkie mapy sta³ymi przeszkodami
 for (int i = 0; i < MAPCOUNT; i++)
 {
   memcpy(&mMapList,&FixedObstacles,sizeof(AStarMap));
   mMapList[i].time = NOW + (float) i * MAP_DELTA;
 }

#ifdef DEBUG
  this->marker = CMeshManager::Instance()->GetMeshHandlerLoad("AStarMarker.X");
  CMeshManager::Instance()->SetAllShaders(marker,"test.fx");
  SceneManager::Instance()->AddObject(this);
  memset(&this->debugMap,0,sizeof(AStarMap)); 
#endif

}

AStarSolver::~AStarSolver()
{
#ifdef DEBUG
  SceneManager::Instance()->RemoveObject(this);
#endif
}

void AStarSolver::Update()
{
  const float current_time = NOW;
  float test_time;

  // je¿eli jesteœmyu na koñcu
  if (mCurrentMap == MAPCOUNT-1)
  { // bierzemy czas z pierwszej mapy
        test_time = mMapList[0].time;
  }
  else 
  { // jeœli nie to z nastêpnej
    test_time = mMapList[this->mCurrentMap+1].time;
  }
 
  if (current_time > test_time)
  {
    while(1)
    {
      
// kopiuj fixed obstacles do aktualnej mapy
      memcpy(&mMapList[this->mCurrentMap],&this->FixedObstacles, sizeof(AStarMap));
// ustaw czas mapy

      if (mCurrentMap == 0)
      {
        mMapList[this->mCurrentMap].time = mMapList[MAPCOUNT -1].time + MAP_DELTA;
      }
      else
      {
        mMapList[this->mCurrentMap].time = mMapList[this->mCurrentMap -1].time + MAP_DELTA;
      }
      //sprawdŸ czy ju¿ koniec  - czy doszliœmy do oodpowiedniego momentu
      if (mCurrentMap == MAPCOUNT-1)
      {
        test_time = mMapList[0].time;
      }
      else 
      {
        test_time = mMapList[this->mCurrentMap+1].time;
      }
      if (current_time < test_time) break;
      
      mCurrentMap++;
      if (mCurrentMap == MAPCOUNT)
      {
        mCurrentMap = 0;
    }

    }
  }
}


static void RealFillRect(register char *map, const int count, const int size, const char mask)
{
  register int n = (count+7)/8;
	switch(count & 7)
  {
		case 0:	do {	
              memset(map, mask, size);
              map += WIDTH;
		case 7:	  memset(map, mask, size);
              map += WIDTH;
		case 6:	  memset(map, mask, size);
              map += WIDTH;
		case 5:	  memset(map, mask, size);
              map += WIDTH;
		case 4:	  memset(map, mask, size);
              map += WIDTH;
		case 3:	  memset(map, mask, size);
              map += WIDTH;
		case 2:	  memset(map, mask, size);
              map += WIDTH;
		case 1:	  memset(map, mask, size);
              map += WIDTH;
			      } while( --n > 0 );
	}
}

static int FillRect(char *map, char mask, int x, int y)
{
  int size;
  int offset;
  int max, min;

  max = x + FILL_STEP;
  if (max > WIDTH -1) max = WIDTH -1;
  min = x - FILL_STEP;
  if (min < 0) min = 0;

  size = ((max - min) + 1) * sizeof(char);
  offset = min;

  max = y + FILL_STEP;
  if (max > HEIGHT - 1) max = HEIGHT-1;
  min = y - FILL_STEP;    
  if (min < 0) min = 0;
  offset += min * WIDTH;

  RealFillRect( map + offset, (max - min + 1), size, mask);
  
  return 0;
}

bool AStarSolver::CheckPath(CPlayer *player, unsigned char work_frame, char mask , short index, int lenght, short step_x, short step_y)
{
  CVector3 out;
  char pl;
  for(int iter = 0; iter < lenght; iter++)
  {
    pl = this->mMapList[work_frame].map[index];
    if ( player && player->IsAI() && !player->CzyOdbijam() && !player->IsBlocking() &&
         pl && pl != mask &&
         this->RunAway(player, pl, this->mMapList[work_frame].time - 0.1f, 0.0f, 2.0f, &out))
    {
      player->SetGoto(&out);
      return true;
    }
    index += step_x;
    index += step_y;
  }
  return false;
}

void AStarSolver::FillMap(unsigned char playerIndex)
{
  CPlayer *player = this->mParentTeam->GetPlayer(playerIndex);
  char mask = 0x80 | (playerIndex & 0x7);
  unsigned char work_frame = mCurrentMap;
  int x_old = -1, y_old = -1;
  for (int i = 0 ; i < MAPCOUNT; i++)
  {
    assert(work_frame < MAPCOUNT);
    CVector3 out;
    player->GetCurrentState()->GetPositionByTime(&out, this->mMapList[work_frame].time);
    int x = XOFFSET + ROUND(out.x / CELL_SIZE);
    int y = YOFFSET + ROUND(out.y / CELL_SIZE);

    if (x < 0 || x >= WIDTH || y < 0 || y >= HEIGHT)
    {
      work_frame++;
      if (work_frame == MAPCOUNT)
      {
        work_frame = 0;
      }
      continue;
    }

    if(x_old == -1 && y_old == -1)
    {
      if(this->CheckPath(player, work_frame, mask, get_index_from_pos(x, y), 1, 0))
      {
        work_frame++;
        if (work_frame == MAPCOUNT)
        {
          work_frame = 0;
      }
        x_old = x;
        y_old = y;
        continue;
      }
      FillRect(this->mMapList[work_frame].map, mask, x, y);
    }
    else
    {
       if(!(x - x_old))
       {
         if(!(y - y_old))
         {
           if(this->CheckPath(player, work_frame, mask, get_index_from_pos(x, y), 1, 0))
           {
             work_frame++;
             if (work_frame == MAPCOUNT)
             {
               work_frame = 0;
             }
             x_old = x;
             y_old = y;
             continue;
           }
           FillRect(this->mMapList[work_frame].map, mask, x, y);
         }
         else
         {
            int lng = y - y_old;
            int dir = ((lng > 0) ? WIDTH : -WIDTH);
            
            lng = IABS(lng);
            if(this->CheckPath(player, work_frame, mask, get_index_from_pos(x_old, y_old), lng, dir))
            {
              work_frame++;
              if (work_frame == MAPCOUNT)
              {
                work_frame = 0;
              }
              x_old = x;
              y_old = y;
              continue;
            }
            dir = ((dir < 0) ? y : y_old);
            
            {
              int offset, max, min;
              int size;

              max = x + FILL_STEP;
              if (max > WIDTH -1) max = WIDTH -1;
              min = x - FILL_STEP;
              if (min < 0) min = 0;

              size = ((max - min) + 1) * sizeof(char);
              offset = min;

              max = dir + lng + FILL_STEP;
              if (max > HEIGHT - 1) max = HEIGHT-1;
              min = dir - FILL_STEP;    
              if (min < 0) min = 0;


              offset += min * WIDTH;
              
              RealFillRect((this->mMapList[work_frame].map + offset), (max - min + 1), size, mask);
            }

         }
       }
       else
       {
        if(!(y - y_old))
        {
          int lng = x - x_old;
          int dir = ((lng > 0) ? 1 : -1);
          
          lng = IABS(lng);
          if(this->CheckPath(player, work_frame, mask, get_index_from_pos(x_old, y_old), lng, dir))
          {
            work_frame++;
            if (work_frame == MAPCOUNT)
            {
              work_frame = 0;
            }
            x_old = x;
            y_old = y;
            continue;
          }
          dir = ((dir < 0) ? x : x_old);

          {
            int offset, max, min;
            int size;

            max = dir + lng + FILL_STEP;
            if (max > WIDTH -1) max = WIDTH -1;
            min = dir - FILL_STEP;
            if (min < 0) min = 0;

            size = ((max - min) + 1) * sizeof(char);
            offset = min;

            max = y + FILL_STEP;
            if (max > HEIGHT - 1) max = HEIGHT-1;
            min = y - FILL_STEP;    
            if (min < 0) min = 0;

            offset += min * WIDTH;
            RealFillRect((this->mMapList[work_frame].map + offset), (max - min + 1), size, mask);
          }

        }
        else
        {
          
          int lng = y - y_old;
          int dir_y = ((lng > 0) ? WIDTH : -WIDTH);
          int dir_x = (((x - x_old) > 0) ? 1 : -1);
          
          lng = IABS(lng);

          if(lng != IABS(x - x_old))
          {
            work_frame++;
            if (work_frame == MAPCOUNT)
            {
              work_frame = 0;
            }
            x_old = x;
            y_old = y;
            continue;
          }

          if(this->CheckPath(player, work_frame, mask, get_index_from_pos(x_old, y_old), lng, dir_x, dir_y))
          { 
    work_frame++;
    if (work_frame == MAPCOUNT)
            {
      work_frame = 0;
            }
            x_old = x;
            y_old = y;
            continue;
          }
  
          {
            int start_y = y_old;
            int start_x = x_old;
            
            dir_y = ((dir_y > 0) ? FILL_STEP : -FILL_STEP);
            dir_x = ((dir_x > 0) ? FILL_STEP : -FILL_STEP);

            for(int j = 0; j < lng; j += FILL_STEP)
            {
              FillRect(this->mMapList[work_frame].map, mask, start_x, start_y);
              start_x += dir_x;
              start_y += dir_y;
            }
            FillRect(this->mMapList[work_frame].map, mask, x, y);
          }
        }
       }
    }

    work_frame++;
    if (work_frame == MAPCOUNT)
    {
      work_frame = 0;
    }
    x_old = x;
    y_old = y;
  }
}

void AStarSolver::ClearMap(unsigned char playerIndex)
{
 /**/
  int offset;
 for (int h = 0; h < MAPCOUNT ; h++)
  {
    for (int j = 0; j < HEIGHT ; j++)
    {
      offset = j * WIDTH;
      for (int i = 0; i < WIDTH ; i++)
      {
        if ((this->mMapList[h].map[offset + i] & 0x7) == playerIndex)
        {
          this->mMapList[h].map[offset + i] = 0;
        }
      }
    }
  }
}


#ifdef DEBUG
void AStarSolver::Render(CMatrix4 *pViewProj)
{
#ifndef STAR_RENDER
  return;
#else
 // assert (this->mMapList[mCurrentMap].map[XOFFSET][YOFFSET] == -1);
  int mmap = mCurrentMap ? mCurrentMap -1 : MAPCOUNT -2;
 int offset;
   for (int j = 0; j < HEIGHT ; j++)
   {
   offset = j * WIDTH;
   for (int i = 0; i < WIDTH ; i++)
   {
     //int k; 
     //for (k = 0 ; k < MAPCOUNT ; k++)
    // {
    //   if (this->mMapList[k].map[offset + i] != 0 )break;
    // }
    // if (k == MAPCOUNT) continue;
     if (this->FixedObstacles.map[offset + i] != 1) continue;
     //if (this->mMapList[mmap].map[offset + i] == 0 &&
       //  this->mMapList[mmap+1].map[offset + i] == 0) continue;
    // if (this->debugMap.map[i][j] >= 0) continue; 
     float x = (float)(i - XOFFSET) * CELL_SIZE;
     float y = (float)(j - YOFFSET) * CELL_SIZE;
     CMatrix4 out,out2;
     out.SetScale(0.5f,0.5f,1);
     out2.SetTranslate(x,y,0.1f);
     out *= out2 * *this->mParentTeam->GetTeamMatrix();
     out *= *pViewProj;
     CMeshManager::Instance()->Render(marker,&out);
   }
 }
#endif
}
#endif

int AStarSolver::FindPath(CPlayer *player, CVector3 *target, State *forState)
{
#define found 1
#define nonexistent -1
#define notStarted 0
  short int openList[WIDTH*HEIGHT+2]; //1 dimensional array holding ID# of open list items
	short int whichList[WIDTH*HEIGHT+2];  //2 dimensional array used to record 
// 		whether a cell is on the open list or on the closed list.
	short int openX[WIDTH*HEIGHT+2]; //1d array stores the x location of an item on the open list
	short int openY[WIDTH*HEIGHT+2]; //1d array stores the y location of an item on the open list
  float sample_time[WIDTH*HEIGHT+2]; // 2d czas samplowania
	short int parentX[WIDTH*HEIGHT+2]; //2d array to store parent of each cell (x)
	short int parentY[WIDTH*HEIGHT+2]; //2d array to store parent of each cell (y)
	short int Fcost[WIDTH*HEIGHT+2];	//1d array to store F cost of a cell on the open list
	short int Gcost[WIDTH*HEIGHT+2]; 	//2d array to store G cost for each cell.
	short int Hcost[WIDTH*HEIGHT+2];
 // int CostOffset[WIDTH*HEIGHT+2];
  	int onOpenList=0,onClosedList = 0, parentXval=0, parentYval=0,parentMap = mCurrentMap,
	a=0, b=0, m=0, u=0, v=0, temp=0, corner=0, numberOfOpenListItems=0,
	addedGCost=0, tempGcost = 0, path = 0, newOpenListItemID=0;;//, tempx,cellPosition,
  float addedTime = 0.0f;
  float tempSample_time = 0.0f;
//1. Convert location data (in pixels) to coordinates in the walkability array.
  CVector3 startPos;
  forState->GetCurrentPosition(&startPos);
	int startX = XOFFSET + ROUND(startPos.x/ CELL_SIZE);
	int startY = YOFFSET + ROUND(startPos.y/ CELL_SIZE);
	int targetX = XOFFSET + ROUND(target->x/ CELL_SIZE);
	int targetY = YOFFSET + ROUND(target->y/ CELL_SIZE);

  if(targetX < 0 || targetX >= WIDTH || targetY < 0 || targetY >= HEIGHT)
  {
    return nonexistent;
  }

//2.Quick Path Checks: Under the some circumstances no path needs to
//	be generated ...

  //this->ClearMap(playerIndex);

//	If starting location and target are in the same location...
	if (startX == targetX && startY == targetY )//&& pathLocation[pathfinderID] > 0)
  {
#ifdef DEBUG
    LogError("ASTAR:Stoje gdzie mam Stac");
#endif
		return notStarted;
  }
/*	if (startX == targetX && startY == targetY && pathLocation[pathfinderID] == 0)
		return nonexistent;*/
  memset(whichList, 0, sizeof(whichList));
//	If target square is unwalkable, return that it's a nonexistent path.
#if 0
  if (walkability[targetX][targetY] == unwalkable)
		goto noPath;

//3.Reset some variables that need to be cleared
	if (onClosedList > 1000000) //reset whichList occasionally
	{
   
		onClosedList = 10;	
	}
#endif

	onClosedList = onClosedList+2; //changing the values of onOpenList and onClosed list is faster than redimming whichList() array
	onOpenList = onClosedList-1;
//	pathLength [pathfinderID] = notStarted;//i.e, = 0
//	pathLocation [pathfinderID] = notStarted;//i.e, = 0
	Gcost[get_index_from_pos(startX , startY)] = 0; //reset starting square's G value to 0
  
//4.Add the starting location to the open list of squares to be checked.
	numberOfOpenListItems = 1;
	openList[1] = 1;//assign it as the top (and currently only) item in the open list, which is maintained as a binary heap (explained below)
	openX[1] = startX ; openY[1] = startY;
//  CostOffset[1] = 0;
  sample_time [get_index_from_pos(startX , startY)] = forState->GetEndTime() - NOW;

//5.Do the following until a path is found or deemed nonexistent.
  int parent_index = 0;
	while(1)

	{

  //6.If the open list is not empty, take the first cell off of the list.
  //	This is the lowest F cost cell on the open list.
	if (numberOfOpenListItems != 0)
	{

    //7. Pop the first item off the open list.
	parentXval = openX[openList[1]];
	parentYval = openY[openList[1]]; //record cell coordinates of the item
      parent_index = get_index_from_pos(parentXval , parentYval);
      parentMap = GetMapFromSampleTime(sample_time[parent_index]);
      if (parentMap >= MAPCOUNT)
      {
        parentMap = MAPCOUNT -1;
      }
	    whichList[parent_index] = onClosedList;//add the item to the closed list

    //	Open List = Binary Heap: Delete this item from the open list, which
    //  is maintained as a binary heap. For more information on binary heaps, see:
    //	http://www.policyalmanac.org/games/binaryHeaps.htm
	numberOfOpenListItems = numberOfOpenListItems - 1;//reduce number of open list items by 1	
		
    //	Delete the top item in binary heap and reorder the heap, with the lowest F cost item rising to the top.
	openList[1] = openList[numberOfOpenListItems+1];//move the last item in the heap up to slot #1
	v = 1;

    //	Repeat the following until the new item in slot #1 sinks to its proper spot in the heap.
	    while(1)
	{
	u = v;		
	if (2*u+1 <= numberOfOpenListItems) //if both children exist
	{
	 	//Check if the F cost of the parent is greater than each child.
		//Select the lowest of the two children.
		if (Fcost[openList[u]] >= Fcost[openList[2*u]]) 
          {
			v = 2*u;
          }
		if (Fcost[openList[v]] >= Fcost[openList[2*u+1]]) 
          {
			v = 2*u+1;		
	}
	      }
	else
	{
		if (2*u <= numberOfOpenListItems) //if only child #1 exists
		{
	 	//Check if the F cost of the parent is greater than child #1	
			if (Fcost[openList[u]] >= Fcost[openList[2*u]]) 
            {
				v = 2*u;
		}
	}
	      }
	if (u != v) //if parent's F is > one of its children, swap them
	{
		temp = openList[u];
		openList[u] = openList[v];
		openList[v] = temp;			
	}
	else
		break; //otherwise, exit loop
		
      } //reorder the binary heap


      //7.Check the adjacent squares. (Its "children" -- these path children
      //	are similar, conceptually, to the binary heap children mentioned
      //	above, but don't confuse them. They are different. Path children
      //	are portrayed in Demo 1 with grey pointers pointing toward
      //	their parents.) Add these adjacent child squares to the open list
      //	for later consideration if appropriate (see various if statements
      //	below).
      int index, offset;
      int costOffset = 0;
	    for (b = parentYval-1; b <= parentYval+1; b++)
      {
        offset = b * WIDTH;
        for (a = parentXval-1; a <= parentXval+1; a++)
        {
          //index = get_index_from_pos(a , b);
          index = offset + a;
          // If not off the map (do this first to avoid array out-of-bounds errors)
	        if (a >= 0 && b >= 0 && a < WIDTH && b < HEIGHT)
          {

            //	If not already on the closed list (items on the closed list have
            //	already been considered and can now be ignored).			
	          if (whichList[index] != onClosedList)
            { 
            //	If not a wall/obstacle square.

              char mapval = this->mMapList[parentMap].map[index];

              costOffset = 0;
              if (mapval > 0) continue;//costOffset = 8;
              if (mapval < 0 && mapval != (0x80 | (player->GetIndex() & 0x7)))
  {
                if (this->mParentTeam->GetPlayer(mapval & 0x7)->GetPriority() < player->GetPriority())
    {
      costOffset = 3;
    }
    else
    {
      costOffset = 1;
    }
  }

              //	If not already on the open list, add it to the open list.			
	            if (whichList[index] != onOpenList) 
	            {	
		//Create a new open list item in the binary heap.
		newOpenListItemID = newOpenListItemID + 1; //each new item has a unique ID #
		m = numberOfOpenListItems+1;
		openList[m] = newOpenListItemID;//place the new open list item (actually, its ID#) at the bottom of the heap
		openX[newOpenListItemID] = a;
		openY[newOpenListItemID] = b;//record the x and y coordinates of the new item
                //CostOffset[newOpenListItemID] = costOffset;
		//Figure out its G cost
		if (IABS(a-parentXval) == 1 && IABS(b-parentYval) == 1)
    {
                  addedTime = 0.053f /(0.3f/CELL_SIZE);
			addedGCost = 14 << costOffset;//cost of going to diagonal squares	
    }
		else	
    {
                  addedTime = 0.0375f /(0.3f/CELL_SIZE);
			addedGCost = 10 << costOffset;//cost of going to non-diagonal squares				
    }
		            Gcost[index] = Gcost[parent_index] + addedGCost;
                sample_time[index] = sample_time [parent_index] + addedTime;
		//Figure out its H and F costs and parent
		Hcost[openList[m]] = 10*(IABS(a - targetX) + IABS(b - targetY));
		            Fcost[openList[m]] = Gcost[index] + Hcost[openList[m]];
		            parentX[index] = parentXval;
                parentY[index] = parentYval;	

		//Move the new open list item to the proper place in the binary heap.
		//Starting at the bottom, successively compare to parent items,
		//swapping as needed until the item finds its place in the heap
		//or bubbles all the way to the top (if it has the lowest F cost).
		while (m != 1) //While item hasn't bubbled to the top (m=1)	
		{
            	
			//Check if child's F cost is < parent's F cost. If so, swap them.	
			if (Fcost[openList[m]] <= Fcost[openList[m/2]])
			{
				temp = openList[m/2];
				openList[m/2] = openList[m];
				openList[m] = temp;
				m = m/2;
			}
			else
				break;
		}
		numberOfOpenListItems = numberOfOpenListItems+1;//add one to the number of items in the heap

		//Change whichList to show that the new item is on the open list.
		            whichList[index] = onOpenList;
	}
            //8.If adjacent cell is already on the open list, check to see if this 
            //	path to that cell from the starting location is a better one. 
            //	If so, change the parent of the cell and its G and F costs.	
	else //If whichList(a,b) = onOpenList
	{
		//Figure out the G cost of this possible new path
			if (IABS(a-parentXval) == 1 && IABS(b-parentYval) == 1)
    {
                  addedTime = 0.053f /(0.3f/CELL_SIZE);
			addedGCost = 14 << costOffset;//cost of going to diagonal squares	
    }
		else	
    {
                  addedTime = 0.0375f /(0.3f/CELL_SIZE);
			addedGCost = 10 << costOffset;//cost of going to non-diagonal squares				
    }
		            tempGcost = Gcost[parent_index] + addedGCost;
		            tempSample_time = sample_time[parent_index] + addedTime;
		//If this path is shorter (G cost is lower) then change
		//the parent cell, G cost and F cost. 		
		            if (tempGcost < Gcost[index]) //if G cost is less,
		{
			            parentX[index] = parentXval; //change the square's parent
			            parentY[index] = parentYval;
			            Gcost[index] = tempGcost;//change the G cost			
                  sample_time[index] = tempSample_time;
			//Because changing the G cost also changes the F cost, if
			//the item is on the open list we need to change the item's
			//recorded F cost and its position on the open list to make
			//sure that we maintain a properly ordered open list.
			for (int x = 1; x <= numberOfOpenListItems; x++) //look for the item in the heap
			{
			if (openX[openList[x]] == a && openY[openList[x]] == b) //item found
			{
				              Fcost[openList[x]] = Gcost[index] + Hcost[openList[x]];//change the F cost
				
				//See if changing the F score bubbles the item up from it's current location in the heap
				m = x;
				while (m != 1) //While item hasn't bubbled to the top (m=1)	
				{
					//Check if child is < parent. If so, swap them.	
					if (Fcost[openList[m]] < Fcost[openList[m/2]])
					{
						temp = openList[m/2];
						openList[m/2] = openList[m];
						openList[m] = temp;
						m = m/2;
					}
					else
						break;
				} 
				break; //exit for x = loop
			} //If openX(openList(x)) = a
			} //For x = 1 To numberOfOpenListItems
		}//If tempGcost < Gcost(a,b)
	}//else If whichList(a,b) = onOpenList	
	            // }//If not cutting a corner
	            //}//If not a wall/obstacle square.
	}//If not already on the closed list 
	}//If not off the map
	}//for (a = parentXval-1; a <= parentXval+1; a++){
	}//for (b = parentYval-1; b <= parentYval+1; b++){

	}//if (numberOfOpenListItems != 0)

    //9.If open list is empty then there is no path.	
	else
	{
#ifdef DEBUG
      LogError("ASTAR: Path Not Found from %f, %f to: %f, %f", startPos.x, startPos.y, target->x,target->y);
#endif
		path = nonexistent; break;
	}  

	//If target is added to open list then path has been found.
	  if (whichList[get_index_from_pos(targetX , targetY)] == onOpenList)
	{
		path = found; break;
	}

	}

	//Do until path is found or deemed nonexistent

//10.Save the path if it exists.
	if (path == found)
	{

  //a.Working backwards from the target to the starting location by checking
  //	each cell's parent, figure out the length of the path.
	  int pathX = targetX;
    int pathY = targetY;
    int tempX,tempY;
    int stateChanges = 0;
    int currentDir = 0xff;
    int tempDir;
    int index, i;

	do
	{
      index = get_index_from_pos(pathX,pathY);
  #ifdef DEBUG
      this->debugMap.map[index] = -1;
  #endif
      tempX = parentX[index];		
		  tempY = parentY[index];
      tempDir = (int)DeltaToDir[pathX - tempX +1][pathY-tempY +1];
      if ( currentDir == 0xff )
    {
      currentDir = tempDir;
    }
    else
    {
      if (currentDir != tempDir)
      {
        stateChanges++;
        currentDir = tempDir;
      }
    }
    pathX = tempX;
      pathY = tempY;
  }
    while (pathX != startX || pathY != startY);

  assert(stateChanges < 50);
    int stateCount = stateChanges;
  Direction stateDirections[50];
  float stateDurations[50];

    {
      int stateCells = 0;
  //  char mapval;
  currentDir = 0xff;
  pathX = targetX; pathY = targetY;
  do
	{
      index = get_index_from_pos(pathX, pathY);
  #ifdef DEBUG
      this->debugMap.map[index] = -1;
  #endif
      tempX = parentX[index];		
		  tempY = parentY[index];
      assert((pathY - tempY + 1) < 3);
        tempDir = (int)DeltaToDir[pathX - tempX + 1][pathY-tempY +1];
      assert(tempDir < 8);
  /*     
      char mapval = this->mMapList[GetMapFromSampleTime(sample_time[index])].map[index];
      if (mapval != 0 && mapval < 0 &&
          (this->mParentTeam->GetPlayer(mapval & 0x7)->GetPriority() > player->GetPriority()))
      {
       // pathX = tempX;
       // pathY = tempY;
        continue;
      }
  */   
      path += Gcost[get_index_from_pos(tempX,tempY)];
    if ( currentDir == 0xff)
    {
      currentDir = tempDir;
        stateCells++;
    }
    else
    {
      if (currentDir != tempDir)
      {
        stateDirections[stateChanges] = (Direction)currentDir; 
        if ((currentDir & 1) != 0) // wszystkie niepazyste sa pod katem
        {
            stateDurations[stateChanges] = (float)(stateCells)* 0.053f/( 0.3f/CELL_SIZE);
        }
        else
        {
            stateDurations[stateChanges] = (float)(stateCells)* 0.0375f/( 0.3f/CELL_SIZE);
        }
        stateChanges--;
        currentDir = tempDir;
            stateCells = 1;
      }
      else
      {
        stateCells++;
      }
    }
    pathX = tempX;
    pathY = tempY;
  }
    while (pathX != startX || pathY != startY);

  stateDirections[0] = (Direction)currentDir;
  if ((currentDir & 1) != 0) // wszystkie niepazyste sa pod katem
  {
      stateDurations[0] = (float)(stateCells) * 0.053f/( 0.3f/CELL_SIZE);
  }
  else
  {
      stateDurations[0] = (float)(stateCells) * 0.0375f/( 0.3f/CELL_SIZE);
  }
    }

    {
    float deltax = target->x - startPos.x - (float)(targetX - startX) * CELL_SIZE;
    float deltay = target->y - startPos.y - (float)(targetY - startY) * CELL_SIZE;
      int bestXstate = 0xff, bestYstate = 0xff;
      
    for (i = 0; i < stateCount+1; i++)
  {
    if ( stateDirections[i] == ANGLE_90 || stateDirections[i] == ANGLE_270)
    {
      bestXstate = i;
      break;
    }

    if ( stateDirections[i] != ANGLE_0 && stateDirections[i] != ANGLE_180)
    {
      bestXstate = i;
    }
  }
    for (i = 0; i < stateCount+1; i++)
  {
    if ( stateDirections[i] == ANGLE_0 || stateDirections[i] == ANGLE_180)
    {
      bestYstate = i;
      break;
    }
    if ( stateDirections[i] != ANGLE_90 && stateDirections[i] != ANGLE_270)
    {
      bestYstate = i;
    }
  }
  if (bestXstate != 0xff)
  {
    stateDurations[bestXstate] +=(deltax/CDV[stateDirections[bestXstate]].x)*0.0375f/( 0.3f/CELL_SIZE);
  }
  if (bestYstate != 0xff)
  {
    stateDurations[bestYstate] +=(deltay/CDV[stateDirections[bestYstate]].y)*0.0375f/( 0.3f/CELL_SIZE);
  }
    }
    
    for (i = 0; i < stateCount+1; i++)
    { 
      forState->SetEndDir(stateDirections[i]);
      forState = StateManager::Instance()->GetState(RUN_FAST, forState, player, false);
      while (forState->GetDuration() < stateDurations[i])
  {
        stateDurations[i] -=  forState->GetDuration();
        forState = StateManager::Instance()->GetState(RUN_FAST, forState, player, false);
      }
     // forState->SetDir(stateDirections[i]);
    forState->SetEndTime(forState->GetStartTime() + stateDurations[i]);
  }
  forState->SetProposedNext(STATE_IDLE);


/*
  #ifdef DEBUG
    float len;
    CVector3 lastPos;
    forState->GetPositionByTime(&lastPos,forState->GetEndTime());
    lastPos -= *target;
    
    len=lastPos.Length();
    if ( len > 0.3f )
    {
    LogError("Possible teleportation : %lf",len);
    }
  #endif
*/

 /* CVector3 realPos;
  forState->GetPositionByTime(&realPos,forState->GetEndTime());
  CVector3 deltaPos = *target - realPos;
  *forState->GetStartPosition() += deltaPos;*/
  /*
		//Look up the parent of the current cell.	
		tempx = parentX[pathX][pathY];		
		pathY = parentY[pathX][pathY];
		pathX = tempx;

		//Figure out the path length
		pathLength[pathfinderID] = pathLength[pathfinderID] + 1;
	}
	while (pathX != startX || pathY != startY);

  //b.Resize the data bank to the right size in bytes
	pathBank[pathfinderID] = (int*) realloc (pathBank[pathfinderID],
		pathLength[pathfinderID]*8);

  //c. Now copy the path information over to the databank. Since we are
  //	working backwards from the target to the start location, we copy
  //	the information to the data bank in reverse order. The result is
  //	a properly ordered set of path data, from the first step to the
  //	last.
	pathX = targetX ; pathY = targetY;
	cellPosition = pathLength[pathfinderID]*2;//start at the end	
	do
	{
	cellPosition = cellPosition - 2;//work backwards 2 integers
	pathBank[pathfinderID] [cellPosition] = pathX;
	pathBank[pathfinderID] [cellPosition+1] = pathY;

  //d.Look up the parent of the current cell.	
	tempx = parentX[pathX][pathY];		
	pathY = parentY[pathX][pathY];
	pathX = tempx;

  //e.If we have reached the starting square, exit the loop.	
	}
	while (pathX != startX || pathY != startY);	*/

  //11.Read the first path step into xPath/yPath arrays
	//ReadPath(pathfinderID,startingX,startingY,1);

	}
	return path;


//13.If there is no path to the selected target, set the pathfinder's
//	xPath and yPath equal to its current location and return that the
//	path is nonexistent.
//	xPath[pathfinderID] = startingX;
//	yPath[pathfinderID] = startingY;
  LogMessage("ASTAR:Nie znalazlem patha");
	return nonexistent;
  
#undef found
#undef nonexistent
#undef notStarted
}

unsigned char AStarSolver::GetMapFromSampleTime(float time)
{
  time/=MAP_DELTA;
  unsigned char delta =(unsigned char)MAX(0,time);
  if (delta + mCurrentMap >= MAPCOUNT)
  {
    delta +=  ((int)mCurrentMap - MAPCOUNT);
  } 
  if(delta >= MAPCOUNT) delta =  (mCurrentMap ? mCurrentMap - 1 : MAPCOUNT - 1);
  //if(delta < 0) delta =  mCurrentMap;
  return delta;
}


void AStarSolver::PurgeMap()
{
  for (int i = 0; i < MAPCOUNT; i++)
 {
   memcpy(mMapList[i].map, &FixedObstacles.map, sizeof(FixedObstacles.map));
 }
}

/* tylko pod kontem 45 stopni lub w pionie i poziomie */
int AStarSolver::GetCost(CPlayer *player, char *map, AStarPoint *src, AStarPoint *dst)
{
  char cmap;
  int a, b, parent_a, parent_b;
  int costOffset, cost = 0;
  int lng, step_a, step_b;

  step_a = (dst->y - src->y);
  step_b = (dst->x - src->x);

  a = IABS(step_a);
  b = IABS(step_b);
  lng = MAX(a, b);

  step_b = (step_b ? ((step_b > 0) ? 1 : -1) : 0);
  step_a = (step_a ? ((step_a > 0) ? 1 : -1) : 0);

  parent_a = src->x;
  parent_b = src->y;
  for(int i = 0; i < lng; i++)
  {

    a = parent_a + step_a;
    b = parent_b + step_b;
    if (a < 0 || b < 0) return 1000000;
    cmap = map[get_index_from_pos(a,b)];
    costOffset = 0;
    if (cmap > 0)
    {
      //costOffset = 8;
      return 1000000;
    }
    else
    {
      if (cmap < 0)
      {
        if (this->mParentTeam->GetPlayer(cmap & 0x7)->GetPriority() < player->GetPriority())
        {
          costOffset = 3;
        }
        else
        {
          costOffset = 1;
        }

      }
    }
    if (IABS(a-parent_a) == 1 && IABS(b-parent_b) == 1)
    {
			cost += 14 << costOffset;//cost of going to diagonal squares	
    }
		else	
    {
			cost += 10 << costOffset;//cost of going to non-diagonal squares				
    }
    parent_a = a;
    parent_b = b;
    
  }

  return cost;
}

int AStarSolver::RunAway(CPlayer *player, char playerMask, float startTime, float endTime, float distance, CVector3 *out)
{
  int cost;
  bool isPrev = false;
  AStarPoint src, dst;
  CVector3 originalPos, target;
  Direction CollisionDir;
  char *map;
  State *StartState; 
  TurnAngle EscapeAngle[] =
  {
    RIGHT_90,
    LEFT_90,
    LEFT_45,
    RIGHT_135,
    RIGHT_45,
    LEFT_135,
    NO_TURN,
    LEFT_180
  };


  if(playerMask < 0)
  {
    StartState = this->mParentTeam->GetPlayer(playerMask & 0x7)->GetCurrentState()->
                                                    GetStateByTime(startTime, &isPrev);
    if(!StartState || isPrev) return 0; 
    CollisionDir = StartState->GetDir();
  }

  StartState = player->GetCurrentState()->GetStateByTime(startTime, &isPrev);
  
  if(!StartState || isPrev) return 0;

  map = this->mMapList[GetMapFromSampleTime(startTime)].map;
  
  StartState->GetPositionByTime(&originalPos, startTime);
  src.x = XOFFSET + ROUND(originalPos.x/ CELL_SIZE);
	src.y = YOFFSET + ROUND(originalPos.y/ CELL_SIZE);
	  
  StartState->SetEndTime(startTime);
  StartState->SetNextState(NULL);
  
  const int maxCost = (int)(distance * 14.0f/CELL_SIZE);
  
  
  for (int nDir = 0 ; nDir < 8; nDir++ )
  {
    if(playerMask < 0)// && CollisionDir == i)
    {
      nDir = StartState->TurnAnyDirByAngle(EscapeAngle[nDir], CollisionDir, NULL);
      if (nDir == 7)//StartState->TurnAnyDirByAngle(LEFT_180, nDir, NULL) == CollisionDir)
    {
      continue;
  }
    }
    
    target = originalPos + CDV[nDir] * distance;
    dst.x =  XOFFSET + ROUND(target.x / CELL_SIZE);
    dst.y =  YOFFSET + ROUND(target.y / CELL_SIZE);
    if(dst.x < 0 || dst.x >= WIDTH || dst.y < 0 || dst.y >= HEIGHT)
  {
      continue;
  }

    cost = GetCost(player, map, &src, &dst);
    
    if (cost > 0 && cost < maxCost)
    {
      out->Set(&target);
  return 1;
    }
  }

  return 0;
}

E:\Project\Kopia (5) VBEngine\Ai\AStarSolver.h
#ifndef _ASTARSOLVER_H
#define _ASTARSOLVER_H

/*
class       :
description :

methods     :

*/
#define WIDTH     128 
#define HEIGHT    128 
#define MAPCOUNT  64 // przy samplowaniu co 0.1 sekundy map na 6.4 sekundy w przyszlosc
#define MAP_DELTA 0.1f
#define XOFFSET   64
#define YOFFSET   0
#define CELL_SIZE 0.15f
/* AStar node info:
   BIT 7     sign if < 0 player blocking > 0 fixed obstacle
   BIT 3 - 6  something to be decided yet :P
   BIT 0 - 2 player number or 
 */

struct AStarMap
{
  char map[WIDTH*HEIGHT];
  float time;
};

struct AStarPoint
{
  short x,y;
};

// solwer A* pracuje na dynamicznej mapie WIDTH * HEIGHT * MAPCOUNT celek 
// wype³nianych co klatke przez zawodników 

class AStarSolver 
#ifdef DEBUG
  :public SceneObject
#endif
{
 unsigned char mCurrentMap; // index aktualnej mapy
 AStarMap mMapList[MAPCOUNT]; // lista map 
 CTeam *mParentTeam;  // Team dla któego sie oblicza
 AStarMap FixedObstacles; // mapa ze sta³ymi przeszkodami
#ifdef DEBUG
 AStarMap debugMap;
 HMesh marker;
#endif
 int GetCost(CPlayer *player, char *map, AStarPoint *src, AStarPoint *dst);
 bool CheckPath(CPlayer *player, unsigned char work_frame, char mask , short index, int lenght, short step_x, short step_y = 0);

 int RunAway(CPlayer *player, char playerMask, float startTime, float endTime, float distance, CVector3 *out);
public:
  AStarSolver(CTeam *team);
  ~AStarSolver();
  void Update();
  // wype³nia mape dla danego playera
  void FillMap(unsigned char playerIndex);
  // czyœci mape dla danego playera
  void ClearMap(unsigned char playerIndex);
  // znajduje œcie¿ke dla danego playera
  int FindPath(CPlayer *player, CVector3 *target, State* forState);
  // pobiera mape z czasu samplowania
  unsigned char GetMapFromSampleTime(float time);
  // czyœci ca³¹ mape
  void PurgeMap(void);
  
#ifdef DEBUG
  void Render(CMatrix4 *pViewProj);
#endif
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\State.cpp
#include "..\config.h"

#include <assert.h>

#include "..\utility\misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"
#include "..\utility\ctime.h"
#include "..\utility\Tools.h"
#include "..\Utility\logger.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"


#include "..\graphics\meshmanager.h"

#include "..\graphics\animation.h"
#include "..\graphics\animationmanager.h"

#include "..\graphics\SceneObject.h"


#include "States\States.h"
#include "..\Core\zawodnik.h"
#include "..\Core\Team.h"

float RotationTab[8] = 
{ 0.0f,
  5.497787f,
  4.712389f,
  3.926991f,
  3.141593f,
  2.356194f,
  1.570796f,
  0.785398f
};

State::State(State *prev, CPlayer *playerPtr)
{  
  this->player = playerPtr;
  if( prev == NULL)
  {
    mStartTime = CTime::Instance()->GetTime();
    mPrev = NULL;
    mNext = NULL;//this;//hack
    StartPosition.Set(0.0f,0.0f,0.0f);
    mdir = ANGLE_0;
    this->mEndDir = this->mdir;
  }
  else
  {
    mPrev = prev;
    mStartTime = prev->mEndTime;
    mPrev->mNext = this;
    mNext = NULL;
    mdir = prev->mEndDir;
    
    //this->TurnDirByAngle(this->GetTurnAngleFromState(mPrev->mCurrent));

    //if (mPrev->mdir == ANGLE_FREE) 
    if (mdir == ANGLE_FREE) 
    {
      this->mFreeAngle = mPrev->mFreeAngle;
    }
    
    prev->GetPositionByTime(&StartPosition, mStartTime);
    LastPosition = StartPosition;
    //GetPositionByTime(&LastPosition, mEndTime);

    this->mEndDir = this->mdir;
  }
  mRepetitionCount = 0;
  mProposedNext = STATE_NONE;

  this->mCurrentAnimStartTime = this->mStartTime;
  this->mRepetitionAnim = 0;
  this->mCurrentAnimEndTime = 0.0f ;
  
  this->mTimeScale   = this->player->speed_scale ;// 1.0f;
  this->mOffsetScale = this->player->speed_scale ;// 1.0f; 1.0f / this->mTimeScale;

  mCurrent = STATE_NONE;

}

State::~State(void)
{
 // assert(this->player->GetCurrentState() != this);
  if( mNext )
  {
    State *last = this->GetLast();
    State *prev;
    while (last != this)
    {
      prev = last->GetPrev();
      delete last;
      last = prev;
    }
  }
  if( mPrev )
  {
    mPrev->mNext = NULL;
  }
};

CVector3 *State::OffsetRotateByDir(CVector3 *dst, CVector3 *src, Direction dir, float angle )
{
  DIE(NULL!=dst);
  DIE(NULL!=src);
  DIE(src!=dst);
  
  switch(dir)
  {
    case ANGLE_0:
        (*dst)=(*src);
        return dst;
    case ANGLE_45:/* right */
        /* cos315 == -sin315 */
        /* dst->x = src->x * cos315 - src->y * sin315; */
        dst->x = (src->x + src->y) * cos315;
        /* dst->y = src->x * sin315 + src->y * cos315; */
        dst->y = (src->x - src->y) * sin315;
        dst->z = src->z;
        return dst;
    case ANGLE_90:
        dst->z = src->z;
        dst->x = src->y;
        dst->y =-src->x;
        return dst;
    case ANGLE_135:
        /* cos225 == sin225 */
        /* dst->x = src->x * cos225 - src->y * sin225; */
        dst->x = (src->x - src->y) * cos225;
        /* dst->y = src->x * sin225 + src->y * cos225; */
        dst->y = (src->x + src->y) * sin225;
        dst->z = src->z;
        return dst;
    case ANGLE_180:
        (*dst)=-1.0f*(*src);
        return dst;
    case ANGLE_225:
        /* -cos135 == sin135 */
        /* dst->x = src->x * cos135 - src->y * sin135; */
        dst->x = (src->x + src->y) * cos135;
        /* dst->y = src->x * sin135 + src->y * cos135; */
        dst->y = (src->x - src->y) * sin135;
        dst->z = src->z;
        return dst;
    case ANGLE_270:
        dst->x = -src->y;
        dst->y =  src->x;
    dst->z =  src->z;
        return dst;     
   case ANGLE_315:
        /* cos45 == sin45 */
        /* dst->x = src->x * cos45 - src->y * sin45; */
        dst->x = (src->x - src->y) * cos45;
        /* dst->y = src->x * sin45 + src->y * cos45; */
        dst->y = (src->x + src->y) * sin45;
        dst->z = src->z;
        return dst;
    case ANGLE_FREE:
      {
        float c =  cosf( angle );
        float s =  sinf( angle );
        dst->x = (src->x * c - src->y *s);
        dst->y = (src->x * s + src->y *c) ;
        dst->z = src->z;
        return dst;
      }
    default:
        (*dst)=(*src);
        return dst;
    }
}

State *State::Update()
{
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}

void State::UpdateControls(unsigned int Key)
{
  return;
}

State * State::GetNext(bool alloc)
{
  if (alloc && !mNext)
  {
    if(IsStateIdle(this->mCurrent) && mProposedNext == STATE_NONE)
    {
     return NULL;
    }   
    return StateManager::Instance()->GetState(mProposedNext,this,player);
  }
  return mNext;
}

State * State::GetLast(void)
{
  State *tmp = this;
  while(tmp->mNext)
  {
    tmp = tmp->mNext;
  }
  return tmp;
}

void State::GetMorphState(MorphState *morph_state)
{

  float current_time = NOW;
  //float delta_T = current_time - mStartTime;
  float delta_T = current_time - this->mCurrentAnimStartTime;

  if (delta_T < 0) 
  {
    delta_T = 0.0000001f;  // weiiiiiiird bug :/
  }  
  
  delta_T /= this->mTimeScale;

  if (delta_T < 0) 
  {
    delta_T = 0.0000001f;  // weiiiiiiird bug :/
  }

  if(delta_T < EPSILON)
  {
    morph_state->first = GetFirstFrame();
  }
  else
  {
    morph_state->first = GetFrameByTime(delta_T);

    if (morph_state->first == NULL)
    {
      DIE(!"Nowa Animacjia");
      mNext = GetNext(true);
      DIE(mNext != this);
      mNext->GetMorphState(morph_state);
      return;
    }
  }

  morph_state->second = GetFollowingFrameByTime(delta_T);

  if (morph_state->second == NULL)
  {
    morph_state->second = this->GetNextFrame();
  }
  else
  {
    if(this->mEndTime < current_time)
    {
      morph_state->second = this->GetNextFrame();
    }
  }

  morph_state->alpha  = (delta_T - morph_state->first->start_time)/ morph_state->first->duration ;
  morph_state->alpha = MAX(morph_state->alpha, 0.0f);
  morph_state->alpha = MIN(morph_state->alpha, 1.0f);

  
}

Frame *State::GetNextFrame()
{
  HAnimation mNextAnim;

  if(this->mNext && this->mEndTime <= NOW)
  {
    mNextAnim = this->mNext->mCurrentAnim;
  }
  else
  {
    if(this->mProposedNext != STATE_NONE && this->mProposedNext != this->mCurrent)
    {
      mNextAnim = this->player->GetStateAnimationHandler(this->mProposedNext, 0);
    }
    else
    {
      mNextAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
    }
  }

  return AnimationManager::Instance()->GetAnimation(mNextAnim)->GetFirstFrame();
}

float State::GetRotationAngle(float anim_step)
{
  if (this->mdir == ANGLE_FREE)
  {
    return mFreeAngle;
  }
  else
  {
    return RotationTab[mdir] + anim_step;
  }
}

float State::GetCurrentPosition(CVector3 *pos)
{
  return GetPositionByTime(pos, NOW);
}

float State::GetPositionByTime(CVector3 *pos, float current_time)
{
  float delta_T;
    
  if (mPrev && mPrev->mEndTime < mStartTime)
  {
    DIE(mPrev->mEndTime < mStartTime && "Klania sie przepennienie stosu");
    *pos = LastPosition;
    return GetRotationAngle(0.0f);
  }

  if (current_time < mStartTime ) 
  { 
    return mPrev ? mPrev->GetPositionByTime(pos, current_time) : GetRotationAngle(0.0f);
  }

  if (current_time > mEndTime ) 
  {
    if(mNext)
    {
      return mNext->GetPositionByTime(pos, current_time);
    }
    else
    {
/*
      if(mProposedNext != STATE_NONE && (mNext = GetNext(true)))
      {
        return mNext->GetPositionByTime(pos, current_time);
      }
*/
      //LogMessage("GetPositionByTime: Call time touch no exist states !");
      *pos = LastPosition;
      return GetRotationAngle(0.0f);
    }
  }

  delta_T = current_time - this->mCurrentAnimStartTime;

  if (delta_T < EPSILON)
  {
    *pos = StartPosition;
    LastPosition.Set(pos);
    return GetRotationAngle(0.0f);
  }
/*
  if (mRepetitionCount > 0)
  {
    //delta_T -= mAnimation->GetDuration() * mRepetitionCount;
  }
*/
  delta_T /= this->mTimeScale;

  Frame *first;

  if (delta_T < 0)
  {
    delta_T = 0.0000001f;  // weiiiiiiird bug :/
  }
  
  first = GetFrameByTime(delta_T);

  float alpha = (delta_T - first->start_time* this->mTimeScale) / first->duration* this->mTimeScale;
  alpha = MAX(alpha, 0.0f);
  alpha = MIN(alpha, 1.0f);

  CVector3 tpos = first->total_offset + alpha * first->Offset;
  
  this->OffsetRotate(&tpos,pos);

  *pos *= this->mOffsetScale;
  (*pos) += StartPosition;

  LastPosition = *pos;
  return GetRotationAngle(first->total_rotation);
}

Direction State::KeyToDir(unsigned int Key)
{
  if ((Key & VBK_UP) != 0)
  {
    if ((Key & VBK_LEFT) != 0)
    {
     return ANGLE_315;
    } else
    if((Key & VBK_RIGHT) != 0)
    {
      return ANGLE_45;
    }
    else
      return ANGLE_0;

  }
  else
  if ((Key & VBK_DOWN) != 0)
  {
    if ((Key & VBK_LEFT) != 0)
    {
     return ANGLE_225;
    } else
    if((Key & VBK_RIGHT) != 0)
    {
      return ANGLE_135;
    }
    else
      return ANGLE_180;
  }
  if ((Key & VBK_LEFT) != 0)
    return ANGLE_270;
  if((Key & VBK_RIGHT) != 0)
    return ANGLE_90;
  return ANGLE_0;
}


void State::SetNextState(State *newState) 
{
  if(this->mCurrent == PRZYJECIE_SCINA ||
     this->mCurrent == PRZYJECIE_END_SCINA ||
     this->mCurrent == PRZYJECIE_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_END_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_SKOK ||
     this->mCurrent == PRZYJECIE_END_SKOK ||
     this->mCurrent == PRZYJECIE_GORNE ||
     this->mCurrent == PRZYJECIE_END_GORNE ||
     this->mCurrent == PRZYJECIE_DOLNE ||
     this->mCurrent == PRZYJECIE_END_DOLNE ||
     this->mCurrent == PRZYJECIE_KOLANA ||
     this->mCurrent == PRZYJECIE_END_KOLANA ||
     this->mCurrent == PRZYJECIE_STOPA ||
     this->mCurrent == PRZYJECIE_END_STOPA ||
     this->mCurrent == PRZYJECIE_BLOK ||
     this->mCurrent == PRZYJECIE_END_BLOK) return;

  if (mNext) delete mNext;
  mNext = newState;
  if (!mNext) return;
  mNext->mPrev = this;
  mNext->mStartTime = this->mEndTime;
  mNext->mCurrentAnimStartTime = this->mEndTime;

 // mNext->mdir = this->mdir;
//  mNext->mFreeAngle = this->mFreeAngle;
  GetPositionByTime(&mNext->StartPosition, mEndTime);
  mNext->mEndTime = mNext->mStartTime + mNext->GetDuration();
  mNext->mCurrentAnimEndTime = mNext->mEndTime;
//  mProposedNext = RUN_FAST;
  if (mNext->mNext) mNext->RecalcNextState();
}

void State::RecalcNextState()
{
  if(!mNext) return;
  mNext->mPrev = this;
  mNext->mStartTime = this->mEndTime;
  mNext->mCurrentAnimStartTime = this->mEndTime;
  GetPositionByTime(&mNext->StartPosition, mEndTime);
  mNext->mEndTime = mNext->mStartTime + mNext->GetDuration();
  mNext->mCurrentAnimEndTime = mNext->mEndTime;
// mNext->mFreeAngle = this->mFreeAngle;
 // mNext->mdir = this->mdir;
  if (mNext->mNext) mNext->RecalcNextState();
}


enum TurnAngle State::GetTurnAngleFromDirs(Direction Dir, Direction Current)
{
  int deltaDir = (int)Dir - (int) Current;
  if (deltaDir > 4)
  {
    deltaDir -= 8;
  }
  if (deltaDir < -4)
  {
    deltaDir += 8;
  }
  switch (deltaDir)
  {
    case -4: return LEFT_180;
    case -3: return LEFT_135;
    case -2: return LEFT_90;
    case -1: return LEFT_45;
    case  1: return RIGHT_45;
    case  2: return RIGHT_90;
    case  3: return RIGHT_135;
    case  4: return RIGHT_180;
    case  0:
    default:  return NO_TURN; 
  }
}

States State::GetRotationStateFromDir(Direction dir)
{
  int deltaDir = (int)dir - (int) this->mEndDir;
  if (deltaDir > 4)
  {
    deltaDir -=8;
  }
  if (deltaDir < -4)
  {
    deltaDir +=8;
  }
  switch (deltaDir)
  {
    case -4: return TURN_LEFT_180;
    case -3: return TURN_LEFT_135;
    case -2: return TURN_LEFT_90;
    case -1: return TURN_LEFT_45;
    case  0: return RUN_FAST;
    case  1: return TURN_RIGHT_45;
    case  2: return TURN_RIGHT_90;
    case  3: return TURN_RIGHT_135;
    case  4: return TURN_RIGHT_180;
  }
  return STATE_NONE;
}

enum TurnAngle State::GetTurnAngleFromState(States Rot)
{
  switch(Rot)
  {
    case STOP_FAST_TURN_180:
    case TURN_LEFT_180:  return LEFT_180;
    case TURN_LEFT_135:  return LEFT_135;
    case TURN_LEFT_90:   return LEFT_90;
    case TURN_LEFT_45:   return LEFT_45;
    case TURN_RIGHT_45:  return RIGHT_45;
    case TURN_RIGHT_90:  return RIGHT_90;
    case TURN_RIGHT_135: return RIGHT_135;
    case TURN_RIGHT_180: return RIGHT_180;
    default:
      return NO_TURN;
  }
}

bool State::CheckFrontiers(enum TurnAngle *turn)
{
  if (turn && (this->LastPosition.y <= 0.3f || this->LastPosition.y >= 17.0f ||
      this->LastPosition.x >= 7.5f || this->LastPosition.x <= -7.5f ))
  {
    CVector3 out, addpos;
    int trgDir = (int)this->mdir;

    addpos.Set(this->player->GetOffset(RUN_FAST));
    if(*turn != NO_TURN)
    {
      trgDir += *(int *)turn;
      if (trgDir <0)
      {
        trgDir +=8;
      }
      if (trgDir >7)
      {
        trgDir -=8;
      }
    }
    this->OffsetRotateByDir(&out, &addpos, (Direction)trgDir);
    out += this->LastPosition;
    if ( !(out.y >= 0.3f && out.y <= 17.0f && out.x <= 7.5f && out.x >= -7.5f ) )
    {
      *turn = NO_TURN;
      return false;
    }
  }
  return true;
}

bool State::CheckFrontiers(enum Direction dir, float angle )
{
  if (this->LastPosition.y <= 0.3f || this->LastPosition.y >= 17.0f ||
      this->LastPosition.x >= 7.5f || this->LastPosition.x <= -7.5f )
  {
    CVector3 out, addpos;
    addpos.Set(this->player->GetOffset(RUN_FAST));
    this->OffsetRotateByDir(&out, &addpos, dir , angle );
    out += this->LastPosition;
    if ( !(out.y >= 0.3f && out.y <= 17.0f && out.x <= 7.5f && out.x >= -7.5f ) )
    {
      return false;
    }
  }
  return true;
}


void State::TurnDirByAngle(TurnAngle angle)
{
  if(this->mdir == ANGLE_FREE)
  {
    this->mFreeAngle+=TurnFreeAngeByTurnAngle(angle);
    return;
  }
  int trgDir = (int)this->mdir;
  if(angle != NO_TURN)
  {
    trgDir += (int)angle;
    if (trgDir <0)
    {
      trgDir +=8;
    }
    if (trgDir >7)
    {
      trgDir -=8;
    }  
    this->mdir = (Direction) trgDir;
    this->mEndDir = this->mdir;
  }  
}

float State::TurnFreeAngeByTurnAngle(TurnAngle angle)
{  
  switch(angle)
  {
    case LEFT_180:  return  -PI;  break;
    case LEFT_135:  return  -PI * 0.75f; break;
    case LEFT_90:   return  -PI * 0.5f;  break;
    case LEFT_45:   return  -PI * 0.25f; break;
    case RIGHT_45:  return   PI * 0.25f; break;
    case RIGHT_90:  return   PI * 0.5f;  break;
    case RIGHT_135: return   PI * 0.75f; break;
    case RIGHT_180: return   PI; break;
    default: return 0.0f;
  }

};

Direction State::TurnAnyDirByAngle(TurnAngle angle, Direction inDir, float* freeAngle  )
{
  if(inDir == ANGLE_FREE)
  {
    if(freeAngle)
    {
      *freeAngle += TurnFreeAngeByTurnAngle(angle);
    }
    return ANGLE_FREE;
  }
  int trgDir = (int)inDir;
  if(angle != NO_TURN)
  {
    trgDir += (int)angle;
    if (trgDir <0)
    {
      trgDir +=8;
    }
    if (trgDir >7)
    {
      trgDir -=8;
    }  
  }
  return (Direction) trgDir;
}


Direction State::InverseTurnByAngle(Direction dir, TurnAngle angle)
{
  if(dir == ANGLE_FREE)
  {
    return ANGLE_FREE;
  }
  int trgDir = (int)dir - (int)angle;
  if (trgDir <0)
  {
    trgDir +=8;
  }
  if (trgDir >7)
  {
    trgDir -=8;
  }
  return (Direction) trgDir;
}


void State::SetTimeScale(float time_scale) 
{
  mTimeScale = time_scale;
  mEndTime = mStartTime + (mEndTime- mStartTime) * time_scale;
}

void State::SetFreeAngle(float angle, bool setEndDir)
{
  this->mdir = ANGLE_FREE;
  this->mFreeAngle = angle;
  if(setEndDir)
  {
    this->mEndDir = ANGLE_FREE;
  }
}

State* State::GetStateByTime(float time, bool *isPrev)
{
  if (time < mStartTime ) 
  {
    if(isPrev) *isPrev = true;
    return mPrev ? mPrev->GetStateByTime(time) : NULL;              
  }
  if (time > mEndTime ) 
  {
    if(isPrev) *isPrev = false;
    if(mNext) return mNext->GetStateByTime(time);
    if(this->IsCurrentIdle()) return this;
    return NULL;
  }
  return this;
}

void State::SetProposedNext(States st)
{
  if(this->mCurrent == PRZYJECIE_SCINA ||
     this->mCurrent == PRZYJECIE_END_SCINA ||
     this->mCurrent == PRZYJECIE_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_END_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_SKOK ||
     this->mCurrent == PRZYJECIE_END_SKOK ||
     this->mCurrent == PRZYJECIE_GORNE ||
     this->mCurrent == PRZYJECIE_END_GORNE ||
     this->mCurrent == PRZYJECIE_DOLNE ||
     this->mCurrent == PRZYJECIE_END_DOLNE ||
     this->mCurrent == PRZYJECIE_KOLANA ||
     this->mCurrent == PRZYJECIE_END_KOLANA ||
     this->mCurrent == PRZYJECIE_STOPA ||
     this->mCurrent == PRZYJECIE_END_STOPA ||
     this->mCurrent == PRZYJECIE_BLOK ||
     this->mCurrent == PRZYJECIE_END_BLOK) return;
  this->mProposedNext = st;
}

void State::SetEndTime(float tm)
 {

  if(this->mCurrent == PRZYJECIE_SCINA ||
     this->mCurrent == PRZYJECIE_END_SCINA ||
     this->mCurrent == PRZYJECIE_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_END_SCINA_LOW ||
     this->mCurrent == PRZYJECIE_SKOK ||
     this->mCurrent == PRZYJECIE_END_SKOK ||
     this->mCurrent == PRZYJECIE_GORNE ||
     this->mCurrent == PRZYJECIE_END_GORNE ||
     this->mCurrent == PRZYJECIE_DOLNE ||
     this->mCurrent == PRZYJECIE_END_DOLNE ||
     this->mCurrent == PRZYJECIE_KOLANA ||
     this->mCurrent == PRZYJECIE_END_KOLANA ||
     this->mCurrent == PRZYJECIE_STOPA ||
     this->mCurrent == PRZYJECIE_END_STOPA ||
     this->mCurrent == PRZYJECIE_BLOK ||
     this->mCurrent == PRZYJECIE_END_BLOK) return;

  // float duration = tm - mStartTime - 1e-5f;// zabezpieczenie przed tm == mEndTime
  // float dur = GetDuration();
   //mRepetitionCount  = (int)( duration / dur );
   
   //if(mRepetitionCount)
   //{
    // DIE(((mCurrent == STATE_IDLE) || (mCurrent == ZAGRYWKA_HINT) || (mCurrent ==  ZAGRYWKA_HINT_AIMING_SCINA) || (mCurrent ==  ZAGRYWKA_HINT_AIMING_LOP) || (mCurrent == PRZYJECIE_DOLNE_HINT) || (mCurrent == PRZYJECIE_GORNE_HINT)));
   //}

   if (mEndTime == mCurrentAnimEndTime)
   {
     mCurrentAnimEndTime = tm;
   }
   mEndTime=tm; 
   this->RecalcLastPosition();
   RecalcNextState();
 }

#ifdef DEBUG
char *DirStr[] =
{
  "ANGLE_0",
  "ANGLE_45",
  "ANGLE_90",
  "ANGLE_135",
  "ANGLE_180",
  "ANGLE_225",
  "ANGLE_270",
  "ANGLE_315",
  "ANGLE_FREE"
};

char *StateStrs[] = 
{
  "STATE_NONE",
  "STATE_IDLE",
  "STEP_LEFT", 
  "STEP_RIGHT", 
  "STEP_FORWARD", 
  "STEP_BACKWARD", 
  "STEP_LEFT_FORWARD", 
  "STEP_LEFT_BACKWARD", 
  "STEP_RIGHT_FORWARD", 
  "STEP_RIGHT_BACKWARD", 
  "TURN_LEFT_45",
  "TURN_LEFT_90",
  "TURN_LEFT_135",
  "TURN_LEFT_180",
  "TURN_RIGHT_45",
  "TURN_RIGHT_90",
  "TURN_RIGHT_135",
  "TURN_RIGHT_180",
  "RUN_NORMAL",
  "RUN_FAST",
  "STOP_FAST_TURN_180",
  "STOP_FAST",
  "ZAGRYWKA_HINT",
  "ZAGRYWKA_STEP_LEFT", 
  "ZAGRYWKA_STEP_RIGHT",
  "ZAGRYWKA_AIMING_LOP",
  "ZAGRYWKA_HINT_AIMING_LOP",
  "ZAGRYWKA_AIMING_SCINA",
  "ZAGRYWKA_HINT_AIMING_SCINA",
  "ZAGRYWKA_ACTION_LOP",
  "ZAGRYWKA_END_LOP",
  "ZAGRYWKA_ACTION_SCINA",
  "ZAGRYWKA_END_SCINA",
  "PRZYJECIE_SKOK",
  "PRZYJECIE_END_SKOK",
  "PRZYJECIE_GORNE",
  "PRZYJECIE_END_GORNE",
  "PRZYJECIE_DOLNE",
  "PRZYJECIE_END_DOLNE",
  "PRZYJECIE_KOLANA",
  "PRZYJECIE_END_KOLANA",
  "PRZYJECIE_SZCZUPAK_FORWARD",
  "PRZYJECIE_END_SZCZUPAK_FORWARD",
  "PRZYJECIE_BLOK",
  "PRZYJECIE_END_BLOK",
  "HOP_FORWARD",
  "HOP_FORWARD_LEFT_45",
  "HOP_FORWARD_RIGHT_45",
  "LAST_STATE"
};

const char *State::GetStateStr(char *buffer, int size)
{
  my_snprintf(buffer,size,"Pos :  ( %f, %f, %f )\nCurrent State: %s\nnext state: %s\nDir: %s\n", this->LastPosition.x, this->LastPosition.y, this->LastPosition.z, StrCurrentState, StateStrs[mProposedNext],DirStr[this->mdir]);
  return buffer;
}

int State::GetEndPoints(CVector3 *point)
{
  *point = StartPosition;
  
  if (mNext)
  {
    point++;
    return mNext->GetEndPoints(point) + 1;
  }
  else
  {
    GetPositionByTime(point+1,mEndTime);
    return 2;
  }
}

void State::DumpInfo()
{
  CVector3 last;
  GetPositionByTime(&last, mEndTime);
  LogMessage("[%s]:Direction %s, StartPoint : {%f, %f, %f} EndPoint : {%f, %f, %f}\n",StrCurrentState,DirStr[this->mdir], StartPosition.x,StartPosition.y,StartPosition.z, last.x, last.y, last.z);
  if (mNext)
    mNext->DumpInfo();
}

#endif


void State::SnipStatesToThis()
{
  if (mPrev == NULL) return;
  State *ToDel = this->GetFirst();
  this->mPrev->mNext = NULL;
  delete ToDel;
  this->mPrev = NULL;
}

bool State::IsStateIdle(States st)
{
  switch(st)
  {
    case STATE_IDLE:
    case ZAGRYWKA_HINT:
    case ZAGRYWKA_HINT_AIMING_LOP:
    case ZAGRYWKA_HINT_AIMING_SCINA:
    case PRZYJECIE_BLOK_HINT:
    case PRZYJECIE_DOLNE_HINT:
    case PRZYJECIE_GORNE_HINT:
    case SIT_IDLE:
      return true;
    default:
      return false;
  }
}

/*
State * State::Clone()
{
  char *pNew = StateManager::Instance()->GetState(this->mCurrent, NULL, this->player);
  return (State *)memcpy(pNew, this, Mission Imposible);
}
*/


State *State::GetFirst()
{
  State *temp = this;
  while (temp->mPrev)
    temp = temp->mPrev;
  return temp;
}
E:\Project\Kopia (5) VBEngine\Ai\State.h
#ifndef _STATE_H
#define _STATE_H

/*
class       : State
description : Podstawowa klasa zarzadzajaca Stanami zawodnikow w grze

methods     : konstruktor(State *) - prywatny konstruktor tylko do doczepiania nastepnych stanow
                                     do listy
              konstruktor          - domyslny konstruktor dla pierwszego utworzenia obiektu
			        Rollback             - przewiniecie listy stanow do czasu wczesniejszego niz podany
			        Update               - wirtualna funkcja zawierajaca maszyne stanow zwraca stan aktualny
			                               albo nastêpny w kolejnosci
*/ 


struct Frame;
class CPlayer;
class Animation;


struct MorphState
{
  Frame *first;
  Frame *second;
  float alpha;
};

class State
{
protected: 
  State *mNext, *mPrev;
  float mOffsetScale,mTimeScale;
  float mStartTime, mEndTime;
  float mCurrentAnimStartTime, mCurrentAnimEndTime;
  int mRepetitionCount;
  unsigned int mRepetitionAnim;

  HAnimation mCurrentAnim;
  CPlayer *player;
  CVector3 StartPosition;
  States mCurrent;
  States mProposedNext;
   
  State(State *prev, CPlayer *playerPtr);
  Direction mdir;
  float mFreeAngle;

  // koncowy dir, np. dla StateTurnRight45 itp. mdir == 45 tylko pod koniec state'a
  Direction mEndDir;
  CVector3 LastPosition;

  Frame *GetFollowingFrameByTime(float time) {return AnimationManager::Instance()->GetFollowingFrameByTime(this->mCurrentAnim, time);}
  Frame *GetFrameByTime(float time) {return AnimationManager::Instance()->GetFrameByTime(this->mCurrentAnim, time);}
public:
  
  void RecalcLastPosition() { this->GetPositionByTime(&LastPosition, mEndTime); }

  CVector3 *OffsetRotateByDir(CVector3 *dst, CVector3 *src, Direction dir , float angle = 0.0f );
  CVector3 *OffsetRotate(CVector3 *in, CVector3 *out)
  {
    return this->OffsetRotateByDir(out, in, this->mdir, this->mFreeAngle);
  }
  
  CVector3 *GetLastPosition(void) {return &this->LastPosition;};
  
  
#ifdef DEBUG
  const char *StrCurrentState;
  const char *GetStateStr(char *buffer, int size);
#endif

  ~State(void);
 // State *Rollback(float czas);

  virtual void UpdateControls(unsigned int Key);
  virtual State *Update();
  
  void RecalcNextState();

  State * GetStateByTime(float time, bool *isPrev = NULL);
  State * GetLast(void);

 State * GetFirst();
  State * GetNext(bool alloc);
  State * GetPrev(void) {return this->mPrev;}
  bool CheckFrontiers(enum TurnAngle *turn);
  bool CheckFrontiers(enum Direction dir, float angle = 0.0f );
  CVector3 *GetStartPosition(void) {return &this->StartPosition;};
  float GetCurrentPosition(CVector3 *pos);
  float GetPositionByTime(CVector3 *pos,float time);
  
  Direction KeyToDir(unsigned int key);
  void SetNextState(State *newState);

  States GetRotationStateFromDir(Direction Dir);
  enum TurnAngle GetTurnAngleFromState(States Rot);
  enum TurnAngle GetTurnAngleFromDirs(Direction Dir, Direction Current);
  States GetCurrent(void) {return this->mCurrent;};

  void TurnDirByAngle(TurnAngle angle);
  Direction TurnAnyDirByAngle(TurnAngle angle, Direction inDir, float* freeAngle );
  float TurnFreeAngeByTurnAngle(TurnAngle angle);
  Direction InverseTurnByAngle(Direction dir,TurnAngle angle);
  
  //void SetStartPosition(CVector3 *v) {StartPosition = *v;}
  
  void SetProposedNext(States st);
  States GetProposedNext(void) { return this->mProposedNext;}
  void SetStartTime(float tm) { mStartTime=tm; }
  float GetStartTime(void) { return mStartTime; }
  float GetEndTime(void) { return mEndTime; }
  void SetEndTime(float tm);
  float GetAnimStartTime(void) { return this->mCurrentAnimStartTime; }
  float GetAnimEndTime(void) { return this->mCurrentAnimEndTime; }

  int GetRepetitionCount() { return this->mRepetitionCount; }

  Direction GetDir(void) { return this->mdir;}
  Direction GetEndDir(void) { return this->mEndDir;}
  void SetEndDir(Direction dir) {this->mEndDir = dir;}
  void SetDir(Direction dir) {this->mdir = dir;}
  
  void SetTimeScale(float time_scale);
  void SetOffsetScale(float offset_scale) {mOffsetScale = offset_scale;}
  float GetOffsetScale() { return mOffsetScale;}
  void SetFreeAngle(float angle, bool setEndDir);

  //CVector3 GetBallOffset() {return mAnimation->GetBallOffset() * mOffsetScale;}
  //float GetDuration() {return mAnimation->GetDuration()*mTimeScale;}
  //Animation *GetAnimation(void) { return mAnimation; }
  
  CVector3 GetBallOffset() {return AnimationManager::Instance()->GetBallOffset(this->mCurrentAnim) * mOffsetScale;}
  CVector3 GetOffset() {return *(AnimationManager::Instance()->GetOffset(this->mCurrentAnim)) * mOffsetScale;}
  float GetDuration() {return AnimationManager::Instance()->GetDuration(this->mCurrentAnim) * mTimeScale;}
  float GetHitDuration() {return AnimationManager::Instance()->GetHitDuration(this->mCurrentAnim) * mTimeScale;}
  Animation *GetAnimation(void) { return AnimationManager::Instance()->GetAnimation(this->mCurrentAnim); }
  void GetMorphState(MorphState *morph_state);
  Frame *GetNextFrame();
  Frame *GetFirstFrame() {return AnimationManager::Instance()->GetFirstFrame(this->mCurrentAnim);}


#ifdef DEBUG
  int GetEndPoints(CVector3 *point);
  void DumpInfo();
#endif

  void SnipStatesToThis();
  float GetRotationAngle(float anim_step);
  bool IsStateIdle(States st);
  bool IsCurrentIdle(void) {return IsStateIdle(this->mCurrent);};
  //State *Clone();

};

#endif
E:\Project\Kopia (5) VBEngine\Ai\StateManager.cpp
#include "..\config.h"

#include <assert.h>

#include "..\utility\misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"
#include "..\utility\ctime.h"
#include "..\utility\Tools.h"


#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"


#include "..\graphics\meshmanager.h"

#include "..\graphics\animation.h"
#include "..\graphics\animationmanager.h"

#include "..\graphics\SceneObject.h"


#include "States\States.h"
#include "..\Core\zawodnik.h"

#include "State.h"
#include "StateManager.h"

const char *StateManager::GetStateDatFile(States RequestedState)
{
  switch(RequestedState)
  {
    case  TURN_LEFT_45          : return "turn_left_45_";
    case  TURN_LEFT_90          : return "turn_left_90_";
    case  TURN_LEFT_135         : return "turn_left_135_";
    case  TURN_LEFT_180         : return "turn_left_180_";
    case  TURN_RIGHT_45         : return "turn_right_45_";
    case  TURN_RIGHT_90         : return "turn_right_90_";
    case  TURN_RIGHT_135        : return "turn_right_135_";
    case  TURN_RIGHT_180        : return "turn_right_180_";
    case  RUN_FAST              : return "run_fast_";
    case  STOP_FAST_TURN_180    : return "stop_fast_turn_";
    case  STOP_FAST             : return "stop_fast_";
    case  STATE_IDLE            : return "hint_prepare_";
    case  ZAGRYWKA_HINT         : return "hint_zagrywka_";
    case  ZAGRYWKA_STEP_LEFT    : return "step_left_zagrywka_";
    case  ZAGRYWKA_STEP_RIGHT   : return "step_right_zagrywka_";
    case  ZAGRYWKA_AIMING_LOP   : return "aiming_lop_zagrywka_";
    case  ZAGRYWKA_AIMING_SCINA : return "aiming_scina_zagrywka_";
    case  HOP_FORWARD           : return "hop_forward_small_";
    case  HOP_FORWARD_LEFT_45   : return "hop_forward_left_smal_";
    case  HOP_FORWARD_RIGHT_45  : return "hop_forward_right_smal_";
  #ifdef USE_HOPS
    //case  HOP_BACKWARD           : return "hop_backward_small_";
    case  HOP_BACKWARD_LEFT_45  : return "hop_backward_left_smal_";
    case  HOP_BACKWARD_RIGHT_45 : return "hop_backward_right_smal_";
  #endif
    case  PRZYJECIE_GORNE_HINT       : return "hint_przyjecie_gorne_";
    case  PRZYJECIE_DOLNE_HINT       : return "hint_przyjecie_dolne_";
    case  PRZYJECIE_SKOK        : return "przyjecie_skok_";
    case  PRZYJECIE_GORNE       : return "przyjecie_gorne_";
    case  PRZYJECIE_DOLNE       : return "przyjecie_dolne_";
    case  PRZYJECIE_KOLANA      : return "przyjecie_kolana_";
    case  PRZYJECIE_SCINA       : return "scina_";
    case PRZYJECIE_STOPA        : return "przyjecie_stopa_";
    case PRZYJECIE_SCINA_LOW    : return "scina_miejsce_";
    case PRZYJECIE_END_SCINA_LOW : return "end_scina_miejsce_";
    case PRZYJECIE_END_SCINA    : return "scina_end_";
    case PRZYJECIE_END_SKOK     : return "przyjecie_skok_end_";
    case PRZYJECIE_END_GORNE    : return "przyjecie_gorne_end_";
    case PRZYJECIE_END_DOLNE    : return "przyjecie_dolne_end_";
    case PRZYJECIE_END_KOLANA   : return "przyjecie_kolana_end_";
    case PRZYJECIE_END_STOPA    : return "przyjecie_stopa_end_";
    case PRZYJECIE_SZCZUPAK_FORWARD     : //tmpState =  new CStatePrzyjencieSkok   (prev,player);  break;
    case PRZYJECIE_END_SZCZUPAK_FORWARD : //tmpState =  new CStatePrzyjencieSkok   (prev,player);  break;
    case PRZYJECIE_BLOK                 : return "block_";
    case PRZYJECIE_END_BLOK             : return "block_end_";
              //case  PRZYJECIE_SZCZUPAK_FORWARD,                                                   
      //case  PRZYJECIE_BLOK,                                                               
    case ZAGRYWKA_ACTION_LOP    : return "lop_zagrywka_";
    case ZAGRYWKA_END_LOP       : return "end_lop_zagrywka_";
    case ZAGRYWKA_ACTION_SCINA  : return "scina_zagrywka_";
    case ZAGRYWKA_END_SCINA     : return "end_scina_zagrywka_";
    case ZAGRYWKA_HINT_AIMING_LOP  : return "hint_aiming_lop_zagrywka_";
    case ZAGRYWKA_HINT_AIMING_SCINA : return "hint_aiming_scina_zagrywka_";
    case PRZYJECIE_BLOK_HINT     : return "hint_przyjecie_gorne_";
    case PRZYJECIE_BLOK_STEP_RIGHT : return "step_right_block_";
    case PRZYJECIE_BLOK_STEP_LEFT  : return "step_left_block_";
    case SIT_DOWN                  : return "hint_sitdown_";
    case SIT_IDLE                  : return "hint_sit_";
    case STAND_UP                  : return "hint_standup_";
    case STATE_SZCZUPAK            : return "szczupak_";
    default                 : DIE(!"UnknownStateRequested!"); break;
  }

  return NULL;
}

State *StateManager::GetState(States RequestedState,State *prev,CPlayer *player, 
                              bool checkForStaticCollision/* = true*/)
{
  State *tmpState;

  switch(RequestedState)
  {
  case  TURN_LEFT_45          : tmpState = new CStateTurnLeft45       (prev,player);  break;
  case  TURN_LEFT_90          : tmpState = new CStateTurnLeft90       (prev,player);  break;
  case  TURN_LEFT_135         : tmpState = new CStateTurnLeft135      (prev,player);  break;
  case  TURN_LEFT_180         : tmpState = new CStateTurnLeft180      (prev,player);  break;
  case  TURN_RIGHT_45         : tmpState = new CStateTurnRight45      (prev,player);  break;
  case  TURN_RIGHT_90         : tmpState = new CStateTurnRight90      (prev,player);  break;
  case  TURN_RIGHT_135        : tmpState = new CStateTurnRight135     (prev,player);  break;
  case  TURN_RIGHT_180        : tmpState = new CStateTurnRight180     (prev,player);  break;  
  case  RUN_FAST              : tmpState =  new StateRunForward        (prev,player); break;
  case  STOP_FAST_TURN_180    : tmpState =  new StateStopRunTurn180    (prev,player); break;
  case  STOP_FAST             : tmpState =  new StateStopRun           (prev,player); break;
  case  STATE_IDLE            : tmpState =  new StateIdle              (prev,player); break;
  case  ZAGRYWKA_HINT         : tmpState =  new CStateZagrywkaIdle     (prev,player); break;
  case  ZAGRYWKA_STEP_LEFT    : tmpState =  new StateZagrywkaStepLeft  (prev,player); break;
  case  ZAGRYWKA_STEP_RIGHT   : tmpState =  new StateZagrywkaStepRight (prev,player); break;
  case  ZAGRYWKA_AIMING_LOP   : tmpState =  new StateLopStart          (prev,player); break;
  case  ZAGRYWKA_AIMING_SCINA : tmpState =  new StateScinaStart        (prev,player);  break;
  case  HOP_FORWARD           : tmpState =  new CStateHopForward       (prev,player);  break;
  case  HOP_FORWARD_LEFT_45   : tmpState =  new CStateHopForwardLeft45 (prev,player);  break;
  case  HOP_FORWARD_RIGHT_45  : tmpState =  new CStateHopForwardRight45 (prev,player); break;
#ifdef USE_HOPS
   case  HOP_BACKWARD_LEFT_45  : tmpState =  new CStateHopBackwardLeft45 (prev,player); break;
   case  HOP_BACKWARD_RIGHT_45 : tmpState =  new CStateHopBackwardRight45 (prev,player);break;
#endif
  case  PRZYJECIE_GORNE_HINT  : tmpState =  new CStateHintPrzyjencieGorne  (prev,player);  break;
  case  PRZYJECIE_DOLNE_HINT  : tmpState =  new CStateHintPrzyjencieDolne  (prev,player); break;
  case  PRZYJECIE_SKOK        : tmpState =  new CStatePrzyjencieSkok   (prev,player);  break;
  case  PRZYJECIE_GORNE       : tmpState =  new CStatePrzyjencieGorne  (prev,player);  break;
  case  PRZYJECIE_DOLNE       : tmpState =  new CStatePrzyjencieDolne  (prev,player); break;
  case  PRZYJECIE_KOLANA      : tmpState =  new CStatePrzyjencieKolana (prev,player); break;
  case  PRZYJECIE_SCINA       : tmpState =  new CStatePrzyjencieScina  (prev,player); break;
  case PRZYJECIE_SCINA_LOW    : tmpState =  new CStatePrzyjencieScinaLow  (prev,player); break;
  case PRZYJECIE_END_SCINA_LOW : tmpState =  new CStatePzyjencieScinaLowEnd   (prev,player);  break;
            //case  PRZYJECIE_SZCZUPAK_FORWARD,                                                   
     //case  PRZYJECIE_BLOK,                                                               
  case ZAGRYWKA_ACTION_LOP    : tmpState =  new StateLop(prev,player);  break;
  case ZAGRYWKA_END_LOP       : tmpState =  new StateLopFinish   (prev,player);  break;
  case ZAGRYWKA_ACTION_SCINA  : tmpState =  new StateScina   (prev,player);  break;
  case ZAGRYWKA_END_SCINA     : tmpState =  new StateScinaFinish   (prev,player);  break;
  case PRZYJECIE_END_SCINA    : tmpState =  new CStatePzyjencieScinaEnd   (prev,player);  break;
  case PRZYJECIE_END_SKOK     : tmpState =  new CStatePrzyjencieSkokEnd   (prev,player);  break;
  case PRZYJECIE_END_GORNE    : tmpState =  new CStatePrzyjencieGorneEnd   (prev,player);  break;
  case PRZYJECIE_END_DOLNE    : tmpState =  new CStatePrzyjencieDolneEnd   (prev,player);  break;
  case PRZYJECIE_END_KOLANA   : tmpState =  new CStatePrzyjencieKolanaEnd  (prev,player);  break;
  case PRZYJECIE_STOPA        : tmpState =  new CStatePrzyjencieStopa      (prev,player);  break;
  case PRZYJECIE_END_STOPA    : tmpState =  new CStatePrzyjencieStopaEnd   (prev,player);  break;
  case PRZYJECIE_SZCZUPAK_FORWARD     : //tmpState =  new CStatePrzyjencieSkok   (prev,player);  break;
  case PRZYJECIE_END_SZCZUPAK_FORWARD : //tmpState =  new CStatePrzyjencieSkok   (prev,player);  break;
  case PRZYJECIE_BLOK                 : tmpState =  new CStateBlok   (prev,player);  break;
  case PRZYJECIE_END_BLOK             : tmpState =  new CStateBlokEnd   (prev,player);  break;
  case ZAGRYWKA_HINT_AIMING_LOP  : tmpState = new StateLopAiming (prev,player);  break;
  case ZAGRYWKA_HINT_AIMING_SCINA : tmpState = new StateScinaAiming(prev,player);  break;
  case PRZYJECIE_BLOK_HINT        : tmpState = new CStateHintBlock(prev,player);break;
  case PRZYJECIE_BLOK_STEP_LEFT   : tmpState =  new StateBlockStepLeft  (prev,player); break;
  case PRZYJECIE_BLOK_STEP_RIGHT  : tmpState =  new StateBlockStepRight  (prev,player); break;
  case SIT_IDLE   : tmpState =  new StateSit  (prev,player); break;
  case SIT_DOWN   : tmpState =  new StateSitDown  (prev,player); break;
  case STAND_UP   : tmpState =  new StateStandUp  (prev,player); break;
  case STATE_SZCZUPAK : tmpState = new StateSzczupak(prev,player);break;
  default                 :DIE(!"UnknownStateRequested!"); tmpState =  new StateIdle(prev,player); break;                    
  }                   
                                                                                       
  tmpState->RecalcLastPosition();
  return tmpState;
}
E:\Project\Kopia (5) VBEngine\Ai\StateManager.h
#ifndef _STATEMANAGER_H
#define _STATEMANAGER_H

/*
class       :
description :

methods     :

*/




class StateManager :public Singleton<StateManager>
{


public:
   State *GetState(States RequestedState,State *prev,CPlayer *player, bool checkForStaticCollision = true);
   const char *GetStateDatFile(States RequestedState);

};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlock.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\Team.h"

CStateBlok::CStateBlok(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{    
  mCurrent = PRZYJECIE_BLOK;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();

#ifdef DEBUG
  StrCurrentState = "StateBlok";
  LogError("Team %d : Player : %d : Twoze stan Blok",playerPtr->GetTeam()->GetTeamNumber(), playerPtr->GetPosOnField());
#endif

  

  //mNext = new CStateBlokEnd(this,player);

  mProposedNext = PRZYJECIE_END_BLOK;
  StartPosition.z = 0.0f;
  
}
 
void CStateBlok::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *CStateBlok::Update()
{
  this->player->SetOdbijam(true);
  if (NOW > mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlock.h
#ifndef _STATEBLOK_H
#define _STATEBLOK_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateBlok :public State
{
public:
  CStateBlok(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\Team.h"

CStateBlokEnd::CStateBlokEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{  
  mCurrent = PRZYJECIE_END_BLOK;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);  
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "StateBlokEnd";
  LogError("Team %d : Player : %d : Twoze stan EndBlok", playerPtr->GetTeam()->GetTeamNumber(), playerPtr->GetPosOnField());
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStateBlokEnd::UpdateControls(unsigned int Key)
{
   return;
}

State *CStateBlokEnd::Update()
{
  float curenttime = NOW;
  if (curenttime >= mEndTime || curenttime >= mCurrentAnimEndTime) 
  {
    /* hack */
    mEndTime = mCurrentAnimEndTime;

    this->player->SetOdbijam(false);
    this->player->ClearBlocking();
    this->player->SetPosOnField(this->player->GetRealPosition(this->player->GetPosOnField()));
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockEnd.h
#ifndef _STATEBLOKEND_H
#define _STATEBLOKEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateBlokEnd :public State
{
public:
  CStateBlokEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockStepLeft.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateBlockStepLeft::StateBlockStepLeft(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = PRZYJECIE_BLOK_STEP_LEFT;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateBlockStepLeft";
#endif
  mProposedNext = PRZYJECIE_BLOK_HINT;
}
 
void StateBlockStepLeft::UpdateControls(unsigned int Key)
{
  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockStepLeft.h
#ifndef _STATEBLOCKSTEPLEFT_H
#define _STATEBLOCKSTEPLEFT_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateBlockStepLeft :public State
{
public:
  StateBlockStepLeft(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockStepRight.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateBlockStepRight::StateBlockStepRight(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = PRZYJECIE_BLOK_STEP_RIGHT;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateBlockStepRight";
#endif
  mProposedNext = PRZYJECIE_BLOK_HINT;
  
}
 
void StateBlockStepRight::UpdateControls(unsigned int Key)
{
 return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateBlockStepRight.h
#ifndef _STATEBLOCKSTEPRIGHT_H
#define _STATEBLOCKSTEPRIGHT_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateBlockStepRight :public State
{
public:
  StateBlockStepRight(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintBlock.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateHintBlock::CStateHintBlock(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = PRZYJECIE_BLOK_HINT;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;

#ifdef DEBUG  
  StrCurrentState = "StateHintBlock";
#endif

  StartPosition.z = 0.0f;
}

 
State *CStateHintBlock::Update()
{
  float CurrentTime = NOW;

  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE)) 
    {
      mRepetitionCount++;
      
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mEndTime == mCurrentAnimEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext = GetNext(true);
      return mNext->Update();
    }
  }
  return this;
}

void CStateHintBlock::UpdateControls(unsigned int Key)
{
  if (CheckFlag(Key, VBK_LEFT))
  {
    mProposedNext = PRZYJECIE_BLOK_STEP_LEFT;
    mEndTime = NOW;
  }
  else
  {
    if (CheckFlag(Key, VBK_RIGHT))
    {
      mProposedNext = PRZYJECIE_BLOK_STEP_RIGHT;
      mEndTime = NOW;
    }
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintBlock.h
#ifndef _STATEHINTBLOCK_H
#define _STATEHINTBLOCK_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHintBlock :public State
{
public:
  CStateHintBlock(State *prev, CPlayer *playerPtr);
  State *Update();
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintPrzyjencieDolne.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateHintPrzyjencieDolne::CStateHintPrzyjencieDolne(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = PRZYJECIE_DOLNE_HINT;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
  

#ifdef DEBUG  
  StrCurrentState = "StateHintPrzyjencieDolne";
#endif

  StartPosition.z = 0.0f;
  
}


State *CStateHintPrzyjencieDolne::Update()
{
  float CurrentTime = NOW;
  
  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == PRZYJECIE_DOLNE_HINT)) 
    {
      mRepetitionCount++;
#ifdef DEBUG
      if (mRepetitionCount>1) 
        LogError("repetition count more than 1 (%d)", mRepetitionCount);
#endif            
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mEndTime == mCurrentAnimEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext = GetNext(true);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintPrzyjencieDolne.h
#ifndef _STATEHINTPRZYJENCIEDOLNE_H
#define _STATEHINTPRZYJENCIEDOLNE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHintPrzyjencieDolne :public State
{
public:
  CStateHintPrzyjencieDolne(State *prev, CPlayer *playerPtr);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintPrzyjencieGorne.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateHintPrzyjencieGorne::CStateHintPrzyjencieGorne(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = PRZYJECIE_GORNE_HINT;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);  
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;

  assert( mCurrentAnimEndTime != mStartTime);

#ifdef DEBUG  
  StrCurrentState = "StateHintPrzyjencieGorne";
#endif

  StartPosition.z = 0.0f;
  
}

 
State *CStateHintPrzyjencieGorne::Update()
{
  float CurrentTime = NOW;
  
  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == PRZYJECIE_GORNE_HINT )) 
    {
      mRepetitionCount++;
#ifdef DEBUG
      if (mRepetitionCount>1) LogError("repetition count more than 1");
#endif      
      this->mCurrentAnimStartTime = this->mCurrentAnimEndTime;
      
      if(mEndTime == mCurrentAnimEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext = GetNext(true);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHintPrzyjencieGorne.h
#ifndef _STATEHINTPRZYJENCIEGORNE_H
#define _STATEHINTPRZYJENCIEGORNE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHintPrzyjencieGorne :public State
{
public:
  CStateHintPrzyjencieGorne(State *prev, CPlayer *playerPtr);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopBackwardLeft45.cpp
#include "..\..\config.h"

#include <assert.h>

#define USE_HOPS

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateHopBackwardLeft45::CStateHopBackwardLeft45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  
  mCurrent = HOP_BACKWARD_LEFT_45;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateHopBackwardLeft45";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStateHopBackwardLeft45::UpdateControls(unsigned int Key)
{

  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopBackwardLeft45.h
#ifndef _STATEHOPBACKWARDLEFT45_H
#define _STATEHOPBACKWARDLEFT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHopBackwardLeft45 :public State
{
public:
  CStateHopBackwardLeft45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopBackwardRight45.cpp
#include "..\..\config.h"

#include <assert.h>

#define USE_HOPS

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateHopBackwardRight45::CStateHopBackwardRight45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = HOP_BACKWARD_RIGHT_45;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);  
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateHopBackwardRight45";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStateHopBackwardRight45::UpdateControls(unsigned int Key)

{
  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopBackwardRight45.h
#ifndef _CSTATEHOPBACKWARDRIGHT45_H
#define _CSTATEHOPBACKWARDRIGHT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHopBackwardRight45 :public State
{
public:
  CStateHopBackwardRight45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForward.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateHopForward::CStateHopForward(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = HOP_FORWARD;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();

#ifdef DEBUG
  StrCurrentState = "StateHopForward";
#endif

  mProposedNext = STATE_IDLE;
  

}
 
void CStateHopForward::UpdateControls(unsigned int Key)
{
  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForward.h
#ifndef _STATEHOPFORWARD_H
#define _STATEHOPFORWARD_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHopForward :public State
{
public:
  CStateHopForward(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForwardLeft45.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateHopForwardLeft45::CStateHopForwardLeft45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = HOP_FORWARD_LEFT_45;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateHopForwardLeft45";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStateHopForwardLeft45::UpdateControls(unsigned int Key)
{
  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForwardLeft45.h
#ifndef _STATEHOPFORWARDLEFT45_H
#define _STATEHOPFORWARDLEFT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHopForwardLeft45 :public State
{
public:
  CStateHopForwardLeft45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForwardRight45.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateHopForwardRight45::CStateHopForwardRight45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = HOP_FORWARD_RIGHT_45;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateHopForwardRight45";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStateHopForwardRight45::UpdateControls(unsigned int Key)
{
  return;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateHopForwardRight45.h
#ifndef _CSTATEHOPFORWARDRIGHT45_H
#define _CSTATEHOPFORWARDRIGHT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateHopForwardRight45 :public State
{
public:
  CStateHopForwardRight45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateIdle.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\meshmanager.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\Team.h"

StateIdle::StateIdle(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = STATE_IDLE;

  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;

  this->mRepetitionAnim = myrand(MAX_IDLE_ANIMATIONS - 1);

  

#ifdef DEBUG  
  StrCurrentState = "StateIdle";  
#endif

  StartPosition.z = 0.0f;
  this->turn = NO_TURN;
}
 
void StateIdle::UpdateControls(unsigned int Key)
{
   if((Key & VBK_HINT) == VBK_HINT)
   {
    if (mNext && mNext->GetCurrent() != STATE_IDLE)
    {
      delete mNext;
      mNext = NULL;
    }
    mProposedNext = STATE_NONE;
    return;
  }

  if (mNext) return;

  Direction dir = KeyToDir(Key);
  turn = this->GetTurnAngleFromDirs(dir, this->mdir);
  
  if (CheckFrontiers(&turn))
  {
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
 
State *StateIdle::Update()
{
  float CurrentTime = NOW;

  if(this->player->GetPosOnField() > POS_5 && this->player->GetPosOnField() < POS_ZAGRYWKA && (FABS(this->StartPosition.x) > 7.5 ))
  {
    Direction targetDir = this->player->GetTeam()->GetSubDirection();
    if (targetDir != this->mdir)
    {
      this->mProposedNext = this->GetRotationStateFromDir(targetDir);
      this->mEndTime = CurrentTime;
    } else
    {
      mProposedNext = SIT_DOWN;
      this->mEndTime = CurrentTime;
    }
  }
  else
  if (this->mdir != ANGLE_0 && (mProposedNext == STATE_NONE || mProposedNext == STATE_IDLE ) && !mNext)
  {
    mEndTime = CurrentTime;
    mCurrentAnimEndTime = mEndTime;
    mProposedNext = this->GetRotationStateFromDir(ANGLE_0);
  }

  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == STATE_IDLE )) 
    {
      mRepetitionCount++;

      this->mCurrentAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
      
      this->mRepetitionAnim = myrand(MAX_IDLE_ANIMATIONS - 1);
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mEndTime == mCurrentAnimEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
/*
      if {mCurrent != this->mProposedNext)
      {
        CVector3 out, addpos = this->player->GetOffset(this->mProposedNext);
        int trgDir = (int)this->mdir;
        if(turn != NO_TURN)
        {
          trgDir += (int)turn;
          if (trgDir <0)
          {
            trgDir +=8;
          }
          if (trgDir >7)
          {
            trgDir -=8;
          }
        }
        this->OffsetRotateByDir(&out, &addpos, (Direction)trgDir);
      }
  */
      mNext = GetNext(true);
      mNext->TurnDirByAngle(turn);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateIdle.h
#ifndef _STATEIDLE_H
#define _STATEIDLE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateIdle :public State
{
  enum TurnAngle turn;
public:
  StateIdle(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateLop.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"
#include "..\..\Core\SetupManager.h"

StateLop::StateLop(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_ACTION_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateLop";
#endif
  if ( mPrev )
  {
    alfa = ((StateLopAiming*)mPrev)->alfa;
    gamma = ((StateLopAiming*)mPrev)->gamma;
    velocity = ((StateLopAiming*)mPrev)->velocity;
    mNext = new StateLopFinish(this,player);
  }
  
  
}
 
void StateLop::UpdateControls(unsigned int Key)
{
  return;
}

State *StateLop::Update()
{
  float CurrentTime = CTime::Instance()->GetTime();
  if (CurrentTime > mEndTime) 
  {  
     Event *qEvent = new Event();
     qEvent->mMask   = ET_BALL;
     qEvent->mID     = BE_SERVING;
     qEvent->mID2    = 0;
     qEvent->mTime   = this->mStartTime + this->GetHitDuration();
     qEvent->mUrgent = true;
     BallServeStruct* bss = new BallServeStruct(); //(BallServeStruct *) qEvent->mData;
     bss->Alfa       = ((StateLopAiming*)(mPrev))->alfa;
     bss->Gamma      = player->GetTeam()->AngleTeamToWorld(((StateLopAiming*)(mPrev))->gamma);
     bss->Velocity   = ((StateLopAiming*)(mPrev))->velocity;

     CVector3 servePoint =  GetBallOffset();
     this->OffsetRotate(&servePoint, &bss->ServePoint);

     bss->TeamNum = this->player->GetTeam()->GetTeamNumber();

     bss->ServePoint += StartPosition;
     player->GetTeam()->TeamToWorld(&bss->ServePoint);

     servePoint.Set(&bss->ServePoint);

     qEvent->mData = (void *)bss;
     
     player->ClearUserMask();

     EventManager::Instance()->PostEvent(qEvent);
     qEvent->Release();
     
     mNext->SetFreeAngle(((StateLopAiming*)(mPrev))->gamma, false);

     if (SetupManager::Instance()->GetSound()->ball)
     {
      qEvent = new Event();
      CVector3 *pos = new CVector3();
      pos->Set(&servePoint);
      qEvent->mData = (void *)pos;
      qEvent->mMask = ET_AUDIO;
      qEvent->mID2 = 0;
      qEvent->mID   = WAV_3;
      qEvent->mTime = this->mStartTime + this->GetHitDuration();
      qEvent->mUrgent = false;
      EventManager::Instance()->PostEvent(qEvent);
      qEvent->Release();
     }

     return mNext->Update();
  }
  return this;
}


CVector3 StateLop::GetOffset()
{
  return GetBallOffset();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateLop.h
#ifndef _STATELOP_H
#define _STATELOP_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateLop :public State
{
  
public:
  float alfa,gamma,velocity;
  StateLop(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  CVector3 GetOffset();
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopAiming.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\meshmanager.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"
#include "..\..\graphics\GUI.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateLopAiming::StateLopAiming(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{  
  IsAi = false;
  mCurrent = ZAGRYWKA_HINT_AIMING_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "StateLopAiming";
#endif
  gamma = 0.0f;
  alfa = CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA;
  velocity = CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY;
  
}
 

StateLopAiming::StateLopAiming(State *prev, CPlayer *playerPtr, CVector3 *target) :State(prev, playerPtr)
{
  IsAi = true;
  mCurrent = ZAGRYWKA_HINT_AIMING_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "StateLopAiming";
#endif
    
  CVector3 delta = *target - StartPosition;
  float R2 = sqrtf(delta.x * delta.x + delta.y * delta.y);
  
  CVector3 finalPos;// = mAnimation->GetBallOffset()+ StartPosition;
  
  {
    StateLop *temp = new StateLop(this,playerPtr);
    finalPos = temp->GetOffset(); 
    this->SetNextState(NULL);
  }
  float c =  delta.y/R2;
  float s =  delta.x/R2;
  float x = (finalPos.x * c - finalPos.y *s);
  float y = (finalPos.x * s + finalPos.y *c);
  finalPos.x = x;
  finalPos.y = y;
  finalPos += StartPosition;      
  delta = *target - finalPos;
  
  float minPredkoscDlaAlfaMaxSq = 1e10;
  float R = sqrtf(delta.x * delta.x + delta.y * delta.y);
  float alpha;
  while (minPredkoscDlaAlfaMaxSq >  CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY 
                                    * CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY)
  {
    alpha = GaussRand(CBall::Instance()->ZAGRYWKA_GAUSS_LOP_ALPHA, 0.2f, CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA,
         CBall::Instance()->ZAGRYWKA_LOP_MAX_ALPHA);
    float tg = tanf(alpha);
    float cosSq = cosf(alpha);
    cosSq *= cosSq;
    minPredkoscDlaAlfaMaxSq =(CBall::Instance()->GRAVITY/2) * R *  R/((FABS(delta.z) + R*tg)*cosSq);
  }
  float speed = sqrtf(minPredkoscDlaAlfaMaxSq);
  

  mVelocityTime = (speed - CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY) /
                             CBall::Instance()->ZAGRYWKA_LOP_V_INCREASE_PER_SEC;
  
 
  mVelocityTime += mStartTime;
  float tGamma =  -asinf(delta.x/R);

  mAlphaTime = (alpha - CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA)/
              CBall::Instance()->ZAGRYWKA_LOP_DELTA_ALPHA + mStartTime;
  if (mAlphaTime > mVelocityTime)
  {
    mAlphaTime = mVelocityTime;
    mDeltaAlpha = (alpha - CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA) / (mVelocityTime - mStartTime);
  }
  else
  {
    mDeltaAlpha = CBall::Instance()->ZAGRYWKA_LOP_DELTA_ALPHA;
  }
  mGammaTime = FABS(tGamma)/ CBall::Instance()->ZAGRYWKA_LOP_DELTA_GAMMA + mStartTime;
  if (mGammaTime > mVelocityTime)
  {
    mGammaTime = mVelocityTime;
    mDeltaGamma = tGamma / (mVelocityTime - mStartTime);
  }
  else
  {
    mDeltaGamma = SGN(tGamma) * CBall::Instance()->ZAGRYWKA_LOP_DELTA_GAMMA;
  }
}
void StateLopAiming::UpdateControls(unsigned int Key)
{
   if (IsAi) return;

   if ((Key & VBK_ACTION_1)  == 0)
   {
     mEndTime = NOW;
     mNext = new StateLop(this,player);
     return;
   }
   velocity = CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY + (NOW - mStartTime) * CBall::Instance()->ZAGRYWKA_LOP_V_INCREASE_PER_SEC;
   if (velocity > CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY)
   {
     velocity = CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY;
     mEndTime = NOW;
     mNext = new StateLop(this,player);
     return;
   }
   if ((Key & VBK_UP)    != 0) alfa  += CBall::Instance()->ZAGRYWKA_LOP_DELTA_ALPHA;
   if ((Key & VBK_DOWN)  != 0) alfa  -= CBall::Instance()->ZAGRYWKA_LOP_DELTA_ALPHA;
   if ((Key & VBK_LEFT)  != 0) gamma -= CBall::Instance()->ZAGRYWKA_LOP_DELTA_GAMMA;
   if ((Key & VBK_RIGHT) != 0) gamma += CBall::Instance()->ZAGRYWKA_LOP_DELTA_GAMMA;
   if (alfa > CBall::Instance()->ZAGRYWKA_LOP_MAX_ALPHA) alfa = CBall::Instance()->ZAGRYWKA_LOP_MAX_ALPHA;
   if (alfa < CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA) alfa = CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA;
   if (gamma > CBall::Instance()->ZAGRYWKA_MAX_GAMMA) gamma = CBall::Instance()->ZAGRYWKA_MAX_GAMMA;
   if (gamma < CBall::Instance()->ZAGRYWKA_MIN_GAMMA) gamma = CBall::Instance()->ZAGRYWKA_MIN_GAMMA;
}

State *StateLopAiming::Update()
{
 // char buffer[1024];
 // my_snprintf(buffer,1024,"Lop Aim: Alfa: %g,Gamma: %g, velocity: %g\n",alfa,gamma,velocity);
 // Logger::Instance()->LogToScreen(buffer);
  float current_time = NOW;
  bool has_gamma = false,
       has_alfa = false,
       has_velocity = false;

  if(IsAi)
  {
    if (mGammaTime > current_time) 
    {
      gamma = mDeltaGamma * (NOW - mStartTime);
    }
    else
    {
      has_gamma = true;
      gamma = (mGammaTime- mStartTime) * mDeltaGamma;
    }
    if (mAlphaTime > current_time) 
    {
      alfa = CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA + mDeltaAlpha * (NOW - mStartTime);
    }
    else
    {
      has_alfa = true;
      alfa = CBall::Instance()->ZAGRYWKA_LOP_MIN_ALPHA + mDeltaAlpha * (mAlphaTime - mStartTime);
    }
    if (mVelocityTime > current_time) 
    {
      velocity = CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY + (NOW - mStartTime) * CBall::Instance()->ZAGRYWKA_LOP_V_INCREASE_PER_SEC;
    }
    else
    {
      has_velocity = true;
      velocity = CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY + (mVelocityTime - mStartTime) * CBall::Instance()->ZAGRYWKA_LOP_V_INCREASE_PER_SEC;
    }
  }
  else
  {
    GUI::Instance()->SetBallForce((velocity - CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY)/
        (CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY - CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY));
  }
  this->SetFreeAngle(-gamma, false);
/*
#ifdef DEBUG
  char buffer[1024];
  my_snprintf(buffer,1024,"Lop Aim: Alfa: %g,Gamma: %g, velocity: %g\n",alfa,gamma,velocity);
  Logger::Instance()->LogToScreen(buffer);
#endif
*/
  if (has_alfa && has_gamma && has_velocity)
  {
     mEndTime = NOW;
     mCurrentAnimEndTime = mEndTime;
     mNext = new StateLop(this,player);
  }

  if (current_time >= mCurrentAnimEndTime || current_time >= mEndTime) 
  {
    if (!(mNext && current_time >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == ZAGRYWKA_HINT_AIMING_LOP)) 
    {
      mRepetitionCount++;
      /* uncomment me if Staszek add new animations for this idle */
      //this->mCurrentAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
      //this->mRepetitionAnim = myrand(5);
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mCurrentAnimEndTime == mEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext->SetFreeAngle(-gamma, false);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopAiming.h
#ifndef _STATELOPAIMING_H
#define _STATELOPAIMING_H

/*
class       : StateIdle
description : 

methods     : 
*/ 

class StateLopAiming :public State
{
  float oldTime;
  bool IsAi;
  float mGammaTime,mAlphaTime,mVelocityTime;
  float mDeltaGamma,mDeltaAlpha;
  
public:
  float alfa, gamma, velocity;
  CVector3 mHitPosition;
  StateLopAiming(State *prev, CPlayer *playerPtr);
  StateLopAiming(State *prev, CPlayer *playerPtr, CVector3 *target);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopFinish.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\Camera.h"
#include "..\..\graphics\SceneObject.h"
#include "..\..\graphics\SceneManager.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateLopFinish::StateLopFinish(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_END_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateLopFinish";
#endif  
  mProposedNext = STATE_IDLE;
  
  if ( previous )
  {
    this->player->SetPosOnField(POS_2);
    this->player->SetGotoPosition(POS_2);
  }
}
 
void StateLopFinish::UpdateControls(unsigned int Key)
{
  return;
}

State *StateLopFinish::Update()
{
  if (NOW >= mEndTime) 
  {
    if (!player->GetTeam()->IsAi())
    {
#if 0
      if ( this->player->GetTeam()->GetTeamNumber() == TEAM_0 &&
        SceneManager::Instance()->GetCamera()->GetCurrentCamera() == 0 )
          SceneManager::Instance()->GetCamera()->ChangeCamera(0);

      if ( this->player->GetTeam()->GetTeamNumber() == TEAM_1 &&
        SceneManager::Instance()->GetCamera()->GetCurrentCamera() == 1 )
          SceneManager::Instance()->GetCamera()->ChangeCamera(1);      
#else
        SceneManager::Instance()->GetCamera()->RestoreViewSettings();
#endif
    }


    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopFinish.h
#ifndef _STATELOPFINISH_H
#define _STATELOPFINISH_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateLopFinish :public State
{
public:
  StateLopFinish(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopStart.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateLopStart::StateLopStart(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_AIMING_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateLopStart";
#endif
  mNext = new StateLopAiming(this,player);
  mProposedNext = STATE_IDLE;
}

StateLopStart::StateLopStart(State *previous, CPlayer *playerPtr, CVector3 *target) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_AIMING_LOP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateLopStart";
#endif
  mProposedNext = STATE_IDLE;
  
  mNext = new StateLopAiming(this,player, target);
}

void StateLopStart::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *StateLopStart::Update()
{
  if (NOW >= mEndTime) 
  {
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateLopStart.h
#ifndef _STATELOPSTART_H
#define _STATELOPSTART_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateLopStart :public State
{
public:
  StateLopStart(State *prev, CPlayer *playerPtr);
  StateLopStart(State *previous, CPlayer *playerPtr, CVector3 *target);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieDolne.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

#include "..\..\Core\Ball.h"

CStatePrzyjencieDolne::CStatePrzyjencieDolne(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_DOLNE;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieDolne";
#endif
  //mNext = new CStatePrzyjencieDolneEnd(this,player);
  mProposedNext = PRZYJECIE_END_DOLNE;
  
  StartPosition.z = 0.0f;
}
 
void CStatePrzyjencieDolne::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *CStatePrzyjencieDolne::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieDolne.h
#ifndef _STATEPRZYJENCIEDOLNE_H
#define _STATEPRZYJENCIEDOLNE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieDolne :public State
{
public:
  CStatePrzyjencieDolne(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieDolneEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieDolneEnd::CStatePrzyjencieDolneEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_DOLNE;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieDolneEnd";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStatePrzyjencieDolneEnd::UpdateControls(unsigned int Key)
{
  if (mNext) return;
  Direction dir = KeyToDir(Key);
  mProposedNext = GetRotationStateFromDir(dir);
  if (mProposedNext == STATE_NONE) mProposedNext = RUN_FAST;
}

State *CStatePrzyjencieDolneEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieDolneEnd.h
#ifndef _STATEPRZYJENCIEDOLNEEND_H
#define _STATEPRZYJENCIEDOLNEEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieDolneEnd :public State
{
public:
  CStatePrzyjencieDolneEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieGorne.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieGorne::CStatePrzyjencieGorne(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_GORNE;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieGorne";
#endif
  //mNext = new CStatePrzyjencieGorneEnd(this,player);
  mProposedNext = PRZYJECIE_END_GORNE;
  
  StartPosition.z = 0.0f;
  
  
}
 
void CStatePrzyjencieGorne::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}


State *CStatePrzyjencieGorne::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieGorne.h
#ifndef _STATEPRZYJENCIEGORNE_H
#define _STATEPRZYJENCIEGORNE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieGorne :public State
{
public:
  CStatePrzyjencieGorne(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieGorneEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\meshmanager.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieGorneEnd::CStatePrzyjencieGorneEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_GORNE;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieGorneEnd";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStatePrzyjencieGorneEnd::UpdateControls(unsigned int Key)
{
  return;
  if (mNext) return;
  Direction dir = KeyToDir(Key);
  mProposedNext = GetRotationStateFromDir(dir);
}

State *CStatePrzyjencieGorneEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieGorneEnd.h
#ifndef _STATEPRZYJENCIEGORNEEND_H
#define _STATEPRZYJENCIEGORNEEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieGorneEnd :public State
{
public:
  CStatePrzyjencieGorneEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieKolana.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieKolana::CStatePrzyjencieKolana(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{  
  mCurrent = PRZYJECIE_KOLANA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieKolana";
#endif
  //mNext = new CStatePrzyjencieKolanaEnd(this,player);
  mProposedNext = PRZYJECIE_END_KOLANA;
  StartPosition.z = 0.0f;
}
 
void CStatePrzyjencieKolana::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *CStatePrzyjencieKolana::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieKolana.h
#ifndef _STATEPRZYJENCIEKOLANA_H
#define _STATEPRZYJENCIEKOLANA_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieKolana :public State
{
public:
  CStatePrzyjencieKolana(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieKolanaEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieKolanaEnd::CStatePrzyjencieKolanaEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_KOLANA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieKolanaEnd";
#endif
  mProposedNext = STATE_IDLE;
  
}
 
void CStatePrzyjencieKolanaEnd::UpdateControls(unsigned int Key)
{
  return;
  if (mNext) return;
  Direction dir = KeyToDir(Key);
  mProposedNext = GetRotationStateFromDir(dir);
  if (mProposedNext == STATE_NONE) mProposedNext = RUN_FAST;
}

State *CStatePrzyjencieKolanaEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieKolanaEnd.h
#ifndef _STATEPRZYJENCIEKOLANAEND_H
#define _STATEPRZYJENCIEKOLANAEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieKolanaEnd :public State
{
public:
  CStatePrzyjencieKolanaEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScina.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

CStatePrzyjencieScina::CStatePrzyjencieScina(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieScina";
#endif
  //mNext = new CStatePzyjencieScinaEnd(this, player);
  mProposedNext = PRZYJECIE_END_SCINA;
  
}
 
void CStatePrzyjencieScina::UpdateControls(unsigned int Key)
{
  return;
}

State *CStatePrzyjencieScina::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}

CVector3 CStatePrzyjencieScina::GetOffset()
{
  return GetBallOffset();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScina.h
#ifndef _STATEPzyjencieScina_H
#define _STATEPzyjencieScina_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieScina :public State
{
  
public:
  float alfa,gamma,velocity;
  CStatePrzyjencieScina(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  CVector3 GetOffset();
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

CStatePzyjencieScinaEnd::CStatePzyjencieScinaEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePzyjencieScinaEnd";
#endif  
  mProposedNext = STATE_IDLE;
  
 
}
 
void CStatePzyjencieScinaEnd::UpdateControls(unsigned int Key)
{
  return;
  if (mNext) return;
  Direction dir = KeyToDir(Key);
  mProposedNext = GetRotationStateFromDir(dir);
}

State *CStatePzyjencieScinaEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}

E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaEnd.h
#ifndef _STATEPzyjencieScinaFINISH_H
#define _STATEPzyjencieScinaFINISH_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePzyjencieScinaEnd :public State
{
public:
  CStatePzyjencieScinaEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaEndLow.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

CStatePzyjencieScinaLowEnd::CStatePzyjencieScinaLowEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_SCINA_LOW;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePzyjencieScinaLowEnd";
#endif  
  mProposedNext = STATE_IDLE;
  
 
}
 
void CStatePzyjencieScinaLowEnd::UpdateControls(unsigned int Key)
{
  return;
}

State *CStatePzyjencieScinaLowEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}

E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaEndLow.h
#ifndef _STATEPzyjencieScinaLOWFINISH_H
#define _STATEPzyjencieScinaLOWFINISH_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePzyjencieScinaLowEnd :public State
{
public:
  CStatePzyjencieScinaLowEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaLow.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

CStatePrzyjencieScinaLow::CStatePrzyjencieScinaLow(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_SCINA_LOW;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieScinaLow";
#endif
  //mNext = new CStatePzyjencieScinaEnd(this, player);
  mProposedNext = PRZYJECIE_END_SCINA_LOW;
  
}
 
void CStatePrzyjencieScinaLow::UpdateControls(unsigned int Key)
{
  return;
}

State *CStatePrzyjencieScinaLow::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}

CVector3 CStatePrzyjencieScinaLow::GetOffset()
{
  return GetBallOffset();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieScinaLow.h
#ifndef _STATEPzyjencieScinaLow_H
#define _STATEPzyjencieScinaLow_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieScinaLow :public State
{
  
public:
  float alfa,gamma,velocity;
  CStatePrzyjencieScinaLow(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  CVector3 GetOffset();
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieSkok.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieSkok::CStatePrzyjencieSkok(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_SKOK;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieSkok";
#endif
  //mNext = new CStatePrzyjencieSkokEnd(this,player);
  mProposedNext = PRZYJECIE_END_SKOK;
  
  StartPosition.z = 0.0f;
  
}
 
void CStatePrzyjencieSkok::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *CStatePrzyjencieSkok::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieSkok.h
#ifndef _STATEPRZYJENCIESKOK_H
#define _STATEPRZYJENCIESKOK_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieSkok :public State
{
public:
  CStatePrzyjencieSkok(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieSkokEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieSkokEnd::CStatePrzyjencieSkokEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_SKOK;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieSkokEnd";
#endif
  mProposedNext = STATE_IDLE;
}
 
void CStatePrzyjencieSkokEnd::UpdateControls(unsigned int Key)
{
  return;
}

State *CStatePrzyjencieSkokEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieSkokEnd.h
#ifndef _STATEPRZYJENCIESKOKEND_H
#define _STATEPRZYJENCIESKOKEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieSkokEnd :public State
{
public:
  CStatePrzyjencieSkokEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieStopa.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieStopa::CStatePrzyjencieStopa(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{  
  mCurrent = PRZYJECIE_STOPA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieStopa";
#endif  
  mProposedNext = PRZYJECIE_END_STOPA;
  StartPosition.z = 0.0f;
  //mNext = new CStatePrzyjencieStopaEnd(this,player);
}
 
void CStatePrzyjencieStopa::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *CStatePrzyjencieStopa::Update()
{
  this->player->SetOdbijam(true);
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieStopa.h
#ifndef _STATEPRZYJENCIESTOPA_H
#define _STATEPRZYJENCIESTOPA_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieStopa :public State
{
public:
  CStatePrzyjencieStopa(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieStopaEnd.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStatePrzyjencieStopaEnd::CStatePrzyjencieStopaEnd(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = PRZYJECIE_END_STOPA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StatePrzyjencieStopaEnd";
#endif
  mProposedNext = STATE_IDLE;
}
 
void CStatePrzyjencieStopaEnd::UpdateControls(unsigned int Key)
{
  return;
}

State *CStatePrzyjencieStopaEnd::Update()
{
  if (NOW >= mEndTime) 
  {
    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StatePrzyjencieStopaEnd.h
#ifndef _STATEPRZYJENCIESTOPAEND_H
#define _STATEPRZYJENCIESTOPAEND_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStatePrzyjencieStopaEnd :public State
{
public:
  CStatePrzyjencieStopaEnd(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateRunForward.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"


StateRunForward::StateRunForward(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = RUN_FAST;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateRunForward";
#endif
  mProposedNext = STOP_FAST;
  this->turn = NO_TURN;
  StartPosition.z = 0.0f;
  if (StartPosition.y < 0.25f && this->mdir == ANGLE_0)
  {
     int i = 0;
  }
}
 
void StateRunForward::UpdateControls(unsigned int Key)
{

  if(this->player->CzyOdbijam()) return;

  if((Key & VBK_HINT) == VBK_HINT)
  {
    if (mNext)
    {
       delete mNext;
       mNext = NULL;
    }
    mProposedNext = STOP_FAST;
    if (player->GetPosOnField() == POS_0)
    {
      LogMessage("RF: State Get HINT : %g", NOW );
    }
    mEndTime = NOW;
    return;
  }
 
  if (mNext != NULL) 
  {
    delete mNext;
    mNext = NULL;
  }

  Direction dir = KeyToDir(Key);
  turn = this->GetTurnAngleFromDirs(dir, this->mdir);

  switch (turn)
      {
    case LEFT_180:
    case RIGHT_180:
        mProposedNext = STOP_FAST_TURN_180;       
      mEndTime = NOW;
    break;
    case NO_TURN:
      mProposedNext = RUN_FAST;
      break;
    default:
      mProposedNext = RUN_FAST;
      mEndTime = NOW;
    break;
  }

  this->player->ForceUpdate();
}

State *StateRunForward::Update()
{
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    mNext->TurnDirByAngle(turn);    
    mNext->RecalcLastPosition();
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateRunForward.h
#ifndef _STATERUNFORWARD_H
#define _STATERUNFORWARD_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateRunForward :public State
{
  enum TurnAngle turn;
public:
  StateRunForward(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\States.h
#ifndef _STATES_H
#define _STATES_H

#include "..\state.h"
#include "..\statemanager.h"

#include "StateIdle.h"
#include "StateRunForward.h"
#include "StateStopRun.h"
#include "StateStopRunTurn180.h"
#include "StateTurnLeft135.h"
#include "StateTurnLeft180.h"
#include "StateTurnLeft45.h"
#include "StateTurnLeft90.h"
#include "StateTurnRight135.h"
#include "StateTurnRight180.h"
#include "StateTurnRight45.h"
#include "StateTurnRight90.h"
#include "StateLop.h"
#include "StateLopStart.h"
#include "StateLopAiming.h"
#include "StateLopFinish.h"
#include "StateScina.h"
#include "StateScinaStart.h"
#include "StateScinaAiming.h"
#include "StateScinaFinish.h"
#include "StateZagrywkaIdle.h"
#include "StateZagrywkaStepLeft.h"
#include "StateZagrywkaStepRight.h"

#include "StateHintPrzyjencieDolne.h"
#include "StateHintPrzyjencieGorne.h"
#include "StatePrzyjencieStopa.h"
#include "StatePrzyjencieStopaEnd.h"
#include "StatePrzyjencieKolana.h"
#include "StatePrzyjencieKolanaEnd.h"
#include "StatePrzyjencieDolne.h"
#include "StatePrzyjencieDolneEnd.h"

#include "StatePrzyjencieGorne.h"
#include "StatePrzyjencieGorneEnd.h"
#include "StatePrzyjencieSkok.h"
#include "StatePrzyjencieSkokEnd.h"
#include "StatePrzyjencieScina.h"
#include "StatePrzyjencieScinaEnd.h"
#include "StatePrzyjencieScinaLow.h"
#include "StatePrzyjencieScinaEndLow.h"
#include "StateBlock.h"
#include "StateBlockEnd.h"

#include "StateHopForward.h"

#include "StateHopForwardLeft45.h"
#include "StateHopForwardRight45.h"

#ifdef USE_HOPS
#include "StateHopBackwardLeft45.h"

#include "StateHopBackwardRight45.h"
#endif


#include "StateHintBlock.h"
#include "StateBlockStepLeft.h"
#include "StateBlockStepRight.h"

#include "StateSit.h"
#include "StateStandUp.h"
#include "StateSitDown.h"

#include "StateSzczupak.h"
#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateScina.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"

#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"
#include "..\..\Core\SetupManager.h"

StateScina::StateScina(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_ACTION_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateScina";
#endif
  if ( previous )
  {
    mNext = new StateScinaFinish(this,player);
  }
}
 
void StateScina::UpdateControls(unsigned int Key)
{
  return;
}

State *StateScina::Update()
{
  
  float CurrentTime = CTime::Instance()->GetTime();
  if (CurrentTime > mEndTime) 
  {  
     Event *qEvent = new Event();
     qEvent->mMask   = ET_BALL;
     qEvent->mID     = BE_SERVING;
     qEvent->mID2    = 0;
     qEvent->mTime   = this->mStartTime + this->GetHitDuration();
     qEvent->mUrgent = true;
     BallServeStruct* bss = new BallServeStruct();
     bss->Alfa       = ((StateScinaAiming*)(mPrev))->alfa;
     bss->Gamma      = player->GetTeam()->AngleTeamToWorld(((StateScinaAiming*)(mPrev))->gamma);
     bss->Velocity   = ((StateScinaAiming*)(mPrev))->velocity;

     CVector3 servePoint =  GetBallOffset();
     this->OffsetRotate(&servePoint, &bss->ServePoint);

     bss->ServePoint += StartPosition;
     player->GetTeam()->TeamToWorld(&bss->ServePoint);

     bss->TeamNum = this->player->GetTeam()->GetTeamNumber();

     servePoint.Set(&bss->ServePoint);

     qEvent->mData = (void *)bss;
     EventManager::Instance()->PostEvent(qEvent);
     qEvent->Release();

     if (SetupManager::Instance()->GetSound()->ball)
     {
        qEvent = new Event();
        CVector3 *pos = new CVector3();
        pos->Set(&servePoint);
        qEvent->mData = (void *)pos;
        qEvent->mUrgent = false;
        qEvent->mMask = ET_AUDIO;
        qEvent->mID2 = 0;
        qEvent->mID   = WAV_5;
        qEvent->mTime = this->mStartTime + this->GetHitDuration();
        EventManager::Instance()->PostEvent(qEvent);
        qEvent->Release();
     }

     return mNext->Update();
  }
  return this;
}
CVector3 StateScina::GetOffset()
{
  return GetBallOffset();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateScina.h
#ifndef _STATEScina_H
#define _STATEScina_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateScina :public State
{
  
public:
  float alfa,gamma,velocity;
  StateScina(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  CVector3 GetOffset();
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaAiming.cpp
#include "..\..\config.h"


#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\meshmanager.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"
#include "..\..\graphics\GUI.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\Ball.h"

StateScinaAiming::StateScinaAiming(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{  
  IsAi = false;
  mCurrent = ZAGRYWKA_HINT_AIMING_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "StateScinaAiming";
#endif
  alfa = gamma = 0.0f;
  velocity = CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY;
  
}



StateScinaAiming::StateScinaAiming(State *prev, CPlayer *playerPtr, CVector3 *target) :State(prev, playerPtr)
{
  IsAi = true;
  mCurrent = ZAGRYWKA_HINT_AIMING_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "StateScinaAiming";
#endif
  
  
  CVector3 delta = *target - StartPosition;
  float R2 = sqrtf(delta.x * delta.x + delta.y * delta.y);
  
  CVector3 finalPos;
  
  {
    StateScina *temp = new StateScina(this,playerPtr);
    finalPos = temp->GetOffset(); 
    this->SetNextState(NULL);
    temp = NULL;
  }
  
  float c =  delta.y/R2;
  float s =  delta.x/R2;
  float x = (finalPos.x * c - finalPos.y *s);
  float y = (finalPos.x * s + finalPos.y *c);
  finalPos.x = x;
  finalPos.y = y;
  finalPos = StartPosition - finalPos;      
  delta = *target - finalPos;
  

  float speed,alpha;
  speed = 1e30f;
  float R = sqrtf(delta.x * delta.x + delta.y * delta.y);
  float minalpha = CBall::Instance()->ZAGRYWKA_SCINA_MIN_ALPHA/4;//atan(-delta.z/R) + 0.1;
  while (speed < CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY || speed > CBall::Instance()->ZAGRYWKA_MAX_SCINA_VELOCITY)
  {
    float trand =(float) myrand(100);
    alpha = GaussRand(0.95f * CBall::Instance()->ZAGRYWKA_GAUSS_SCINA_ALPHA,0.05f, CBall::Instance()->ZAGRYWKA_SCINA_MIN_ALPHA/2,
                 CBall::Instance()->ZAGRYWKA_SCINA_MAX_ALPHA);//(trand/100) * (MAX_ALPHA - minalpha) + minalpha;
    float tg = tanf(alpha);
	  float cosSq = cosf(alpha);
    cosSq *= cosSq;
    float minPredkoscDlaAlfaMaxSq =(CBall::Instance()->GRAVITY/2) * R *  R/((FABS(delta.z) + R*tg)*cosSq);
    speed = sqrtf(FABS(minPredkoscDlaAlfaMaxSq));
}
  

  mVelocityTime = (speed - CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY) / CBall::Instance()->ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;
  
 
  mVelocityTime += mStartTime;
  DIE(mVelocityTime > mStartTime);
  float tGamma =  -asinf(delta.x/R);

  mAlphaTime =  FABS(alpha)/CBall::Instance()->ZAGRYWKA_SCINA_DELTA_ALPHA + mStartTime;
  if (mAlphaTime > mVelocityTime)
  {
    mAlphaTime = mVelocityTime;
    mDeltaAlpha = (alpha ) / (mVelocityTime - mStartTime);
  }
  else
  {
    mDeltaAlpha = SGN(alpha) * CBall::Instance()->ZAGRYWKA_SCINA_DELTA_ALPHA;
  }

  mGammaTime = FABS(tGamma)/CBall::Instance()->ZAGRYWKA_SCINA_DELTA_GAMMA + mStartTime;
  if (mGammaTime > mVelocityTime)
  {
    mGammaTime = mVelocityTime;
    mDeltaGamma = tGamma / (mVelocityTime - mStartTime);
  }
  else
  {
    mDeltaGamma = SGN(tGamma) *CBall::Instance()->ZAGRYWKA_SCINA_DELTA_GAMMA;
  }
}

void StateScinaAiming::UpdateControls(unsigned int Key)
{
  if (IsAi) return;

   if ((Key & VBK_ACTION_2)    == 0)
   {
     mEndTime = NOW;
     mNext = new StateScina(this,player);
     return;
   }

   velocity = CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY + (NOW - mStartTime) * CBall::Instance()->ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;
   if (velocity > CBall::Instance()->ZAGRYWKA_MAX_SCINA_VELOCITY)
   {
     velocity = CBall::Instance()->ZAGRYWKA_MAX_SCINA_VELOCITY;
     mEndTime = NOW; 
     mNext = new StateScina(this,player);
     return;
   }
   if ((Key & VBK_UP)    != 0) alfa  += CBall::Instance()->ZAGRYWKA_SCINA_DELTA_ALPHA;
   if ((Key & VBK_DOWN)  != 0) alfa  -= CBall::Instance()->ZAGRYWKA_SCINA_DELTA_ALPHA;
   if ((Key & VBK_LEFT)  != 0) gamma -= CBall::Instance()->ZAGRYWKA_SCINA_DELTA_GAMMA;
   if ((Key & VBK_RIGHT) != 0) gamma += CBall::Instance()->ZAGRYWKA_SCINA_DELTA_GAMMA;
   if (alfa > CBall::Instance()->ZAGRYWKA_SCINA_MAX_ALPHA) alfa = CBall::Instance()->ZAGRYWKA_SCINA_MAX_ALPHA;
   if (alfa < CBall::Instance()->ZAGRYWKA_SCINA_MIN_ALPHA) alfa = CBall::Instance()->ZAGRYWKA_SCINA_MIN_ALPHA;
   if (gamma > CBall::Instance()->ZAGRYWKA_MAX_GAMMA) gamma = CBall::Instance()->ZAGRYWKA_MAX_GAMMA;
   if (gamma < CBall::Instance()->ZAGRYWKA_MIN_GAMMA) gamma = CBall::Instance()->ZAGRYWKA_MIN_GAMMA;

}
State *StateScinaAiming::Update()
{
  float current_time = NOW;
  bool has_gamma = false,
       has_alfa = false,
       has_velocity = false;

  if(IsAi)
  {
    if (mGammaTime > current_time) 
    {
      gamma = mDeltaGamma * (NOW - mStartTime);
    }
    else
    {
      has_gamma = true;
      gamma = (mGammaTime- mStartTime) * mDeltaGamma;
    }
    if (mAlphaTime > current_time) 
    {
      alfa = mDeltaAlpha * (NOW - mStartTime);
    }
    else
    {
      has_alfa = true;
      alfa = mDeltaAlpha * (mAlphaTime - mStartTime);
    }
    if (mVelocityTime > current_time) 

    {
      velocity = CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY + (NOW - mStartTime) *
                                    CBall::Instance()->ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;
    }
    else
    {
      has_velocity = true;
      velocity = CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY + (mVelocityTime - mStartTime) *
                                                CBall::Instance()->ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;
    }
     
    
  }
  else
  {
    GUI::Instance()->SetBallForce((velocity - CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY)/
         (CBall::Instance()->ZAGRYWKA_MAX_SCINA_VELOCITY - CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY));
  }
  this->SetFreeAngle(-gamma, false);
/*
#ifdef DEBUG
  char buffer[1024];
  my_snprintf(buffer,1024,"Scina Aim: Alfa: %g,Gamma: %g, velocity: %g\n",alfa,gamma,velocity);
  Logger::Instance()->LogToScreen(buffer);
#endif
*/
  if (has_alfa && has_gamma && has_velocity)
  {
     mEndTime = NOW;
     mNext = new StateScina(this,player);
  }
  
  if (current_time >= mCurrentAnimEndTime || current_time >= mEndTime) 
  {
    if (!(mNext && current_time >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == ZAGRYWKA_HINT_AIMING_SCINA)) 
    {
      mRepetitionCount++;
      /* uncomment me if Staszek add new animations for this idle */
      //this->mCurrentAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
      //this->mRepetitionAnim = myrand(5);

      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mCurrentAnimEndTime == mEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext->SetFreeAngle(-gamma, false);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaAiming.h
#ifndef _STATEScinaAIMING_H
#define _STATEScinaAIMING_H

/*
class       : StateIdle
description : 

methods     : 
*/ 

class StateScinaAiming :public State
{
  float oldTime;
  bool IsAi;
  float mGammaTime,mAlphaTime,mVelocityTime;
  float mDeltaGamma,mDeltaAlpha;
public:
  float alfa, gamma, velocity;
  CVector3 mHitPosition;
  StateScinaAiming(State *prev, CPlayer *playerPtr);
  StateScinaAiming(State *prev, CPlayer *playerPtr, CVector3* target);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaFinish.cpp
#include "..\..\config.h"

#include <assert.h>


#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\Camera.h"
#include "..\..\graphics\SceneObject.h"
#include "..\..\graphics\SceneManager.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateScinaFinish::StateScinaFinish(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_END_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateScinaFinish";
#endif
  
  mProposedNext = STATE_IDLE;
  
  if ( previous )
  {
    this->player->SetPosOnField(POS_2);
    this->player->SetGotoPosition(POS_2);
  }
}
 
void StateScinaFinish::UpdateControls(unsigned int Key)
{
  return;
  if (mNext) return;
  Direction dir = KeyToDir(Key);
  mProposedNext = GetRotationStateFromDir(dir);
}

State *StateScinaFinish::Update()
{
  if (NOW >= mEndTime) 
  {
    if (!player->GetTeam()->IsAi())
    {
#if 0
      if ( this->player->GetTeam()->GetTeamNumber() == TEAM_0 &&
        SceneManager::Instance()->GetCamera()->GetCurrentCamera() == 0 )
          SceneManager::Instance()->GetCamera()->ChangeCamera(0);

      if ( this->player->GetTeam()->GetTeamNumber() == TEAM_1 &&
        SceneManager::Instance()->GetCamera()->GetCurrentCamera() == 1 )
          SceneManager::Instance()->GetCamera()->ChangeCamera(1);      
#else
        SceneManager::Instance()->GetCamera()->RestoreViewSettings();
#endif   
    }

    this->player->SetOdbijam(false);
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaFinish.h
#ifndef _STATEScinaFINISH_H
#define _STATEScinaFINISH_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateScinaFinish :public State
{
public:
  StateScinaFinish(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaStart.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateScinaStart::StateScinaStart(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_AIMING_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateScinaStart";
#endif
  mNext = new StateScinaAiming(this,player);
  mProposedNext = STATE_IDLE;
}

StateScinaStart::StateScinaStart(State *previous, CPlayer *playerPtr, CVector3 *target) :State(previous, playerPtr)
{ 
  mCurrent = ZAGRYWKA_AIMING_SCINA;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateScinaStart";
#endif  
  mProposedNext = STATE_IDLE;
  
  mNext = new StateScinaAiming(this,player,target);
}

void StateScinaStart::UpdateControls(unsigned int Key)
{
  return; // ignorujemy caly input
}

State *StateScinaStart::Update()
{
  if (NOW >= mEndTime) 
  {
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateScinaStart.h
#ifndef _STATEScinaSTART_H
#define _STATEScinaSTART_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateScinaStart :public State
{
public:
  StateScinaStart(State *prev, CPlayer *playerPtr);
  StateScinaStart(State *previous, CPlayer *playerPtr, CVector3 *target);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateSit.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\Conf.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\meshmanager.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\Team.h"

#define MAX_SCRIPTS 10

StateSit::StateSit(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = SIT_IDLE;
  this->mAnims = NULL;
//this->mRepetitionAnim = myrand(MAX_SIT_ANIMATIONS - 1);
  /* this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
     mEndTime = mStartTime + GetDuration();
     mCurrentAnimEndTime = mEndTime; */
  SelectAnims();
   
   this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mAnims[0].anim);
mEndTime = mStartTime + GetDuration();
   mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG  
  StrCurrentState = "StateSit";  
#endif

  StartPosition.z = 0.0f;
  
}

 
State *StateSit::Update()
{
  float CurrentTime = NOW;

  
  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == SIT_IDLE )) 
    {
      mRepetitionCount++;

      this->mAnims[mCurrAnimSet].rep_count--;
      if (this->mAnims[mCurrAnimSet].rep_count == 0)
      {
        this->mCurrAnimSet++;
        if (this->mCurrAnimSet == this->mAnimCount)
        {
          SelectAnims();
        }
      }

      this->mCurrentAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mAnims[mCurrAnimSet].anim);
      if(myrand(100) < 25)
      {
        this->mRepetitionAnim = myrand(MAX_SIT_ANIMATIONS - 1);
      }
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mEndTime == mCurrentAnimEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      if (this->mAnims) delete[] this->mAnims;
      mNext = GetNext(true);
      return mNext->Update();
    }
  }
  return this;
}

void StateSit::SelectAnims()
{
  if (this->mAnims) delete[] this->mAnims;
  char x = myrand(MAX_SCRIPTS-1)+1;
  ConfFile config;
  char buffer[256];
  my_snprintf(buffer,256,".\\Data\\sit_script_%i.dat",x);
  config.Init(buffer);
 
  config.GET_INT("ANIMATION_COUNT",&mAnimCount);
  this->mAnims = new AnimSet[mAnimCount];
  
  for (int i = 0 ; i < mAnimCount;i++)
  {
    my_snprintf(buffer,256,"ANIMATION_%i",i);
    config.GET_INT(buffer,&mAnims[i].anim);
    my_snprintf(buffer,256,"ANIMATION_%i_REPETITIONS",i);
    config.GET_INT(buffer,&mAnims[i].rep_count);
  }

  this->mCurrAnimSet = 0;
  config.DeInit();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateSit.h
#ifndef _STATESIT_H
#define _STATESIT_H

/*
class       : StateIdle
description : 

methods     : 
*/ 

struct AnimSet
{
  int anim;
  int rep_count;
};


class StateSit :public State
{
  AnimSet *mAnims;
  int mAnimCount, mCurrAnimSet;
public:
  StateSit(State *prev, CPlayer *playerPtr);
  State *Update();
  void SelectAnims();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateSitDown.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateSitDown::StateSitDown(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = SIT_DOWN;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateSitDown";
#endif
  mProposedNext = SIT_IDLE;  
  
}
/* 

State *StateSitDown::Update()
{
  float CurrentTime = CTime::Instance()->GetTime();
  if (CurrentTime > mEndTime) 
  {  
     mNext = GetNext(true);
     return mNext->Update();
  }
  return this;
}
*/

E:\Project\Kopia (5) VBEngine\Ai\States\StateSitDown.h
#ifndef _STATESITDOWN_H
#define _STATESITDOWN_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateSitDown :public State
{
  
public:
  StateSitDown(State *prev, CPlayer *playerPtr);
  //State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateStandUp.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateStandUp::StateStandUp(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = STAND_UP;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateStandUp";
#endif
  mProposedNext = STATE_IDLE;
  
}
/*

State *StateStandUp::Update()
{
  float CurrentTime = CTime::Instance()->GetTime();
  if (CurrentTime > mEndTime) 
  {  
     mNext = GetNext(true); 
     return mNext->Update();
  }
  return this;
}
*/

E:\Project\Kopia (5) VBEngine\Ai\States\StateStandUp.h
#ifndef _STATESTANDUP_H
#define _STATESTANDUP_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateStandUp :public State
{
  
public:
  StateStandUp(State *prev, CPlayer *playerPtr);
  //State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateStopRun.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

StateStopRun::StateStopRun(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  this->mCurrent = STOP_FAST;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateStopRun";
#endif
  mProposedNext = STATE_IDLE;
  this->turn = NO_TURN;
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void StateStopRun::UpdateControls(unsigned int Key)
{
  if((Key & VBK_HINT) == VBK_HINT)
   {
    if (mNext)
    {
      delete mNext;
      mNext = NULL;
    }
    mProposedNext = STATE_IDLE;
    return;
  }

  if (mNext) return;

  Direction dir = KeyToDir(Key);
  turn = this->GetTurnAngleFromDirs(dir, this->mdir);
    
   if (CheckFrontiers(&turn))
  {
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}

State * StateStopRun::Update(void)
{
  if (NOW >= mEndTime) 
  {
    mNext = GetNext(true);
    mNext->TurnDirByAngle(turn);    
    mNext->RecalcLastPosition();
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateStopRun.h
#ifndef _STATESTOPRUN_H
#define _STATESTOPRUN_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateStopRun :public State
{
  enum TurnAngle turn;
public:
  StateStopRun(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update(void);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateStopRunTurn180.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateStopRunTurn180::StateStopRunTurn180(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = STOP_FAST_TURN_180;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateStopRunTurn180";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void StateStopRunTurn180::UpdateControls(unsigned int Key)
{
   if((Key & VBK_HINT) == VBK_HINT)
   {
    if (mNext)
    {
      delete mNext;
      mNext = NULL;
    }
    mProposedNext = STATE_IDLE;
    return;
  }
  if (mNext) return;
  //this->mEndDir =  KeyToDir(Key);
  //mProposedNext = RUN_FAST;
  //mEndTime = NOW;
  //this->player->ForceUpdate();
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateStopRunTurn180.h
#ifndef _STATESTOPRUNTURN180_H
#define _STATESTOPRUNTURN180_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateStopRunTurn180 :public State
{
public:
  StateStopRunTurn180(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateSzczupak.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"
#include "..\..\Core\team.h"
#include "..\..\Core\Ball.h"

StateSzczupak::StateSzczupak(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = STATE_SZCZUPAK;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateSzczupak";
#endif
  mProposedNext = STATE_IDLE;  
}


State *StateSzczupak::Update()
{
  this->player->SetOdbijam(true);
  float CurrentTime = CTime::Instance()->GetTime();
  if (CurrentTime > mEndTime) 
  {  
     this->player->SetOdbijam(false);
     mNext = GetNext(true);
     return mNext->Update();
  }
  return this;
}
/* */

E:\Project\Kopia (5) VBEngine\Ai\States\StateSzczupak.h
#ifndef _STATESZCZUPAK_H
#define _STATESZCZUPAK_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateSzczupak :public State
{
  
public:
  StateSzczupak(State *prev, CPlayer *playerPtr);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft135.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"


#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnLeft135::CStateTurnLeft135(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_LEFT_135;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnLeft135";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnLeft135::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;
  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft135.h
#ifndef _STATETURNLEFT135_H
#define _STATETURNLEFT135_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnLeft135 :public State
{
public:
  CStateTurnLeft135(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft180.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "states.h"

#include "..\..\Core\zawodnik.h"

CStateTurnLeft180::CStateTurnLeft180(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_LEFT_180;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateTurnLeft180";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnLeft180::UpdateControls(unsigned int Key)
{
 if(this->player->CzyOdbijam()) return;
 if((Key & VBK_HINT) == VBK_HINT)
 {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
 }
 if (mNext) return;

  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft180.h
#ifndef _STATETURNLEFT180_H
#define _STATETURNLEFT180_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnLeft180 : public State
{
public:
  CStateTurnLeft180(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft45.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnLeft45::CStateTurnLeft45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_LEFT_45;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnLeft45";
#endif
  mProposedNext = STATE_IDLE;
  

  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnLeft45::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;

  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft45.h
#ifndef _STATETURNLEFT45_H
#define _STATETURNLEFT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnLeft45 :public State
{
public:
  CStateTurnLeft45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft90.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnLeft90::CStateTurnLeft90(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_LEFT_90;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnLeft90";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnLeft90::UpdateControls(unsigned int Key)
{

  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;

  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
  
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnLeft90.h
#ifndef _STATETURNLEFT90_H
#define _STATETURNLEFT90_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnLeft90 :public State
{
public:
  CStateTurnLeft90(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);

};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight135.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnRight135::CStateTurnRight135(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_RIGHT_135;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnRight135";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnRight135::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;
  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight135.h
#ifndef _STATETURNRIGHT135_H
#define _STATETURNRIGHT135_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnRight135 : public State
{
public:
  CStateTurnRight135(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight180.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"

#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnRight180::CStateTurnRight180(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_RIGHT_180;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateTurnRight180";
#endif
  mProposedNext = STATE_IDLE;
  
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnRight180::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;
  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}

E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight180.h
#ifndef _STATETURNRIGHT180_H
#define _STATETURNRIGHT180_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnRight180 : public State
{
public:
  CStateTurnRight180(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight45.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"

#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnRight45::CStateTurnRight45(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = TURN_RIGHT_45;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnRight45";
#endif
  mProposedNext = STATE_IDLE;
      
  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnRight45::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;
  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight45.h
#ifndef _STATETURNRIGHT45_H
#define _STATETURNRIGHT45_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnRight45 :public State
{
public:
  CStateTurnRight45(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight90.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateTurnRight90::CStateTurnRight90(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{ 
  mCurrent = TURN_RIGHT_90;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "CStateTurnRight90";
#endif
  mProposedNext = STATE_IDLE;

  this->mEndDir = this->TurnAnyDirByAngle(this->GetTurnAngleFromState(this->mCurrent), this->mdir, &this->mFreeAngle);
}
 
void CStateTurnRight90::UpdateControls(unsigned int Key)
{
  if(this->player->CzyOdbijam()) return;
  if((Key & VBK_HINT) == VBK_HINT)
  {
   if (mNext)
   {
     delete mNext;
     mNext = NULL;
   }
   mProposedNext = STATE_IDLE;
   return;
  }
  if (mNext) return;

  enum Direction tmp = KeyToDir(Key);
  if (CheckFrontiers(tmp))
  {
    this->mEndDir =  tmp;
  mProposedNext = RUN_FAST;
  mEndTime = NOW;
  this->player->ForceUpdate();
  }

}
E:\Project\Kopia (5) VBEngine\Ai\States\StateTurnRight90.h
#ifndef _STATETURNRIGHT90_H
#define _STATETURNRIGHT90_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateTurnRight90 :public State
{
public:
  CStateTurnRight90(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaIdle.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\animation.h"
#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\Camera.h"
#include "..\..\graphics\SceneObject.h"
#include "..\..\graphics\Stadion.h"
#include "..\..\graphics\SceneManager.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

CStateZagrywkaIdle::CStateZagrywkaIdle(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = ZAGRYWKA_HINT;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
  mCurrentAnimEndTime = mEndTime;
#ifdef DEBUG
  StrCurrentState = "CStateZagrywkaIdle";
#endif
  this->mdir = ANGLE_0;
  
  is_ai = false;
  if(playerPtr->IsAI())
  {
    is_ai = true;
    CVector3 target;
    
    target.x = ((float)(myrand(45)) / 10.0f ) * (myrand(100) < 50 ? -1.0f : 1.0f);
    target.y = (2.5f + ((float)(myrand(65)) / 10.0f) ) * -1.0f;

    if(target.y < - 6.5f)
    {
      mNext = new StateScinaStart(this,player, &target);
    }
    else
    {
      mNext = new StateLopStart(this,player, &target);
    }

    player->SetOdbijam(true);
  }
}
 
void CStateZagrywkaIdle::UpdateControls(unsigned int Key)
{
  if (is_ai) return;
  if (mProposedNext != ZAGRYWKA_AIMING_LOP && CheckFlag(Key, VBK_ACTION_1))
  {
    mProposedNext = ZAGRYWKA_AIMING_LOP;
    mEndTime = NOW;
    player->SetAI(true);
    player->SetOdbijam(true);
    return;
  }
  if (mProposedNext != ZAGRYWKA_AIMING_SCINA && CheckFlag(Key, VBK_ACTION_2))
  {
    mProposedNext = ZAGRYWKA_AIMING_SCINA;
    mEndTime = NOW;
    player->SetAI(true);
    player->SetOdbijam(true);
    return;
  }
  if (CheckFlag(Key, VBK_LEFT) && this->LastPosition.x < 7.5f)
  {
    mProposedNext = ZAGRYWKA_STEP_LEFT;
    mEndTime = NOW;
  }
  else
  {
    if (CheckFlag(Key, VBK_RIGHT) && this->LastPosition.x > -7.5f)
    {
      mProposedNext = ZAGRYWKA_STEP_RIGHT;
      mEndTime = NOW;
    }
  }
  this->player->ForceUpdate();
}
 
State *CStateZagrywkaIdle::Update()
{
  float CurrentTime = NOW;
  
  if (CurrentTime >= mCurrentAnimEndTime || CurrentTime >= mEndTime) 
  {
    if (!(mNext && CurrentTime >= mEndTime) && (mProposedNext == STATE_NONE || mProposedNext == ZAGRYWKA_HINT)) 
    {
      mRepetitionCount++;
      /* uncomment me if Staszek add new animations for this idle */
      //this->mCurrentAnim = this->player->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
      //this->mRepetitionAnim = myrand(5);
      
      this->mCurrentAnimStartTime = mCurrentAnimEndTime;
      if(mCurrentAnimEndTime == mEndTime)
      {
        mEndTime += GetDuration();
      }
      mCurrentAnimEndTime += GetDuration();
    }
    else
    {
      mNext = GetNext(true);
      return mNext->Update();
    }
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaIdle.h
#ifndef _STATEZAGRYWKAIDLE_H
#define _STATEZAGRYWKAIDLE_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class CStateZagrywkaIdle :public State
{
  bool is_ai;
public:
  CStateZagrywkaIdle(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaStepLeft.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"

StateZagrywkaStepLeft::StateZagrywkaStepLeft(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = ZAGRYWKA_STEP_LEFT;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateZagrywkaStepLeft";
#endif
  mProposedNext = ZAGRYWKA_HINT;
}
 
void StateZagrywkaStepLeft::UpdateControls(unsigned int Key)
{
  if (CheckFlag(Key, VBK_HINT))
  {
    mProposedNext = ZAGRYWKA_HINT;
    mEndTime = NOW;
    this->player->ForceUpdate();
  return;
  }
  if (CheckFlag(Key, VBK_LEFT) && this->LastPosition.x < 7.5f)
  {
    mProposedNext = ZAGRYWKA_STEP_LEFT;
  }
  else
  {
    if (CheckFlag(Key, VBK_RIGHT) && this->LastPosition.x > -7.5f)
    {
      mProposedNext = ZAGRYWKA_STEP_RIGHT;
    }
  }
}

State *StateZagrywkaStepLeft::Update()
{
  if (NOW >= mEndTime) 
  {
    if ((this->LastPosition.x + this->GetOffset().x > 7.5f) || (this->LastPosition.x + this->player->GetOffset(ZAGRYWKA_STEP_RIGHT)->x < -7.5f))
    {
      mProposedNext = ZAGRYWKA_HINT;
    }
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaStepLeft.h
#ifndef _STATEZAGRYWKASTEPLEFT_H
#define _STATEZAGRYWKASTEPLEFT_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateZagrywkaStepLeft :public State
{
public:
  StateZagrywkaStepLeft(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaStepRight.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\Utility\Defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\VBmath.h"
#include "..\..\utility\ctime.h"
#include "..\..\Utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\EventHandler.h"
#include "..\..\Utility\tools.h"
#include "..\..\Utility\logger.h"

#include "..\..\graphics\AnimationManager.h"
#include "..\..\graphics\SceneObject.h"

#include "States.h"

#include "..\..\Core\zawodnik.h"


StateZagrywkaStepRight::StateZagrywkaStepRight(State *previous, CPlayer *playerPtr) :State(previous, playerPtr)
{
  mCurrent = ZAGRYWKA_STEP_RIGHT;
  this->mCurrentAnim = playerPtr->GetStateAnimationHandler(this->mCurrent, this->mRepetitionAnim);
  mEndTime = mStartTime + GetDuration();
#ifdef DEBUG
  StrCurrentState = "StateZagrywkaStepRight";
#endif
  mProposedNext = ZAGRYWKA_HINT;
  
}
 
void StateZagrywkaStepRight::UpdateControls(unsigned int Key)
{
  if (CheckFlag(Key, VBK_HINT))
  {

    mProposedNext = ZAGRYWKA_HINT;
    mEndTime = NOW;
    this->player->ForceUpdate();
 return;
  }
  if (CheckFlag(Key, VBK_LEFT) && this->LastPosition.x < 7.5f)
  {
    mProposedNext = ZAGRYWKA_STEP_LEFT;
  }
  else
  {
    if (CheckFlag(Key, VBK_RIGHT) && this->LastPosition.x > -7.5f)
    {
      mProposedNext = ZAGRYWKA_STEP_RIGHT;
    }
  }
}

State *StateZagrywkaStepRight::Update()
{
  if (NOW >= mEndTime) 
  {
    if ((this->LastPosition.x + this->GetOffset().x < -7.5f) || (this->LastPosition.x + this->player->GetOffset(ZAGRYWKA_STEP_LEFT)->x > 7.5f))
    {
      mProposedNext = ZAGRYWKA_HINT;
    }
    mNext = GetNext(true);
    return mNext->Update();
  }
  return this;
}
E:\Project\Kopia (5) VBEngine\Ai\States\StateZagrywkaStepRight.h
#ifndef _STATEZAGRYWKASTEPRIGHT_H
#define _STATEZAGRYWKASTEPRIGHT_H

/*
class       : StateIdle
description : 

methods     : 
*/ 


class StateZagrywkaStepRight :public State
{
public:
  StateZagrywkaStepRight(State *prev, CPlayer *playerPtr);
  void UpdateControls(unsigned int Key);
  State *Update();
};

#endif
E:\Project\Kopia (5) VBEngine\Ai\Tactic.cpp
#include "..\config.h"

#include <assert.h>
#include <string.h>


#include "..\utility\misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"
//#include "..\utility\ctime.h"
#include "..\utility\conf.h"
#include "..\utility\Tools.h"

#include "Tactic.h"

CPosition::CPosition()
{
  memset(this->Pos, 0, sizeof(struct TacPosition) * MAX_PLAYERS_ON_FIELD);
}

CPosition::~CPosition()
{
  
}

bool CPosition::Load(const char *file)
{
 // tactic file loader
  ConfFile Config;
  char buffer[256];

  int priority[MAX_PLAYERS_ON_FIELD];
  int i;


  for(i=0; i < MAX_PLAYERS_ON_FIELD; i++)
  {  
    priority[i] = i;
  }

  my_snprintf(buffer, 256, ".\\Data\\%s", file);  
  if (SUCCEEDED(Config.Init(buffer)))  
  { 

    this->Versus = -1;
    Config.GET_INT("VERSUS", &this->Versus);
  

    this->Main = LAST_POS;
    Config.GET_INT("MAIN", (int*)&this->Main);
  
    for(i=0; i < MAX_PLAYERS_ON_FIELD; i++)
    {  
      my_snprintf(buffer, 256, "PLAYER%d_NEWPOS", i);  
      this->Pos[i].is_position_set = false;
      if(SUCCEEDED(Config.GET_VECT(buffer,
          &this->Pos[i].Position.x,
          &this->Pos[i].Position.y,
          &this->Pos[i].Position.z)
          ))
      {
        this->Pos[i].is_position_set = true;
      }


      my_snprintf(buffer, 256, "PLAYER%d_PRIORITY", i);  
      this->Pos[i].Priority = -1;
      if(SUCCEEDED(Config.GET_INT(buffer, &this->Pos[i].Priority)))
      {
        priority[i] = -1;
      }

     }

     for(i=0; i < MAX_PLAYERS_ON_FIELD; i++)
     {
      if(this->Pos[i].Priority == -1)
      {
        int j = 0;
        while(j < MAX_PLAYERS_ON_FIELD && priority[j] == -1) { j++; }
        DIE(j < MAX_PLAYERS_ON_FIELD && "Czary przy automatycznym nadaniu priorytetu");
        this->Pos[i].Priority = priority[j];
        priority[j] = -1;
      }
     }

     Config.DeInit();
     return true;
  }
  return false;
}



/* ===================================================================================== */

CPhase::CPhase()
{
  memset(this, 0, sizeof(CPhase));  
}

CPhase::~CPhase()
{

}

bool CPhase::Load(const char *file)
{
  ConfFile Config;
  char buffer[MAX_FILE_NAME];

  my_snprintf(buffer, MAX_FILE_NAME, ".\\Data\\%s", file);  
  if (SUCCEEDED(Config.Init(buffer)))  
  { 
    //my_snprintf(this->Name, 256, file);
  
    this->HitMan = POS_0;
    this->is_hitman_set = false;
    if(SUCCEEDED(Config.GET_INT("HITMAN", (int *)&this->HitMan)))
        {
      this->is_hitman_set = true;
      }

    this->Area = POS_0;
    Config.GET_INT("AREA", (int *)&this->Area);

    this->setup = POS_0;
    Config.GET_INT("SETUP", &this->setup);
    
    this->type = 0;
    Config.GET_INT("TYPE", &this->type);

    this->is_target_set = false;
    if(SUCCEEDED(Config.GET_VECT("BALL_DEST_POSITION",
            &this->BallTarget.x,
            &this->BallTarget.y,
            &this->BallTarget.z)))
    {
      this->is_target_set = true;
    }

     Config.DeInit();
     return true;
  }
  return false;
}



/* ===================================================================================== */

CTactic::CTactic()
{
  
}

CTactic::~CTactic()
{

}

bool CTactic::Load(const char *file)
{
  // tactic file loader
  ConfFile Config;
  char buffer[256];

  my_snprintf(buffer,256,"%s%s",DataPath, file);
  if (SUCCEEDED(Config.Init(buffer)))
  { 

    this->max_phases = MAX_TACTIC_PHASES;
    Config.GET_INT("COUNT", &this->max_phases);

    //my_snprintf(TacticTab[tactic].Name, 256, file);

    for(int i = 0; i < this->max_phases; i++)
    {
      my_snprintf(buffer, 256, "PHASE_%d", i);
      this->Phase[i] = 0;
      Config.GET_INT(buffer, (int *)&this->Phase[i]);  
    }

    Config.DeInit();

    return (i ? true : false);
  }

  return false;
}

/*
bool CTactic::IsPlayerValid(unsigned char player)
{
  switch(player)
  {
    case POS_0:
    case POS_1:
    case POS_2:          
    case POS_3:
    case POS_4:
    case POS_5:
      return true;
    default:
      return false;
  }
}
*/
E:\Project\Kopia (5) VBEngine\Ai\Tactic.h
#ifndef _TACTIC_H_
#define _TACTIC_H_

/*
class       :
description :

methods     :

*/


/*
#define MAX_POSITIONS 10

struct TacPosition
{
  CVector3 Position;
  bool is_position_set;
  int Priority;
};


class CPosition
{
  TacPosition Pos[MAX_POSITIONS][MAX_PLAYERS_ON_FIELD];
  char Name[MAX_POSITIONS][MAX_FILE_NAME];
  int  Versus[MAX_POSITIONS];
  bool LoadPos(int positons, const char *file);
public:
  CPosition();
  ~CPosition();
  bool Load(const char *file);
  bool IsPlayerValid(unsigned char player);
  bool IsPositionValid(unsigned char phase, unsigned char player)
  {
    return (this->IsPlayerValid(player) ? this->Pos[phase][player].is_position_set : false );
  };
  CVector3 *GetPosition(unsigned char phase, unsigned char player)
  {
    return (this->IsPlayerValid(player) ? &this->Pos[phase][player].Position : NULL );
  };
  int GetVersus(unsigned char phase)
  {
    return this->Versus[phase];
  }
  int GetPriority(unsigned char phase, unsigned char player)
  {
    return (this->IsPlayerValid(player) ? this->Pos[phase][player].Priority : 6 );
  }
  void SetPriority(unsigned char phase, unsigned char player, int pr)
  {
    if(this->IsPlayerValid(player))
    {
      this->Pos[phase][player].Priority = pr;
    }
  }
};
*/


class CPosition
{
public:
  struct TacPosition
  {
    CVector3 Position;
    bool is_position_set;
    int Priority;
  } Pos[MAX_PLAYERS_ON_FIELD]; 

  int  Versus;
  PositionOnField Main;

  CPosition();
  ~CPosition();

  bool Load(const char *file);

};


class CPhase
{
public:
  CVector3 BallTarget;
  PositionOnField HitMan;
  PositionOnField Area;
/*  struct {
    States mProposedNext;
    //bool WillBlock;
  } player[MAX_PLAYERS_ON_FIELD];*/
  int setup;  
  int type;
  bool is_target_set;
  bool is_hitman_set;

  CPhase();
  ~CPhase();

  bool Load(const char *filename);

//  void ResetPhase(void) { memset(this, 0, sizeof(CPhase)); };

  
};

class CTactic
{
  HPhase Phase[MAX_TACTIC_PHASES];
  int max_phases;

public:
  CTactic();
  ~CTactic();
  bool Load(const char *file);
  int GetMaxPhases(void) { return this->max_phases; }
  HPhase GetTacticPhase(int phase)
  {
    if(phase >= this->max_phases) return 0;
    return this->Phase[phase];
  }

};

#endif /* _TACTIC_H_ */
E:\Project\Kopia (5) VBEngine\Ai\TacticManager.cpp
#include "..\config.h"

#include <assert.h>
#include <string.h>

#include "..\Utility\Misc.h"
#include "..\Utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"

#include "..\utility\CTime.h"
#include "..\utility\logger.h"
#include "..\utility\tools.h"
#include "..\utility\conf.h"

#include "Tactic.h"
#include "TacticManager.h"

CTacticManager::CTacticManager() : EventHandler(ET_TACTIC)
{

  //this->current[TEAM_0] = 0;
  //this->current[TEAM_1] = 0;
  this->Main[TEAM_0] = POS_2; 
  this->Main[TEAM_1] = POS_2;

  this->Phases = NULL;
  this->max_phases = 0;
  this->Setup = NULL;
  this->max_setups = 0;
}

CTacticManager::~CTacticManager()
{
  if(this->Phases)
  {
    delete[] this->Phases;
  }
  if(this->Setup)
  {
    delete[] this->Setup;
  }
}

bool CTacticManager::IsPlayerValid(unsigned char player)
{
  switch(player)
  {
    case POS_0:
    case POS_1:
    case POS_2:          
    case POS_3:
    case POS_4:
    case POS_5:
      return true;
    default:
      return false;
  }
}


CVector3 * CTacticManager::GetBallTarget(HPhase phase)
{
  if(this->Phases[phase].is_target_set)
  {
    return &this->Phases[phase].BallTarget;
  }
  return NULL;
};


PositionOnField CTacticManager::GetHitMan(HPhase phase)
{
  return this->Phases[phase].HitMan;
};


bool CTacticManager::IsPositionValid(HPhase phase, unsigned int player)
{
  if(IsPlayerValid(player))
  {
    return this->Setup[this->Phases[phase].setup].Pos[player].is_position_set;
  }
  return false;
};

CVector3 * CTacticManager::GetPosition(HPhase phase, unsigned char player)
{
  int setup = this->Phases[phase].setup;
  if(IsPlayerValid(player) && this->Setup[setup].Pos[player].is_position_set)
  {
    return &this->Setup[setup].Pos[player].Position;
  }
  return NULL; 
};


int CTacticManager::GetPriority(HPhase phase, unsigned char player)
{
  if(IsPlayerValid(player))
  {
    return this->Setup[this->Phases[phase].setup].Pos[player].Priority;
  }
  return 12;
};

  
bool CTacticManager::IsTargetValid(HPhase phase)
{
  return this->Phases[phase].is_target_set;
};

bool CTacticManager::IsHitmanValid(HPhase phase)
{
  return this->Phases[phase].is_hitman_set;
}

bool CTacticManager::LoadPhases(const char *filename)
{
  ConfFile Config;
  char *str0, buffer[256];

  my_snprintf(buffer, 256, ".\\Data\\%s", filename);
  if (SUCCEEDED(Config.Init(buffer)))
  { 

    Config.GET_INT("PHASES_COUNT", &this->max_phases);

    if(!this->max_phases)
    {
      Config.DeInit();
      return false;
    }

    this->Phases = new CPhase[this->max_phases];

    for(int i = 0; i < this->max_phases; i++)
    {
      my_snprintf(buffer, 256,"PHASE_%d", i);
      if(((str0 = Config.GET_STR(buffer)) != NULL ))
      {
        this->Phases[i].Load(str0);
        free(str0);
      }
    }

    Config.DeInit();
    return true;
  }
  return false;
}


bool CTacticManager::LoadSetups(const char *filename)
{
  ConfFile Config;
  char *str0, buffer[256];

  my_snprintf(buffer, 256, ".\\Data\\%s", filename);
  if (SUCCEEDED(Config.Init(buffer)))
  { 

    Config.GET_INT("SETUP_COUNT", &this->max_setups);

    if(!this->max_setups)
      {
        Config.DeInit();
        return false;
      }

    this->Setup = new CPosition[this->max_setups];

    for(int i = 0; i < this->max_setups; i++)
    {
      my_snprintf(buffer, 256,"SETUP_%d", i);
      if(((str0 = Config.GET_STR(buffer)) != NULL ))
      {
        this->Setup[i].Load(str0);
        free(str0);
      }
    }

    Config.DeInit();
    return true;
  }
  return false;
}

short CTacticManager::GetAttackPhaseIndex(unsigned short team, PositionOnField pl)
{
  int i, count = 0;
  short ret = -1, *t = new short[this->max_phases];
  
  for(i = 0; i < this->max_phases; i++)
  {
    
    if ( this->Phases[i].type == 2
         && this->Phases[i].is_hitman_set
         && this->Phases[i].HitMan == pl
         && this->Setup[this->Phases[i].setup].Main == this->Main[team]
       )
    {
      t[count++] = i;
    }
  }

  if(count)
  {
    ret = t[0];
    if(count > 1)
    {
      ret = t[myrand(count - 1)];
    }
  }

  delete t;
  return ret;
}

short CTacticManager::GetPhaseIndexFromTarget(unsigned short team, unsigned short phase, CVector3 *target)
{
  if(target->y < 0) return -2;

  PositionOnField pos;

  int i, count = 0;
  short ret = -1, *t = new short[this->max_phases];

  if(target->y > 4.5f)
  {
    if(target->x > 1.5f)
    {
      pos = POS_0;
    }
    else
    {
      if(target->x < -1.5f)
      {
        pos = POS_2;
      }
      else
      {
        pos = POS_1;
      }
    }
  }
  else
  {
    if(target->x > 1.5f)
    {
      pos = POS_5;
    }
    else
    {
      if(target->x < -1.5f)
      {
        pos = POS_3;
      }
      else
      {
        pos = POS_4;
      }
    }
  }
    
  for(i = 0; i < this->max_phases; i++)
  {
    if ( this->Phases[i].type == phase
         && this->Phases[i].Area == pos
         && this->Setup[this->Phases[i].setup].Main == this->Main[team]
       )
    {
      t[count++] = i;
    }
  }

  if(count)
  {
    ret = t[0];
    if(count > 1)
    {
      ret = t[myrand(count - 1)];
    }
  }

  delete t;
  return ret;
}

short CTacticManager::GetPhaseIndex(unsigned short team, unsigned short phase)
{
//  if(target->y < 0) return -2;

//  PositionOnField pos;

  int i, count = 0;
  short ret = -1, *t = new short[this->max_phases];

  for(i = 0; i < this->max_phases; i++)
  {
    if ( this->Phases[i].type == phase
         && this->Setup[this->Phases[i].setup].Main == this->Main[team]
       )
    {
      t[count++] = i;
    }
  }

  if(count)
  {
    ret = t[0];
    if(count > 1)
    {
      ret = t[myrand(count - 1)];
    }
  }

  delete t;
  return ret;
}

void CTacticManager::ProcessEvent(Event *event)
{
  int team = 0;
  /* switch(event->mID)
  {
   case VBKEY_1: current[team] = 1; break;
    case VBKEY_2: current[team] = 2; break;
    case VBKEY_3: current[team] = 3; break;
    case VBKEY_4: current[team] = 4; break;
    case VBKEY_5: current[team] = 5; break;
    case VBKEY_6: current[team] = 6; break;
    case VBKEY_7: current[team] = 7; break;
    case VBKEY_8: current[team] = 8; break;
    case VBKEY_9: current[team] = 9; break;
    case VBKEY_0: current[team] = 0; break;
    default: */LogCritical("ERROR : Change Tactic to %d", event->mID); return;
/*  }
//  LogCritical("Change Tactic to %d", current);
   prowizorka */
  POST_EVENT(ET_GAME, GE_TEAM0_CHANGE_TACTIC , false, NULL);

}
E:\Project\Kopia (5) VBEngine\Ai\TacticManager.h
#ifndef _TACTICMANAGER_H_
#define _TACTICMANAGER_H_

/*
class       :
description :

methods     :

*/

class CPhase;
class CPosition;

class CTacticManager : public EventHandler, public Singleton<CTacticManager>
{
 
  CPhase *Phases;
  int max_phases;

  CPosition *Setup;
  int max_setups;

  //int current[MAX_TEAM];
  PositionOnField Main[MAX_TEAM];
  
public:
  CTacticManager();
  ~CTacticManager();

  bool IsPlayerValid(unsigned char player);


  void SetMain(unsigned int team, PositionOnField pos)
  {
    this->Main[team] = pos;
  }

  bool IsPositionValid(HPhase phase, unsigned int player);
  bool IsTargetValid(HPhase phase);
  bool IsHitmanValid(HPhase phase);

  CVector3 *GetPosition(HPhase phase, unsigned char player);
  int GetPriority(HPhase phase, unsigned char player);
  CVector3 *GetBallTarget(HPhase phase);
  PositionOnField GetHitMan(HPhase phase);

  short GetPhaseIndexFromTarget(unsigned short team, unsigned short phase, CVector3 *target);
  short GetPhaseIndex(unsigned short team, unsigned short phase);
  short GetAttackPhaseIndex(unsigned short team, PositionOnField pl);

  bool LoadPhases(const char *filename);
  bool LoadSetups(const char *filename);
  void ProcessEvent(Event *event);
};

#endif /*  _TACTICMANAGER_H_ */
E:\Project\Kopia (5) VBEngine\Audio\Audio.cpp
#include "..\config.h"

#include <windows.h>
#include <mmsystem.h> /* for wav input / output / timeGetTime() functions  */
#include <string.h> /* for config reading */
#include <assert.h>

#include <d3d9.h>
#include <dsound.h>
//#include "dmusici.h" /* trying to throw out this dx shit */

#include "..\utility\Singleton.h"
#include "..\utility\defines.h"

#include "..\graphics\renderer.h"

/* useful enums */
#include "AudioError.h"

#include "Audio.h"

/* ---------------------------------------------------------------------- */

CAudio::CAudio()
{
  p_DirectSound = NULL;
  this->is_init = false;
} /* end of: constructor */

CAudio::CAudio( int Channels, int Frequency, int BitRate )
{
  p_DirectSound = NULL;
  this->is_init = false;
  /* fire up direct shit sound */
  InitDirectSound( Channels, Frequency, BitRate );

} /* end of: constructor */

/* ---------------------------------------------------------------------- */

CAudio::~CAudio()
{
    
} /* end of: destructor */

/* ---------------------------------------------------------------------- */

struct IDirectSound8 * CAudio::GetSoundDevice(void)
{
  return this->p_DirectSound;
};

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudio::InitDirectSound( int Channels, int Frequency, int BitRate )
	{
		HRESULT hr = DS_OK;

		/* if direct sound NOT initialized yet, start it up */
		if( NULL == p_DirectSound )
			{
				/* create direct shit sound */
			  hr = DirectSoundCreate8( NULL /* default sound device */, &p_DirectSound,
					                       NULL /* COM aggregation not supported */ );
				if( hr ) /* in case of error */

					{
					  return DSOUND_INIT_ERROR;
					}

				/* set cooperative level of application with sound device */
				/* we can set format of primary buffer */
				hr = p_DirectSound->SetCooperativeLevel( Renderer::Instance()->GetWindowHandle(), DSSCL_PRIORITY );

				if( hr ) /* in case of error */
					{
					  return DSOUND_COOPERATIVE_ERROR;
					}

        DWORD Flags = 0;
        Flags |= DSBCAPS_PRIMARYBUFFER | DSBCAPS_CTRL3D;
				/* P -> primary, canot be LPDIRECTSOUNDBUFFER8 ( 8 ) */
				LPDIRECTSOUNDBUFFER p_DSPBuffer = NULL ;
				DSBUFFERDESC dsbd;
				ZeroMemory( &dsbd, sizeof( DSBUFFERDESC ) );
				dsbd.dwSize        = sizeof( DSBUFFERDESC );
				dsbd.dwFlags       = Flags; /* create primary buffer with 3D control */
				
				/* create primary sound buffer */
				hr = p_DirectSound->CreateSoundBuffer( &dsbd, &p_DSPBuffer, NULL );

				if( hr ) /* in case of error */
					{
					  return DSOUND_PRIMARY_BUFFER_NOT_CREATED;
					}
				else /* now we can safely set buffer format which was passed as args to this function */
					{
						WAVEFORMATEX wfx;
						ZeroMemory( &wfx, sizeof( WAVEFORMATEX ) ); 
						wfx.wFormatTag      = ( WORD )		WAVE_FORMAT_PCM; 
						wfx.nChannels       = ( WORD )		Channels; 
						wfx.nSamplesPerSec  = ( DWORD )		Frequency; 
						wfx.wBitsPerSample  = ( WORD )		BitRate;
						wfx.nBlockAlign     = ( WORD )	( wfx.wBitsPerSample / 8 * wfx.nChannels );
						wfx.nAvgBytesPerSec = ( DWORD )	( wfx.nSamplesPerSec * wfx.nBlockAlign );

						hr = p_DSPBuffer->SetFormat( &wfx );
						if( hr ) /* in case of error */
						{
							RELEASE( p_DSPBuffer );
							return DSOUND_PRIMARY_BUFFER_SET_FORMAT_FAILED;
						}
						
						/* primary buffer is now set so we can release it */
					  RELEASE( p_DSPBuffer );
					} /* end of: else ( set primary buffer format ) */

			} /* end of: if direct sound NOT initialized yet, start it up */

    this->is_init = true;
		return AUDIO_OK;
	} /* end of: InitDirectSound() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudio::DeInitDirectSound( void )
	{
	  /* make sure dsound WAS initialized */
		if( NULL != p_DirectSound )
			{
				RELEASE( p_DirectSound );
        this->is_init = false;
				return AUDIO_OK;
			}

		return DSOUND_IS_NULL;
	} /* end of: DeInitDirectSound() */

/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\Audio.h
#ifndef _AUDIO_H_

#define _AUDIO_H_

/* useful enums */
#include "AudioError.h"

/* ---------------------------------------------------------------------- */
struct IDirectSound8;

class CAudio : public Singleton<CAudio>
{
    /* members variables */
		struct IDirectSound8 *p_DirectSound;
    bool is_init;
	public:
    
    struct IDirectSound8 * GetSoundDevice(void);

		/* constructor initializes direct shit sound */
    /* HWnd taken from most top desktop window   */
		CAudio();
    CAudio( int Channels, int Frequency, int BitRate );

    /* destructor unloads oggs and waves from memory */
    /* and deinitializes direct shit sound           */
		~CAudio();

		/* this initializes direct shit sound for use */
		AUDIO_ERROR InitDirectSound( int Channels, int Frequency, int BitRate );

		/* and this frees direct shit sound */
		AUDIO_ERROR DeInitDirectSound( void );

    bool IsInit(void) {return this->is_init;}

} /* MUST BE */; /* end of: CAudio() */

/* ---------------------------------------------------------------------- */
#endif /* _AUDIO_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\AudioError.h
#ifndef _AUDIO_ERROR_H_
#define _AUDIO_ERROR_H_

/* ---------------------------------------------------------------------- */

/* megagine audio enum this values are returned by functions */
enum AUDIO_ERROR
	{
		AUDIO_OK = 0, AUDIO_FAILED, DSOUND_INIT_ERROR, DSOUND_IS_NULL,
		DSOUND_COOPERATIVE_ERROR, DSOUND_PRIMARY_BUFFER_NOT_CREATED,
		DSOUND_PRIMARY_BUFFER_SET_FORMAT_FAILED, AUDIO_OPEN_CONFIG_FAILED,
    AUDIO_CONFIG_VALUE_NOT_FOUND, AUDIO_SETPOS_FAILED, AUDIO_NOT_WAVE_ID
	}; /* after enum must be semicolon, but this should be obvious to you */

/* ---------------------------------------------------------------------- */

/* useful defs */
enum STD_DEFS { OFF = 0, ON, NO = 0, YES, DONT_LOOP = 0, DO_LOOP };

/* ---------------------------------------------------------------------- */

/* ogg specific */
enum OGG_ERROR
	{ 
		OGG_OK = 0, OGG_DSOUND_NULL, OGG_OPEN_FILE_FAILED,
		OGG_OPEN_OGG_FAILED, OGG_PLAY_ERROR, OGG_NOT_PLAYING,
		OGG_CANNOT_UPDATE
	};

/* ---------------------------------------------------------------------- */

/* wav ( RIFF ) specific */
enum WAV_ERROR
{
  WAV_OK = 0, WAV_DSOUND_NULL, WAV_OPEN_FILE_FAILED,
  WAV_NO_RIFF_FILE, WAV_NO_WAVE_FILE, WAV_BAD_FORMAT_TAG,
  WAV_BAD_DATA_TAG, WAV_UNSUPPORTED_FORMAT, WAV_CREATE_BUFFER_FAILED,
  WAV_PLAY_ERROR, WAV_LOCK_BUFFER_FAILED, WAV_UNLOCK_BUFFER_FAILED,
  WAV_PLAY_FAILED, WAV_BUFFER_IS_NULL, WAV_NOT_PLAYING,
  WAV_NOT_MONO, WAV_QUERY_3D_ITERFACE_FAILED
};

/* ---------------------------------------------------------------------- */

#ifndef RELEASE
  #define RELEASE(p) { if(p) { (p)->Release(); (p)=NULL; } }
#endif

/* ---------------------------------------------------------------------- */
#endif /* _AUDIO_ERROR_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\AudioID.h
#ifndef _AUDIO_ID_H_
#define _AUDIO_ID_H_

/* ---------------------------------------------------------------------- */

/* music and sound ID should be renamed more accurately when they will be available */
enum AUDIO_ID
{
  MUSIC_0 = 0, MUSIC_1, MUSIC_2, MUSIC_3, MUSIC_4,
  WAV_0, WAV_1, WAV_2, WAV_3, WAV_4, WAV_5, WAV_6, WAV_7, WAV_8, WAV_9,
  WAV_10, WAV_11, WAV_12, WAV_13, WAV_14, WAV_15, WAV_16, WAV_17, WAV_18,
  WAV_19, WAV_21, WAV_22, WAV_23, WAV_24, WAV_25, WAV_26, WAV_27, WAV_28,
  WAV_29
};

/* ---------------------------------------------------------------------- */
#endif /* _AUDIO_ID_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\AudioManager.cpp
#include "..\config.h"

#include <windows.h>

#include <mmsystem.h> /* for wav input / output / timeGetTime() functions  */
#include <string.h> /* for config reading */
#include <assert.h> /* for singeltons */

#include <dsound.h>
//#include "dmusici.h" /* trying to throw out this dx shit */

#include    <vorbis/codec.h>
#include    <vorbis/vorbisfile.h>

#include "..\utility\misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\Tools.h"
#include "..\utility\VBmath.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"

#include "..\core\SetupManager.h"

/* useful enums */
#include "AudioError.h"

#include "COgg.h"
#include "CWav.h"

#include "Audio.h"
#include "AudioManager.h"

/* ---------------------------------------------------------------------- */

CAudioManager::CAudioManager() : EventHandler(ET_AUDIO)
{
  is_init = false;
  CurrentOGG = LAST_AUDIO;
  m_Waves = new CWav[ MAX_WAVES ];
	m_Oggs  = new COgg[ MAX_OGGS ];
  this->mTrackPlaying = 0;
} /* end of: constructor */

/* ---------------------------------------------------------------------- */

CAudioManager::~CAudioManager()
{
  //DeInit();
  delete[] m_Waves;
  delete[] m_Oggs;
} /* end of: destructor */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::GetCfgPath( char *Tag, char *Path , int size )
{
  char Line[ 256 ];

  my_snprintf(Line, 256, "Audio.cfg" );
  

  /* open config file */
  FILE *f = fopen( Line , "rt" );
  if( NULL == f )
  {
    return AUDIO_OPEN_CONFIG_FAILED;
  }

  /* scan lines for specific tag */
  

  while( !feof( f ) )
  {
    fscanf( f, "%s\n", Line );

    /* tag is matching what we have, read and copy data to Path */
    if( strcmp( Tag, Line ) == 0 )
    {
      /* read '=' and path data strings */
      fscanf( f, "%s\n", Line );
      fscanf( f, "%s\n", Line );
      my_snprintf(Path, size, "%s", Line);
      fclose( f );
      return AUDIO_OK;
    }

  } /* end of: while( !eof( f ) ) */

  fclose( f );
  return AUDIO_CONFIG_VALUE_NOT_FOUND;
}

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::Init() /* load into RAM by default */
{
  if(!CAudio::Instance()->IsInit()) return AUDIO_FAILED;

  is_init = true;
  /* read paths from config file */
  GetCfgPath( "MUSIC_PATH0", m_MusicPath[ 0 ], MAX_FILE_NAME );
  GetCfgPath( "MUSIC_PATH1", m_MusicPath[ 1 ], MAX_FILE_NAME );
  GetCfgPath( "MUSIC_PATH2", m_MusicPath[ 2 ], MAX_FILE_NAME );
  GetCfgPath( "MUSIC_PATH3", m_MusicPath[ 3 ], MAX_FILE_NAME );
  GetCfgPath( "MUSIC_PATH4", m_MusicPath[ 4 ], MAX_FILE_NAME );

  /* read paths from config file */
  GetCfgPath( "EFFECT_PATH0", m_MusicPath[ 5 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH1", m_MusicPath[ 6 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH2", m_MusicPath[ 7 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH3", m_MusicPath[ 8 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH4", m_MusicPath[ 9 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH5", m_MusicPath[ 10 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH6", m_MusicPath[ 11 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH7", m_MusicPath[ 12 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH8", m_MusicPath[ 13 ], MAX_FILE_NAME );
  GetCfgPath( "EFFECT_PATH9", m_MusicPath[ 14 ], MAX_FILE_NAME );

  /* these are availibale for now */
  GetCfgPath( "WAV_PATH0", m_WavePath[ 0 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH1", m_WavePath[ 1 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH2", m_WavePath[ 2 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH3", m_WavePath[ 3 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH4", m_WavePath[ 4 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH5", m_WavePath[ 5 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH6", m_WavePath[ 6 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH7", m_WavePath[ 7 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH8", m_WavePath[ 8 ] , MAX_FILE_NAME);
  GetCfgPath( "WAV_PATH9", m_WavePath[ 9 ] , MAX_FILE_NAME);

  /* load all .oggs into RAM by default */
  m_Oggs[ 0 ].Load( m_MusicPath[ 0 ] );
  m_Oggs[ 1 ].Load( m_MusicPath[ 1 ] );
  m_Oggs[ 2 ].Load( m_MusicPath[ 2 ] );
  m_Oggs[ 3 ].Load( m_MusicPath[ 3 ] );
  m_Oggs[ 4 ].Load( m_MusicPath[ 4 ] );

  m_Oggs[ 5 ].Load( m_MusicPath[ 5 ] );
  m_Oggs[ 6 ].Load( m_MusicPath[ 6 ] );
  m_Oggs[ 7 ].Load( m_MusicPath[ 7 ] );
  m_Oggs[ 8 ].Load( m_MusicPath[ 8 ] );
  m_Oggs[ 9 ].Load( m_MusicPath[ 9 ] );
  m_Oggs[ 10 ].Load( m_MusicPath[ 9 ] );
  m_Oggs[ 11 ].Load( m_MusicPath[ 9 ] );
  m_Oggs[ 12 ].Load( m_MusicPath[ 9 ] );
  m_Oggs[ 13 ].Load( m_MusicPath[ 13 ] );

  /* load all waves into memory by default */
  m_Waves[ 0 ].Load( m_WavePath[ 0 ] );
  m_Waves[ 1 ].Load( m_WavePath[ 1 ] );
  m_Waves[ 2 ].Load( m_WavePath[ 2 ] );
  m_Waves[ 3 ].Load( m_WavePath[ 3 ] );
  m_Waves[ 4 ].Load( m_WavePath[ 4 ] );
  m_Waves[ 5 ].Load( m_WavePath[ 5 ] );

  //m_Waves[ 6 ].Load( m_WavePath[ 6 ] );
  //m_Waves[ 7 ].Load( m_WavePath[ 7 ] );
  //m_Waves[ 8 ].Load( m_WavePath[ 8 ] );
  //m_Waves[ 9 ].Load( m_WavePath[ 9 ] );

  //mciSendString("open cdaudio
  return AUDIO_OK;
}

/* ---------------------------------------------------------------------- */

void CAudioManager::DeInit()
{
  if(!is_init) return;
  for( int i = 0; i < MAX_OGGS; i++ ) /* unload oggs from mem */
  {
    this->m_Oggs[ i ].Close();
  }


  for( i = 0; i < MAX_WAVES; i++ ) /* unload waves from mem */
  {
    this->m_Waves[ i ].Close();
  }
  is_init = false;
} /* end of: destructor */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::Play( AUDIO_ID AudioID )
	{
    if( AudioID > EFFECT_14 )
    {
      /* because WAV_0 is not zero */
      ResetPos( AudioID );
     // m_Waves[ AudioID - WAV_0 ].SetVolume( 100 );
      m_Waves[ AudioID - WAV_0 ].Play( DONT_LOOP );
    }
    else
    {
      if( AudioID > MUSIC_4 )
      {
        m_Oggs[ AudioID ].Play( DONT_LOOP );
      }
      else
      {
       m_Oggs[ AudioID ].Play( DO_LOOP );
      }
    }

		return AUDIO_OK;
	} /* end of: PlaySound() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::Pause( AUDIO_ID AudioID )
{
  if( AudioID > EFFECT_14 )
  {
    /* because WAV_0 is not zero */
    m_Waves[ AudioID - WAV_0 ].Pause();
  }
  else
  {
    m_Oggs[ AudioID ].Pause();
  }

  return AUDIO_OK;
} /* end of: Pause() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::Stop( AUDIO_ID AudioID )
	{
    if( AudioID > EFFECT_14 )

    {
      /* because WAV_0 is not zero */
      m_Waves[ AudioID - WAV_0 ].Stop();
    }
    else
    {
      CurrentOGG = LAST_AUDIO;
      m_Oggs[ AudioID ].Stop();
    }
		return AUDIO_OK;
	} /* end of: Stop() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::ResetVolume() /* all audios at max volume */
	{
    for( int i = MUSIC_0; i < LAST_AUDIO; i++ )
    {
      SetVolume( 100, ( AUDIO_ID ) i );
    }

		return AUDIO_OK;
	} /* end of: ResetVolume() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::SetVolume( int Percent, AUDIO_ID AudioID )
	{
    if( AudioID > EFFECT_14 )
    {
      /* because WAV_0 is not zero */
       m_Waves[ AudioID - WAV_0 ].SetVolume( Percent );
    }
    else
    {
      m_Oggs[ AudioID ].SetVolume( Percent );
    } /* end of: else */

		return AUDIO_OK;
	} /* end of: SetSoundVolume() */

bool CAudioManager::IsPlaing( AUDIO_ID AudioID )
{
  if( AudioID > EFFECT_14 )
  {
    /* because WAV_0 is not zero */
    return (m_Waves[ AudioID - WAV_0 ].m_Playing == YES);
  }
  else
  {
    return (m_Oggs[ AudioID ].m_Playing == YES);
  } /* end of: else */  
}

AUDIO_ERROR CAudioManager::SetVolume( int Percent, bool waves )
{
  if( waves )
  {
    for( int i = 0; i < MAX_WAVES; i++ )
    {
        m_Waves[ i ].SetVolume( Percent );
    }
  } /* end of: for */
  else
  {
    /* hack */
    for( int i = (int)EFFECT_0; i < MAX_OGGS; i++ )
    {
        m_Oggs[ i ].SetVolume( Percent );
    }
  } /* end of: else */

  return AUDIO_OK;
} /* end of: SetSoundVolume() */

bool CAudioManager::SetCDVolume( int Percent )
{
  for( int i = 0; i < (int)EFFECT_0; i++ )
  {
    m_Oggs[ i ].SetVolume( Percent );
  }
  return true;
}

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::SetPos( float x, float y, float z, AUDIO_ID SoundID )
{
  if( SoundID < WAV_0 ) /* this applies only to waves not oggs */
  {
    return AUDIO_NOT_WAVE_ID;
  }

  if( NULL == m_Waves[ SoundID ].p_DS3DB ) /* can we do that ? */
  {
    return AUDIO_SETPOS_FAILED;
  }

  m_Waves[ SoundID ].p_DS3DB->SetPosition( x, y, z, DS3D_IMMEDIATE );
  return AUDIO_OK;
} /* end of: SetSoundPos() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::ResetPos( AUDIO_ID SoundID )
{

  if( SoundID < WAV_0 ) /* this applies only to waves not oggs */
  {
    return AUDIO_NOT_WAVE_ID;
  }
      
  /* cause  WAV_0 is not zero */
  SoundID = ( AUDIO_ID ) ( SoundID - WAV_0 );

  if( NULL == m_Waves[ SoundID ].p_DS3DB ) /* can we do that ? */
  {
    return AUDIO_SETPOS_FAILED;
  }

  m_Waves[ SoundID ].p_DS3DB->SetPosition( 0.0f, 0.0f, 0.0f, DS3D_IMMEDIATE );
  return AUDIO_OK;
} /* end of: ResetSoundPos() */

/* ---------------------------------------------------------------------- */

AUDIO_ERROR CAudioManager::Update()
{
  for( int i = 0; i < MAX_OGGS; i++ )
  {
    m_Oggs[ i ].Update();
  }

  return AUDIO_OK;
}

/* ---------------------------------------------------------------------- */

void CAudioManager::ProcessEvent(Event *event)
{
  if(!is_init) return;

  enum AUDIO_ID AudioID = (AUDIO_ID)event->mID;

  if(AudioID >= LAST_AUDIO)
  {
    int i;
    for( i = 0; i < MAX_WAVES; i++ )
    {
      m_Waves[ i ].Stop();
    }
    for( i = 0; i < MAX_OGGS; i++ )
    {
      m_Oggs[ i ].Stop();
    }
    return;
  }

  if(AudioID == MUSIC_1)
  {
    if(event->mID2)
    {
      if (m_Oggs[ MUSIC_1 ].m_Playing == NO && SetupManager::Instance()->GetSound()->menu)
      {
        m_Oggs[ MUSIC_1 ].Play(DO_LOOP);
      }
    }
    else
    {
      if (m_Oggs[ MUSIC_1 ].m_Playing == YES)
  {
    m_Oggs[ MUSIC_1 ].Stop();
      }
    }
    return;
  }
  if(AudioID == MUSIC_0)
  {
    if(event->mID2)
    {
      if (m_Oggs[ MUSIC_0 ].m_Playing == NO && SetupManager::Instance()->GetSound()->peoples)
      {
        m_Oggs[ MUSIC_0 ].Play(DO_LOOP);
      }
    }
    else
    {
      if (m_Oggs[ MUSIC_0 ].m_Playing == YES)
      {
        m_Oggs[ MUSIC_0 ].Stop();
      }
    }
    return;
  }
  if((AudioID > MUSIC_1) && (AudioID <= MUSIC_4) && CurrentOGG != AudioID)
  {
    if(CurrentOGG != LAST_AUDIO)
    {
      m_Oggs[ CurrentOGG ].Stop();
    }
    CurrentOGG = AudioID;
  }
  if (AudioID < LAST_AUDIO)
  {
    this->Play(AudioID);
    if(event->mID2)
    {
      SetVolume( event->mID2, AudioID );
    }
    if (event->mData)
    {
      CVector3 *pos = (CVector3 *)event->mData;
      SetPos( pos->x, pos->y, pos->z, AudioID );
    }
  }
}

/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\AudioManager.h
#ifndef _AUDIOMANAGER_H_
#define _AUDIOMANAGER_H_

/* ---------------------------------------------------------------------- */
/* main ( parent ) class for megagine audio     */
/* adaœ: pamashoid@onet.pl                      */

/* structure:                                   */
/*               Audio                          */
/*              |     |                         */
/*            COgg   CWav                       */

/* COgg -> ogg vorbis playing class for dsound  */
/* CWav -> wav playing class with DS 3D sound   */

/* programming note:                            */
/*                  - all functions returns int */
/*                    ( exept of constructor,   */
/*                      and destructor )        */
/*                    see included AudioError.h */
/*                  - variables are public      */

/* ---------------------------------------------------------------------- */

/* maximum number of available sounds ( .wav ) and musics ( .oggs ) */
#define MAX_WAVES											30
#define MAX_OGGS											20

/* loop background music by default ? */
#define DEFAULT_AUDIO_MUSIC_LOOPING		YES

/* loop sound effects by default ?    */
#define DEFAULT_AUDIO_WAVE_LOOPING		NO

/* useful enums */
#include "AudioError.h"

/* ---------------------------------------------------------------------- */
class COgg;
class CWav;

class CAudioManager : public Singleton<CAudioManager> ,EventHandler
	{
    /* paths to musics and waves readed from external config file ( Audio.cfg ) */
    char m_MusicPath[ MAX_OGGS ][ MAX_FILE_NAME ];
    char m_WavePath[ MAX_WAVES ][ MAX_FILE_NAME ];
    CWav *m_Waves;
		COgg *m_Oggs;
    enum AUDIO_ID CurrentOGG;
    bool is_init;
    unsigned char mTrackPlaying;
	public:

    void ProcessEvent(Event *event);

		/* constructor initializes direct shit sound */
    /* HWnd taken from most top desktop window   */
		CAudioManager();

    /* destructor unloads oggs and waves from memory */
    /* and deinitializes direct shit sound           */
		~CAudioManager();

    /* get path by 'Tag' from 'Audio.cfg' file and copy this to 'Path' */
    AUDIO_ERROR GetCfgPath( char *Tag, char *Path , int size);

    /* init musics / waves classes  */
    /* load into memory by default  */
    /* executed at cinstructor time */
    AUDIO_ERROR Init();
    void DeInit();

		/* playing / pausing / stopping functions */
		AUDIO_ERROR Play( AUDIO_ID AudioID );
    AUDIO_ERROR Pause( AUDIO_ID AudioID );
		AUDIO_ERROR Stop( AUDIO_ID AudioID );

    bool IsPlaing( AUDIO_ID AudioID );
    bool IsInit(void) {return this->is_init;};

		/* volume controls */
		AUDIO_ERROR SetVolume( int Percent, AUDIO_ID AudioID );
    AUDIO_ERROR SetVolume( int Percent, bool waves );
		AUDIO_ERROR ResetVolume( void );

		/* 3D position controls */
		AUDIO_ERROR SetPos( float x, float y, float z, AUDIO_ID SoundID );
		AUDIO_ERROR ResetPos( AUDIO_ID SoundID );

    /* this must be called to update oggs streaming buffers */
    AUDIO_ERROR Update();

    bool PlayCDTrack(unsigned char track_number);
    bool SetCDVolume( int Percent );

	} /* MUST BE */; /* end of: CAudioManager() */

/* ---------------------------------------------------------------------- */
#endif /* _AUDIOMANAGER_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\COgg.cpp

#include "..\config.h"

#include    <windows.h>
#include    <mmreg.h>
#include    <assert.h>

#include    <dsound.h>
#include    <vorbis/codec.h>
#include    <vorbis/vorbisfile.h>

#include "..\utility\Singleton.h"
#include "..\utility\defines.h"

/* enums to return function codes for entire project */
#include "AudioError.h"

#include "Audio.h"

#include "COgg.h"

/* ---------------------------------------------------------------------- */

COgg::COgg()
{
	m_FileOpened = NO;
  m_Playing    = NO;
	/* m_DataDone	 = NO; moved to Load() */
	m_Loop			 = YES;
	m_Paused		 = NO;
	p_DSB				 = NULL;
  mVolume = 100;
} /* end of: constructor */

/* ---------------------------------------------------------------------- */

COgg::~COgg()
	{
	} /* end of: destructor */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Load( const char *FileName )
	{
    LPDIRECTSOUND8 pDS = CAudio::Instance()->GetSoundDevice();

	  /* make sure direct shit sound is already initialized ( CMegaGineAudio ) */
	  if( NULL == pDS )
		{
			return OGG_DSOUND_NULL;
		}
		
		HRESULT hr = AUDIO_OK;

		/* if file already opened we force it to close */
		if( YES == m_FileOpened )
			{
				hr = this->Close();
			}

    /* now we open file */
		FILE *f = fopen( FileName, "rb" );

		if( NULL == f )
			{
				return OGG_OPEN_FILE_FAILED;
			}

		hr = ov_open( f, &( this->m_vf ), NULL, 0 );
			if( hr )
				{
				 fclose( f );
					return OGG_OPEN_OGG_FAILED;
			  }

		/* the vorbis_info struct keeps the most of the interesting format info */
		vorbis_info *vi = ov_info( &m_vf, -1 );

		/* set the wave format audio data */
		WAVEFORMATEX  wfm;
	  ZeroMemory( &wfm, sizeof( wfm ) );

    wfm.cbSize          = sizeof( wfm );
    wfm.nChannels       = vi->channels;
    wfm.wBitsPerSample  = 16;                    /* ogg vorbis is always 16 bit */
    wfm.nSamplesPerSec  = vi->rate;
    wfm.nAvgBytesPerSec = wfm.nSamplesPerSec * wfm.nChannels * 2;
    wfm.nBlockAlign     = 2 * wfm.nChannels;
    wfm.wFormatTag      = 1;

	  /* set up the buffer */
	  DSBUFFERDESC desc;

		desc.dwSize         = sizeof( desc );
    /* global focus makes us to be heard even when another window is active */
		desc.dwFlags        = DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS;
		desc.lpwfxFormat    = &wfm; /* NULL for primary buffers ONLY! */
		desc.dwReserved     = 0;

		/* must be beetween DSBSIZE_MIN and MAX set in dsound.h */
		desc.dwBufferBytes  = BUFSIZE * 2;

		/* CreateSoundBuffer( struct DSBUFFERDESC, &pDSObject, must be NULL ); */
    hr = pDS->CreateSoundBuffer( &desc, &p_DSB, NULL );

		if( hr ) /* in case of error */
		{
			ov_clear( &( this->m_vf ) );
			return ( OGG_ERROR ) hr;
		}
  
    m_Playing = NO;
	  m_FileOpened = YES;
    return OGG_OK;
	} /* end of Load() */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Close()
	{
		if( this->m_Playing ) /* if buffer is playing we must to stop it first */
		{
			this->p_DSB->Stop();
		}

		if( this->m_FileOpened ) /* if file was opened clear .ogg ( we MUST ) */
			{
				ov_clear( &( this->m_vf ) );
				this->m_FileOpened = NO;
			}
   
		if( this->p_DSB ) /* free buffer ( secondary ) for this ogg */
		{
			this->p_DSB->Release();
		}

		return OGG_OK;
	} /* end of: Close() */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Play( STD_DEFS Loop ) /* default Loop is NO */
	{
		HRESULT hr;

		/* can we do that ? */
		if( ( NO == m_FileOpened ) || ( NULL == p_DSB ) )
		{
			return OGG_PLAY_ERROR;
		}

		/* fill the buffer with data */
		DWORD   pos = 0;
		int     sec = 0;
		int     ret = 1;
		DWORD   size = BUFSIZE * 2;
		char    *buf;
    
		m_DataDone = NO;
    p_DSB->Stop();

		/* fill the buffer with initial data               */
		/* entire buffer        prarameter size IS ignired */
	  if( SUCCEEDED( hr = p_DSB->Lock( 0, size, ( LPVOID * ) &buf, &size, NULL, NULL,
			                               DSBLOCK_ENTIREBUFFER ) ) )
			{ 
				/* avoid 'white noise' when file size is smaller than BUFSIZE */
        ov_pcm_seek( &this->m_vf, 0 );

				/* now read in the bits */
				while( ret && pos < size )
				{
					ret = ov_read( &this->m_vf, ( buf + pos ), ( size - pos ), 0, 2, 1, &sec );
					pos += ret;
				}

				/* reached the and? */
				if( !ret && ( YES == m_Loop ) ) /* default is YES */
				{
					/* we are looping so restart from the beginning               */
					/* NOTE: sound with sizes smaller than BUFSIZE may be cut off */
		      ret = 1;
				  ov_pcm_seek( &m_vf, 0 );
					while( ret && pos < size )
					{
						ret = ov_read( &m_vf, ( buf + pos ), ( size - pos ), 0, 2, 1, &sec );
						pos += ret;
					}

				} /* end of: if( !ret && ( YES == Loop ) ) */
				else
				{
					if( !ret && ( m_Loop == NO ) )
					{
						/* not looping so fill the rest with 0 */
						while( pos < size )
						{
							*( buf + pos ) = 0;
							pos++;
						}

						/* and say that after the current section no other section follows */
						m_DataDone = YES;

					} /* end of: if( !ret && ( Loop == NO ) ) */

				} /* end of: else */

				p_DSB->SetCurrentPosition( 0 );
				p_DSB->Unlock( buf, size, NULL, NULL );
				m_Section = m_LastSection = 0;
    
			} /* end of: if ( SUCCEEDED( hr = pDSB->Lock() )*/
		else
			{
				return ( OGG_ERROR ) hr; /* avoid warnings */
			}

		/* play buffer looping because we will fill the buffer */
		if ( FAILED( hr = p_DSB->Play( 0, 0, DSBPLAY_LOOPING ) ) )
		{
			return ( OGG_ERROR ) hr; /* avoid warnings */
		}

		m_Playing = YES;
		m_Loop = Loop;
		return OGG_OK;
	} /* end of: Play() */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Pause() /* pause / resume playing */
	{
	  /* we pause it only if it is playing */
		if( !m_Playing )
			{
				return OGG_NOT_PLAYING;
			}

		if( m_Paused ) /* if paused resume playing */
			{
				p_DSB->Play( 0, 0, DSBPLAY_LOOPING );
				m_Paused = NO;
			}
		else
			{
				p_DSB->Stop();
        m_Paused = YES;
			} /* end of: if( m_Paused ) */

		return OGG_OK;
	} /* end of: Pause() */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Stop()
	{
		if (p_DSB) p_DSB->Stop();
    m_Playing = NO;
		return OGG_OK;
	} /* end of: Stop() */

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::SetVolume( int Percent ) /* default is volume max */
	{
    
		if( ( Percent < 0 ) || ( Percent > 100 ) )
			{
				/* if invalid range sound is heared with maximum volume */
				Percent = 100;
			}
    this->mVolume = Percent;
		if( m_FileOpened && ( NULL != p_DSB ) ) /* can we do it? */
			{
				p_DSB->SetVolume( -10000 + ( 100 * Percent ) );
			}

		return OGG_OK;
	}

/* ---------------------------------------------------------------------- */

OGG_ERROR COgg::Update() /* must be called frequently ( suggested timers ) */
	{
	 	if( !m_FileOpened || ( NULL == p_DSB ) ) /* can we do it? */
		{
		  return OGG_CANNOT_UPDATE;
		}

		DWORD pos;
    HRESULT hr;

		/* obtain current buffer position */
    p_DSB->GetCurrentPosition( &pos, NULL );

		/* wchich part of the buffer it is */
		/* buffer has two parts            */
		m_Section = ( pos < BUFSIZE ? 0 : 1 );

    /* if section changed we fill previous section ( not currently playied ) */
		/* with new .ogg sound data                                              */
		if( m_Section != m_LastSection )
			{

				/* otherwise there wont be played all bits */
				if( YES == m_DataDone )
				{
					this->Stop();
				}

			DWORD   size = BUFSIZE;
			char    *buf = NULL;

			/* fill the section we just left */
      if( SUCCEEDED( hr = p_DSB->Lock( ( m_LastSection * BUFSIZE ), size, ( LPVOID * ) &buf, &size,
				                                 NULL, NULL, 0 ) ) )
				{

					int     sec = 0;
					int     ret = 1;

					pos = 0;
					while( ret && pos < size )
						{

							ret = ov_read( &m_vf, ( buf + pos ), ( size - pos ), 0, 2, 1, &sec );
							pos += ret;
						}
    
					/* reached the end? */
          if( !ret && ( YES == m_Loop ) )
						{
              DWORD pos_tmp = pos;

							/* we are looping so restart from the beginning               */
							/* NOTE: sound with sizes smaller than BUFSIZE may be cut off */
							ret = 1;
							ov_pcm_seek( &m_vf, 0 );

             	/* fill the rest with 0 */
							while( pos_tmp < size )
              {
								*( buf + pos_tmp ) = 0;
							  pos_tmp++;
							}

							while( ret && pos < size )
							{
								ret = ov_read( &m_vf, ( buf + pos ), ( size - pos ), 0, 2, 1, &sec );
								pos += ret;
							}

						} /* end of: reached the end? */
					else
						{
							if( !ret && ( NO == m_Loop ) ) /* if not looping and reached the end */
								{
									/* fill the rest with 0 */
									while( pos < size )
										{
											*( buf + pos ) = 0;
											pos++;
										}

									/* and say that after the current section no other section follows */
									m_DataDone = YES;

								} /* end of: if( !ret ) */
						} /* end of: else ( reached the end ? ) */
        
					/* transfer data to buffer */
					hr = p_DSB->Unlock( buf, size, NULL, NULL );
					m_LastSection = m_Section;

				} /* end of: fill the section we just left */

			} /* end of: section changed */
  
		return OGG_OK;
	} /* end of: Update() */

/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\COgg.h
#ifndef _COGG_H_
#define _COGG_H_

/*
This is a simple Ogg Vorbis player class for DirectX Shit 8.

Link the following files to your project:
	vorbisfile_static.lib,
	vorbis_static.lib,
	ogg_static,
	dsound.lib.
Also be sure your include
paths contain the Vorbis SDK.

USAGE:

	OggPlayer op;
	op.OpenOgg( "somemusic.ogg" );
	op.Play();
	while( op.IsPlaying() );
	op.Close();

*/

/* ---------------------------------------------------------------------- */

#define     BUFSIZE  ( 0xFFFF + 1 )     /* buffer size */

/* ---------------------------------------------------------------------- */

class COgg
	{
	public:

		STD_DEFS						m_FileOpened;  /* file opened already ?          */
		STD_DEFS						m_Playing;     /* is ogg playing ?               */
		STD_DEFS						m_DataDone;    /* no more sound data in file     */
		int									m_Section;     /* current part of buffer         */
		int                 m_LastSection; /* previous section number        */
		STD_DEFS            m_Paused;      /* is playing paused ?            */
		STD_DEFS						m_Loop;        /* loop playing sound ?           */

    int mVolume;

		OggVorbis_File			m_vf;          /* vorbis file struct info        */
		LPDIRECTSOUNDBUFFER p_DSB;         /* ds secondary buffer            */

		/* Constructor and destructor */
		COgg();
		~COgg();

		/* open / reload .ogg file                            */
		/* direct shit sound is initialized in CMegaGineAudio */
		OGG_ERROR Load( const char *FileName );

		/* and close it */
    OGG_ERROR Close();

		/* playing / stopping / pausing functions */
		OGG_ERROR Play( STD_DEFS Loop = NO );
		OGG_ERROR Pause(); /* and unpause */
		OGG_ERROR Stop();

		/* volume control */
		OGG_ERROR SetVolume( int Percent = 100 );

		/* this function must be called to fill the buffer with new data to play */
		/* updates data to play position in file                                 */
		OGG_ERROR Update();

	}; /* class MUST END with semicolon */
		 /* end of: COgg */

/* ---------------------------------------------------------------------- */
#endif /* _COGG_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\CWav.cpp
#include "..\config.h"

#include    <windows.h>
#include    <mmreg.h>
#include    <dsound.h>
#include    <stdio.h>
#include    <assert.h>

#include "..\utility\Singleton.h"
#include "..\utility\defines.h"

#include "..\FileSystem\FileNode.h"
#include "..\FileSystem\BranchNode.h"
#include "..\FileSystem\FileSystem.h"
/* enums to return function codes for entire project */
#include "AudioError.h"
#include "Audio.h"

#include "CWav.h"

/* ---------------------------------------------------------------------- */

CWav::CWav()
{
 	m_FileOpened = NO;
	m_DataSize	 = 0;
	m_Loop			 = YES;
	m_Paused		 = NO;
  m_Playing    = NO;
  m_f          = NULL;
  m_WavBuffer  = NULL;
	p_DSB				 = NULL;
  p_DS3DB      = NULL;
  this->mVolume = 100;

} /* end of: constructor */

/* ---------------------------------------------------------------------- */

CWav::~CWav()
{
} /* end of: destructor */

/* ---------------------------------------------------------------------- */


WAV_ERROR CWav::Load(char* FileName)
{
  char * data = (char *) FileSystem::Instance()->LoadFile(FileName);
  if (data!= NULL)
  {
    return Load_from_memory(data);
  }
  else
  {
    return Load_from_disk(FileName);
  }

}
WAV_ERROR CWav::Load_from_memory(char *data )
{
   LPDIRECTSOUND8 pDS = CAudio::Instance()->GetSoundDevice();

   /* make sure direct shit sound is already initialized ( CMegaGineAudio ) */
	  if( NULL == pDS )
		{
			return WAV_DSOUND_NULL;
		}

  WAV_ERROR code = WAV_OK;

  /* check if this is really RIFF file */
  char ID[5] = ""; /* to hold 'RIFF\0' */
  memcpy( ID,data,  sizeof( char )* 4);
  if( strcmp( "RIFF", ID ) ) /* make sure we have RIFF file */
  {
    m_f = NULL;
    return WAV_NO_RIFF_FILE;
  }
  data +=  sizeof( char )* 4;
   
  /* read the file size */
  DWORD FileSize;
  memcpy( &FileSize,data, sizeof( DWORD )* 1);
  data+= sizeof(DWORD);

  /* this makes sure we have a wave file format ( RIFF can be MIDI also ) */
  memcpy( ID,data,  sizeof( char )* 4);
  if( strcmp( "WAVE", ID ) ) /* make sure we have WAVE file */
  {
    m_f = NULL;
    return WAV_NO_WAVE_FILE;
  }
  data +=  sizeof( char )* 4;
    
  /* read the format tags of the file */
   memcpy( ID,data,  sizeof( char )* 4);
  if( strcmp( "fmt ", ID ) ) /* make sure we have format available */
  {
    m_f = NULL;
    return WAV_BAD_FORMAT_TAG;
  }
   data +=  sizeof( char )* 4;

  /* wave format audio data */
	WAVEFORMATEX  wfm;
	ZeroMemory( &wfm, sizeof( wfm ) );
  wfm.cbSize = sizeof( wfm );
  /* other fields are filled when reading from file */

  DWORD FmtLen;
  memcpy(&FmtLen,data, sizeof( DWORD )* 1);
  data+= sizeof(DWORD);

  /* check for other possible format tags ( mmreg.h line 2253 ) */
  memcpy( &wfm.wFormatTag, data, sizeof( short )* 1);
  data+= sizeof(short);
  if( WAVE_FORMAT_PCM != wfm.wFormatTag ) /* support ONLY PCM format */
  {
    m_f = NULL;
    return WAV_UNSUPPORTED_FORMAT;
  }

  /* number of channels ( for 3D control must be mono ) */
  /* 1 -> mono                                          */
  /* 2 -> stereo                                        */
   memcpy( &wfm.nChannels, data, sizeof( short )* 1);
  data+= sizeof(short);
  if( WAVE_MONO != wfm.nChannels ) /* accept only mono for 3D control */
  {
    m_f = NULL;
    return WAV_NOT_MONO;
  }

  /* sample rate */
  memcpy(&wfm.nSamplesPerSec,data,sizeof( DWORD ) );
  data+= sizeof(DWORD); 
  /* other data shit used in WAVEFORMATEX struct */
  memcpy(&wfm.nAvgBytesPerSec,data, sizeof( DWORD ));
  data+= sizeof(DWORD);
  memcpy( &wfm.nBlockAlign, data,sizeof( short ) );
  data+= sizeof(short);
  /* should be 16 but low quality samples may be also */
  memcpy( &wfm.wBitsPerSample, data,sizeof( short ));
  data+= sizeof(short);
  /* now we read our data ( entirely ) */
  memcpy( ID, data,sizeof( char )* 4);
  data += 4*sizeof(char);
 
  if( strcmp( "data", ID ) ) /* make sure we have data available */
  {

    m_f = NULL;
    return WAV_BAD_DATA_TAG;
  }

  /* how many bytes of sound data we have */
  memcpy( &m_DataSize,data,sizeof( DWORD ) );
  data+= sizeof(DWORD); 
  /* now we set buffer for this data */
  m_WavBuffer = ( char * ) malloc( sizeof( char ) * m_DataSize );

  /* and read whole data chunk into this buffer */
  memcpy( m_WavBuffer,data, sizeof( char )* m_DataSize );
  data += sizeof( char )* m_DataSize;
  /* now we can create direct shit sound secondary buffer */
  /* set up the buffer */
  DSBUFFERDESC desc;
  desc.dwSize         = sizeof( desc );
  /* global focus makes us to be heard even when another wondow is active */
  desc.dwFlags        = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS;
  desc.lpwfxFormat    = &wfm; /* request buffer of the loaded wav format */
  desc.dwReserved     = 0;
  
  /* must be beetween DSBSIZE_MIN and MAX set in dsound.h */
  desc.dwBufferBytes  = m_DataSize;

	/* CreateSoundBuffer( struct DSBUFFERDESC, &pDSObject, must be NULL ); */
      /* avoids warnings */
  code = ( WAV_ERROR ) pDS->CreateSoundBuffer( &desc, &p_DSB, NULL );
  if( code ) /* error check */
  {
    free( m_WavBuffer );
    m_WavBuffer = NULL;
    m_f = NULL;
    return WAV_CREATE_BUFFER_FAILED;
  }

  /* obtain 3D control buffer interface */
  code = ( WAV_ERROR ) p_DSB->QueryInterface( IID_IDirectSound3DBuffer8, ( void ** ) &p_DS3DB );
  if( code ) /* error check */
  {
    free( m_WavBuffer );
    m_WavBuffer = NULL;
    m_f = NULL;
    return WAV_QUERY_3D_ITERFACE_FAILED;
  }

  /* we have correctly opened this file */
  m_FileOpened = YES;

  /* all sound data is stored in buffer */
  /* so we close the file               */
  m_f = NULL;
  return WAV_OK;
} /* end of: Load() */


WAV_ERROR CWav::Load_from_disk( const char *FileName )
{
   LPDIRECTSOUND8 pDS = CAudio::Instance()->GetSoundDevice();

   /* make sure direct shit sound is already initialized ( CMegaGineAudio ) */
	  if( NULL == pDS )
		{
			return WAV_DSOUND_NULL;
		}

  WAV_ERROR code = WAV_OK;

  /* if file already opened we force it to close */
	if( YES == m_FileOpened )
	  {
		  code = this->Close();
		}

  /* now we open file */
  m_f = fopen( FileName, "rb" );
  if( NULL == m_f ) /* error check */
  {
    return WAV_OPEN_FILE_FAILED;
  }

  /* check if this is really RIFF file */
  char ID[5] = ""; /* to hold 'RIFF\0' */
  fread( ID, sizeof( char ), 4, m_f );
  if( strcmp( "RIFF", ID ) ) /* make sure we have RIFF file */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_NO_RIFF_FILE;
  }

  /* read the file size */
  DWORD FileSize;
  fread( &FileSize, sizeof( DWORD ), 1, m_f );

  /* this makes sure we have a wave file format ( RIFF can be MIDI also ) */
  fread( ID, sizeof( char ), 4, m_f );
  if( strcmp( "WAVE", ID ) ) /* make sure we have WAVE file */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_NO_WAVE_FILE;
  }

  /* read the format tags of the file */
  fread( ID, sizeof( char ), 4, m_f );
  if( strcmp( "fmt ", ID ) ) /* make sure we have format available */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_BAD_FORMAT_TAG;
  }

  /* wave format audio data */
	WAVEFORMATEX  wfm;

	ZeroMemory( &wfm, sizeof( wfm ) );
  wfm.cbSize = sizeof( wfm );
  /* other fields are filled when reading from file */

  DWORD FmtLen;
  fread( &FmtLen, sizeof( DWORD ), 1, m_f );

  /* check for other possible format tags ( mmreg.h line 2253 ) */
  fread( &wfm.wFormatTag, sizeof( short ), 1, m_f );
  if( WAVE_FORMAT_PCM != wfm.wFormatTag ) /* support ONLY PCM format */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_UNSUPPORTED_FORMAT;
  }

  /* number of channels ( for 3D control must be mono ) */
  /* 1 -> mono                                          */
  /* 2 -> stereo                                        */
  fread( &wfm.nChannels, sizeof( short ), 1, m_f );
  if( WAVE_MONO != wfm.nChannels ) /* accept only mono for 3D control */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_NOT_MONO;
  }

  /* sample rate */
  fread( &wfm.nSamplesPerSec, sizeof( DWORD ), 1, m_f );
  
  /* other data shit used in WAVEFORMATEX struct */
  fread( &wfm.nAvgBytesPerSec, sizeof( DWORD ), 1, m_f );
  fread( &wfm.nBlockAlign, sizeof( short ), 1, m_f );

  /* should be 16 but low quality samples may be also */
  fread( &wfm.wBitsPerSample, sizeof( short ), 1, m_f );

  /* now we read our data ( entirely ) */
  fread( ID, sizeof( char ), 4, m_f );
  if( strcmp( "data", ID ) ) /* make sure we have data available */
  {
    fclose( m_f );
    m_f = NULL;
    return WAV_BAD_DATA_TAG;
  }

  /* how many bytes of sound data we have */
  fread( &m_DataSize, sizeof( DWORD ), 1, m_f );

  /* now we set buffer for this data */
  m_WavBuffer = ( char * ) malloc( sizeof( char ) * m_DataSize );

  /* and read whole data chunk into this buffer */
  fread( m_WavBuffer, sizeof( char ), m_DataSize, m_f );

  /* now we can create direct shit sound secondary buffer */
  /* set up the buffer */
  DSBUFFERDESC desc;
  desc.dwSize         = sizeof( desc );
  /* global focus makes us to be heard even when another wondow is active */
  desc.dwFlags        = DSBCAPS_CTRL3D | DSBCAPS_CTRLVOLUME | DSBCAPS_GLOBALFOCUS;
  desc.lpwfxFormat    = &wfm; /* request buffer of the loaded wav format */
  desc.dwReserved     = 0;
  
  /* must be beetween DSBSIZE_MIN and MAX set in dsound.h */
  desc.dwBufferBytes  = m_DataSize;

	/* CreateSoundBuffer( struct DSBUFFERDESC, &pDSObject, must be NULL ); */
      /* avoids warnings */
  code = ( WAV_ERROR ) pDS->CreateSoundBuffer( &desc, &p_DSB, NULL );
  if( code ) /* error check */
  {
    free( m_WavBuffer );
    m_WavBuffer = NULL;
    fclose( m_f );
    m_f = NULL;
    return WAV_CREATE_BUFFER_FAILED;
  }

  /* obtain 3D control buffer interface */
  code = ( WAV_ERROR ) p_DSB->QueryInterface( IID_IDirectSound3DBuffer8, ( void ** ) &p_DS3DB );
  if( code ) /* error check */
  {
    free( m_WavBuffer );
    m_WavBuffer = NULL;
    fclose( m_f );
    m_f = NULL;
    return WAV_QUERY_3D_ITERFACE_FAILED;
  }

  /* we have correctly opened this file */
  m_FileOpened = YES;

  /* all sound data is stored in buffer */
  /* so we close the file               */
  fclose( m_f );
  m_f = NULL;
  return WAV_OK;
} /* end of: Load() */

/* ---------------------------------------------------------------------- */

WAV_ERROR CWav::Close()
{
  if( this->m_FileOpened ) /* close the file */
  {
    if( NULL != this->m_f )
    {
      fclose( this->m_f );
		  this->m_FileOpened = NO;
    }
  }
  
  if( this->m_WavBuffer ) /* free sound data buffer */
		{
      free( this->m_WavBuffer );
      this->m_WavBuffer = NULL;
		}

  if( this->p_DS3DB ) /* free 3D control buffer */
  {
    this->p_DS3DB->Release();
  }

  if( this->p_DSB ) /* free buffer ( secondary ) for this wav */
		{
			this->p_DSB->Release();
		}

  return WAV_OK;
} /* end of: Load() */

/* ---------------------------------------------------------------------- */

WAV_ERROR CWav::Play( STD_DEFS Loop ) /* YES by default */
{
  /* can we do that ? */
	if( ( NO == m_FileOpened ) || ( NULL == p_DSB ) )
	{
		return WAV_PLAY_ERROR;
	}

  /* fill the buffer with data */
  WAV_ERROR code;
  void *pBuf;
  DWORD Length;

  /* lock entire buffer since wavs are short so we copy all data into buffer only once */
  code = ( WAV_ERROR ) this->p_DSB->Lock( 0, /* Offset at which to start lock. */
                                          0, /* Size of lock; ignored because of flag. */
                                          &pBuf, /* Gets address of first part of lock. */
                                          &Length, /* Gets size of first part of lock. */
                                          NULL, /* Address of wraparound not needed. */
                                          NULL, /* Size of wraparound not needed.*/
                                          DSBLOCK_ENTIREBUFFER );  // Flag.

  if( code ) /* in case of error */
  {
    return WAV_LOCK_BUFFER_FAILED;
  }

  /* now we copy our data into buffer */
  memcpy( pBuf, m_WavBuffer, Length );

  /* unlock the buffer */
  code = ( WAV_ERROR ) this->p_DSB->Unlock( pBuf, Length, NULL, 0 );
  if( code ) /* in case of error */
  {
    return WAV_UNLOCK_BUFFER_FAILED;
  }

  /* now we start playing */
  /* reset to start position */
  p_DSB->SetCurrentPosition( 0 );

  DWORD Flags = 0;
  if( Loop )
  {
    Flags |= DSBPLAY_LOOPING;
  }
  code = ( WAV_ERROR ) this->p_DSB->Play( 0, 0, Flags );
  if( code ) /* in case of error */
  {
    return WAV_PLAY_FAILED;
  }

  m_Loop = Loop;
  m_Playing = YES;
  return WAV_OK;
} /* end of: Play() */

/* ---------------------------------------------------------------------- */

WAV_ERROR CWav::Pause()
{
  if( !p_DSB ) /* can we do that ? */
  {
    return WAV_BUFFER_IS_NULL;
  }

  if( NO == m_Playing )
  {
    return WAV_NOT_PLAYING;

  }
  
  if( m_Paused ) /* if paused resume playing */
	{
		p_DSB->Play( 0, 0, DSBPLAY_LOOPING );
		m_Paused = NO;
	}
  else
	{
		p_DSB->Stop();
    m_Paused = YES;
  } /* end of: if( m_Paused ) */

  return WAV_OK;
} /* end of: Pause() */

/* ---------------------------------------------------------------------- */

WAV_ERROR CWav::Stop()
{
  if( !p_DSB ) /* can we do that ? */
  {
    return WAV_BUFFER_IS_NULL;
  }

  p_DSB->Stop();
  p_DSB->SetCurrentPosition( 0 );
  m_Paused = YES;
  
  return WAV_OK;
} /* end of: Stop() */

/* ---------------------------------------------------------------------- */

WAV_ERROR CWav::SetVolume( int Percent ) /* default is volume max */
{
  if( ( Percent < 0 ) || ( Percent > 100 ) )
	{
		/* if invalid range sound is heared with maximum volume */
		Percent = 100;
	}
  this->mVolume = Percent;
  if( NULL != this->p_DSB ) /* can we do it? */
	{
		this->p_DSB->SetVolume( -10000 + ( 100 * Percent ) );
    return WAV_OK;
	}
  return WAV_BUFFER_IS_NULL;
}

/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\Audio\CWav.h
#ifndef _CWAV_H_
#define _CWAV_H_

/* ---------------------------------------------------------------------- */
/* note: additionally dxguid.lib must be linked with this                 */
/*       used in QueryInterface to create 3D capable buffer               */

/* ---------------------------------------------------------------------- */

//#define     BUFSIZE       ( 0xFFFF + 1 )     /* buffer size */
#define     WAVE_MONO     1

/* ---------------------------------------------------------------------- */

class CWav
{
  public:

    STD_DEFS						m_FileOpened;  /* file opened already ?          */
    STD_DEFS						m_Playing;     /* is wav playing ?               */
		long    						m_DataSize;    /* size of sound data in file     */
    STD_DEFS            m_Paused;      /* is playing paused ?            */
		STD_DEFS						m_Loop;        /* loop playing sound ?           */
    FILE               *m_f;           /* file pointer i / o operations  */
    char               *m_WavBuffer;   /* wav sound data buffer          */

    int mVolume;
    LPDIRECTSOUNDBUFFER p_DSB;         /* ds secondary buffer            */
    LPDIRECTSOUND3DBUFFER8 p_DS3DB;    /* ds 3D control buffer           */
		
		/* Constructor and destructor */
		CWav();
		~CWav();

    /* load / close .wav ( RIFF ) file */
    /* direct shit sound is initialized in CMegaGineAudio */
    WAV_ERROR Load( char *FileName );
    WAV_ERROR Load_from_memory(char *data );
    WAV_ERROR Load_from_disk( const char *FileName );
    WAV_ERROR Close();

    /* playing / stopping / pausing functions */
    /* after Play you need only Stop and Pause ( NOT PLAY ) */
		WAV_ERROR Play( STD_DEFS Loop = NO );
		WAV_ERROR Pause(); /* and unpause */
		WAV_ERROR Stop();

    /* volume control */
    WAV_ERROR SetVolume( int Percent = 100 );

} /* MUST BE */; /* end of: COgg */

/* ---------------------------------------------------------------------- */
#endif /* _CWAV_H_ */
/* ---------------------------------------------------------------------- */
/* EOF */
E:\Project\Kopia (5) VBEngine\config.h
#ifndef _CONFIG_H
#define _CONFIG_H

#define DEMO
//#define DO_PROFILE
//#define DIEASASSERT
#define D3DX_MIGRATION

#define WIN32_LEAN_AND_MEAN
#define _MFC_OVERRIDES_NEW


#ifdef D3DX_MIGRATION
#pragma comment (lib,"d3dx9.lib")
#endif


#define ENGLISH 1
#define GERMAN 0
#define FRENCH 0
#define POLISH 0


#endif /* _CONFIG_H */
E:\Project\Kopia (5) VBEngine\Core\Ball.cpp
#include "..\config.h"

#include <assert.h>
#include <string.h>
#include "..\Utility\conf.h"
#include "..\Utility\Misc.h"
#include "..\Utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\utility\CTime.h"
#include "..\utility\logger.h"
#include "..\utility\tools.h"
#include "..\utility\Parabola.h"

#include "User.h"
#include "UserManager.h"

#include "..\graphics\meshmanager.h"
#include "..\graphics\SceneObject.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\Stadion.h"
#include "..\graphics\GUI.h"

#include "team.h"
#include "game.h"
#include "SetupManager.h"
#include "Ball.h"


CBall::CBall() : EventHandler(ET_BALL),
                 MeshSceneObject(1,"pilkagra.x"),
                 mStartPosition(0.0f,0.0f,0.0f),
                 mTargetPosition(0.0f,0.0f,0.0f),
                 mVelocity(0.0f,0.0f,0.0f),
                 mIsRolling(false),
                 mIsInWorld(true)
{
// ustawienie parametrów balistyki na wartoœci domyœlne
  GRAVITY = DEFAULT_GRAVITY;
  FLOOR_DAMPENING = DEFAULT_FLOOR_DAMPENING;
  NET_DAMPENING = DEFAULT_NET_DAMPENING;
  FLOOR_DRAG = DEFAULT_FLOOR_DRAG;
  MAX_SCINA_ALPHA = DEFAULT_MAX_SCINA_ALPHA;
  MIN_SCINA_ALPHA = DEFAULT_MIN_SCINA_ALPHA;
  SCINA_SPEED_TWEAK = DEFAULT_SCINA_SPEED_TWEAK;
  MIN_HIT_ALPHA = DEFAULT_MIN_HIT_ALPHA;
  MAX_HIT_ALPHA = DEFAULT_MAX_HIT_ALPHA;
  D_ALPHA = DEFAULT_D_ALPHA;
  D_SCINA_ALPHA = DEFAULT_D_SCINA_ALPHA;
  MAX_BALL_VELOCITY = DEFAULT_MAX_BALL_VELOCITY;

  ZAGRYWKA_MAX_GAMMA = DEFAULT_ZAGRYWKA_MAX_GAMMA;
  ZAGRYWKA_MIN_GAMMA = DEFAULT_ZAGRYWKA_MIN_GAMMA;

  ZAGRYWKA_SCINA_DELTA_ALPHA = DEFAULT_ZAGRYWKA_SCINA_DELTA_ALPHA;
  ZAGRYWKA_SCINA_DELTA_GAMMA = DEFAULT_ZAGRYWKA_SCINA_DELTA_GAMMA;
  ZAGRYWKA_SCINA_MAX_ALPHA   = DEFAULT_ZAGRYWKA_SCINA_MAX_ALPHA;
  ZAGRYWKA_SCINA_MIN_ALPHA   = DEFAULT_ZAGRYWKA_SCINA_MIN_ALPHA;
  ZAGRYWKA_SCINA_V_INCREASE_PER_SEC = DEFAULT_ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;

  ZAGRYWKA_LOP_DELTA_ALPHA = DEFAULT_ZAGRYWKA_LOP_DELTA_ALPHA;
  ZAGRYWKA_LOP_DELTA_GAMMA = DEFAULT_ZAGRYWKA_LOP_DELTA_GAMMA;
  ZAGRYWKA_LOP_MAX_ALPHA   = DEFAULT_ZAGRYWKA_LOP_MAX_ALPHA;
  ZAGRYWKA_LOP_MIN_ALPHA   = DEFAULT_ZAGRYWKA_LOP_MIN_ALPHA;
  ZAGRYWKA_LOP_V_INCREASE_PER_SEC = DEFAULT_ZAGRYWKA_LOP_V_INCREASE_PER_SEC;

  ZAGRYWKA_MIN_SCINA_VELOCITY = DEFAULT_ZAGRYWKA_MIN_SCINA_VELOCITY;
  ZAGRYWKA_MAX_SCINA_VELOCITY = DEFAULT_ZAGRYWKA_MAX_SCINA_VELOCITY;
  ZAGRYWKA_MIN_LOP_VELOCITY   = DEFAULT_ZAGRYWKA_MIN_LOP_VELOCITY;
  ZAGRYWKA_MAX_LOP_VELOCITY   = DEFAULT_ZAGRYWKA_MAX_LOP_VELOCITY;

  ZAGRYWKA_GAUSS_LOP_ALPHA = DEFAULT_ZAGRYWKA_GAUSS_LOP_ALPHA;
  ZAGRYWKA_GAUSS_SCINA_ALPHA = DEFAULT_ZAGRYWKA_GAUSS_SCINA_ALPHA;
  mTimeScale = 0.8f;
  
  
  // pobieranie powy¿szych parametrów z configu
  {
    ConfFile config;
    char buffer[MAX_FILE_NAME];

    my_snprintf(buffer, MAX_FILE_NAME, "%s%s", DataPath, "game.dat");
    if (SUCCEEDED(config.Init(buffer)))
    {
      config.GET_FOLAT("BALL_SPEED",&mTimeScale);

      config.GET_FOLAT("GRAVITY", &GRAVITY);
      config.GET_FOLAT("FLOOR_DAMPENING", &FLOOR_DAMPENING);
      config.GET_FOLAT("NET_DAMPENING", &NET_DAMPENING);
      config.GET_FOLAT("FLOOR_DRAG", &FLOOR_DRAG);

      if (SUCCEEDED(config.GET_FOLAT("MAX_SCINA_ALPHA", &MAX_SCINA_ALPHA)))
      {
        MAX_SCINA_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("MIN_SCINA_ALPHA", &MIN_SCINA_ALPHA)))
      {
        MIN_SCINA_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("SCINA_SPEED_TWEAK", &SCINA_SPEED_TWEAK)))
      {
        SCINA_SPEED_TWEAK *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("MIN_HIT_ALPHA", &MIN_HIT_ALPHA)))
      {
        MIN_HIT_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("MAX_HIT_ALPHA", &MAX_HIT_ALPHA)))
      {
        MAX_HIT_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("D_ALPHA", &D_ALPHA)))
      {
        D_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("D_SCINA_ALPHA", &D_SCINA_ALPHA)))
      {
        D_SCINA_ALPHA *= PI / 180.0f;
      }

      config.GET_FOLAT("MAX_BALL_VELOCITY", &MAX_BALL_VELOCITY);
      
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_MAX_GAMMA", &ZAGRYWKA_MAX_GAMMA)))
      {
        ZAGRYWKA_MAX_GAMMA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_MIN_GAMMA", &ZAGRYWKA_MIN_GAMMA)))
      {
        ZAGRYWKA_MIN_GAMMA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_SCINA_DELTA_ALPHA", &ZAGRYWKA_SCINA_DELTA_ALPHA)))
      {
        ZAGRYWKA_MIN_GAMMA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_SCINA_DELTA_GAMMA", &ZAGRYWKA_SCINA_DELTA_GAMMA)))
      {
        ZAGRYWKA_SCINA_DELTA_GAMMA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_SCINA_MAX_ALPHA", &ZAGRYWKA_SCINA_MAX_ALPHA)))
      {
        ZAGRYWKA_SCINA_MAX_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_SCINA_MIN_ALPHA", &ZAGRYWKA_SCINA_MIN_ALPHA)))
      {
        ZAGRYWKA_SCINA_MIN_ALPHA *= PI / 180.0f;
      }

      config.GET_FOLAT("ZAGRYWKA_SCINA_V_INCREASE_PER_SEC", &ZAGRYWKA_SCINA_V_INCREASE_PER_SEC);
      
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_LOP_DELTA_ALPHA", &ZAGRYWKA_LOP_DELTA_ALPHA)))
      {
        ZAGRYWKA_LOP_DELTA_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_LOP_DELTA_GAMMA", &ZAGRYWKA_LOP_DELTA_GAMMA)))
      {
        ZAGRYWKA_LOP_DELTA_GAMMA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_LOP_MAX_ALPHA", &ZAGRYWKA_LOP_MAX_ALPHA)))
      {
        ZAGRYWKA_LOP_MAX_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_LOP_MIN_ALPHA", &ZAGRYWKA_LOP_MIN_ALPHA)))
      {
        ZAGRYWKA_LOP_MIN_ALPHA *= PI / 180.0f;
      }

      config.GET_FOLAT("ZAGRYWKA_LOP_V_INCREASE_PER_SEC", &ZAGRYWKA_LOP_V_INCREASE_PER_SEC);
      config.GET_FOLAT("ZAGRYWKA_MIN_SCINA_VELOCITY", &ZAGRYWKA_MIN_SCINA_VELOCITY);
      config.GET_FOLAT("ZAGRYWKA_MAX_SCINA_VELOCITY", &ZAGRYWKA_MAX_SCINA_VELOCITY);
      config.GET_FOLAT("ZAGRYWKA_MIN_LOP_VELOCITY", &ZAGRYWKA_MIN_LOP_VELOCITY);
      config.GET_FOLAT("ZAGRYWKA_MAX_LOP_VELOCITY", &ZAGRYWKA_MAX_LOP_VELOCITY);
      
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_GAUSS_LOP_ALPHA", &ZAGRYWKA_GAUSS_LOP_ALPHA)))
      {
        ZAGRYWKA_GAUSS_LOP_ALPHA *= PI / 180.0f;
      }
      if (SUCCEEDED(config.GET_FOLAT("ZAGRYWKA_GAUSS_SCINA_ALPHA", &ZAGRYWKA_GAUSS_SCINA_ALPHA)))
      {
        ZAGRYWKA_GAUSS_SCINA_ALPHA *= PI / 180.0f;
      }

      config.DeInit();
    }
  }
  //ustaw parametry podstawowe
  this->nextBlock = NULL;
  this->HitCount = 0;
  mStartTime = mTimeScaleStartTime = CTime::Instance()->GetTime();
  this->mTimeScale = 0.8f; 
  mCurrentPosition = mStartPosition;
  mStoppedRolling = true;
  mIsRolling = true;
  this->mScina = false;
  mHitAlpha = 0.0f;
  mAngularVelocity = 0.0f;
  mAngle = 0.0f;
  mCurrentAngle = 0.0f;
  this->mUsePrzebicieTarget = false;
  this->mTeamOwner = 0;
  //przetestuj kolizje dla pierwszego lotu
  this->TestCollisions();
  //dodaj obiekt do sceny
  SceneManager::Instance()->AddObject(this);
}

CBall::~CBall()
{
  //usuñ obiekt ze sceny
  SceneManager::Instance()->RemoveObject(this);
}

void CBall::TestCollisions()
{
  //sprawdŸ oba rodzaje kolizji
  TestFloorHit(); // z pod³og¹ 
  TestNetHit();   // i z siatk¹
}

bool CBall::TestNetHit()
{
  // ustaw domyœlny tryb przejœæia przez p³aszczyzne siatki
  mNetPassTypes = NET_PASS_OVER;
  // jak nic nie znajdzie czas przejœcia przez siatke ustaw w prtaktycznej nieskoñczonoœci
  mNetHitTime = mStartTime + 1e30f;
  // jeœli pi³ka sie nie rusza w osi prostopad³ej do siatki nie ma co sprawdzaæ
  if (mVelocity.y == 0.0f) return false;
  
  float NetPassTime1, NetPassTime2;
  // czas zderzenia z p³aszczyznami oddalonymi od siatki o promieñ pi³ki
  NetPassTime1 = -(mStartPosition.y - BALL_RADIUS) / mVelocity.y + mStartTime;
  NetPassTime2 = -(BALL_RADIUS + mStartPosition.y) / mVelocity.y + mStartTime;

  // jeœli by³o to w przesz³oœci to olej ten test
  if (NetPassTime1 < mStartTime) return false;
  if (NetPassTime2 < mStartTime) return false;


  CVector3 entry;
  // NetPassTime1 jest czasem pierwszego zderzenia
  // jeœli tak nie jest to zamieñ
  if (NetPassTime1 > NetPassTime2)
  {
    NetPassTime1 = NetPassTime2;
  }
  

  //pobierz pozycje w któej sie znajdzie w czasie przejœcia przez t¹ p³aszczyzne
  GetPointByTime(TimeBallToWorld(NetPassTime1),&entry);

// jeœli jest poza siatk¹ - wyjdŸ
  if (entry.x > NET_MAX_X) return false;
  if (entry.x < NET_MIN_X) return false;
  if (entry.z > NET_MAX_Z) return false;

 
 // jesli jest poni¿ej - ustaw typ na przejœcie pod  
  if (entry.z < NET_MIN_Z )
  {
     mNetPassTypes = NET_PASS_UNDER;
     mNetHitTime = NetPassTime1;
     return true;
  }
// jak tu jesteœmy znaczy ¿e uderzy w siatke
  this->mNetPassTypes = NET_HIT_NET;
  LogWarning("BALL: uderzenie w siatke!");
  mNetHitTime = NetPassTime1;
  return true;
}

void CBall::TestFloorHit()
{
  // uderzy napewno - jedyne pytanie kiedy
  // sprawdzamy czas w którym pi³ka bêdzie na wysokoœci promienia pi³ki
  mFloorHitTime   = TimeWorldToBall(GetPointByZ(BALL_RADIUS,NULL)); 
}

void CBall::CalcFloorHit()
{
  //oblicz odbicie pi³ki od pod³ogi i rozeœli eventy
  CVector3 hitPos;
  float HitTime;
  HitTime = TimeWorldToBall(GetPointByZ(BALL_RADIUS, &hitPos));
  float DeltaT = HitTime - mStartTime;
  mVelocity.z -= GRAVITY * DeltaT;
  mVelocity.z *= -1;
  float vel = mVelocity.Length();
  unsigned int volume = (unsigned int)(100.0f * vel/MAX_BALL_VELOCITY);
  mVelocity *= FLOOR_DAMPENING; // wyt³um odbicie
  mAngle += mAngularVelocity * DeltaT;
  RecalcAngularVelocity();
  mStartTime = HitTime;
  mStartPosition = hitPos;
  POST_EVENT((ET_GAME | ET_TEAM_0 | ET_TEAM_1 | ET_STADION),GE_BALL_HIT_FLOOR,false, NULL);

  if (SetupManager::Instance()->GetSound()->ball)  
  {
    CVector3 *pos = new CVector3();
    pos->Set(&mStartPosition);
    POST_EVENT(ET_AUDIO, (this->mScina ? WAV_2 : WAV_1), false, pos);
  }
}


void CBall::CalcNetHit()
{
  switch(this->mNetPassTypes)
  {
  case NET_PASS_OVER  :
    {
      POST_EVENT((ET_GAME| ET_STADION),GE_BALL_PASS_OVER,false, NULL);
    }
  return;
  case NET_PASS_UNDER : 
    {
      POST_EVENT((ET_GAME| ET_STADION),GE_BALL_PASS_UNDER_NET,false, NULL);
    }
  return;
  case NET_HIT_NET    : 
    { //oblicz parametry odbicia od siatki (do falowania)
      NetHitStruct *NHS = new NetHitStruct;
      CVector3 NetHit;
      GetPointByTime(TimeBallToWorld(mNetHitTime),&NetHit);
      NHS->position = NetHit;
      mVelocity.z   -= GRAVITY * (mNetHitTime - mStartTime);

      NHS->velocity = mVelocity;
      NHS->time = TimeBallToWorld(mNetHitTime);
      mVelocity.y   *= -1;
      mVelocity     *= NET_DAMPENING; // wyt³um ruch pi³ki
      mAngle += mAngularVelocity * (mNetHitTime - mStartTime);
      RecalcAngularVelocity();
      mStartPosition = NetHit;
      mStartTime     = mNetHitTime;
      POST_EVENT((ET_GAME | ET_TEAM_0 | ET_TEAM_1 | ET_STADION), GE_BALL_HIT_NET, false, (void*)NHS);
      return;
    }
  }

}
void CBall::Update()
{
  // jeœli nie ma jej w œwiecie nie update'uj
  if (!mIsInWorld) return;
  // jeœli sie nie toczy to napewno nie stoi ;)
  if ( !mIsRolling )
  {
    mStoppedRolling = false;
  }
  //aktualny czas dla pi³ki
  float current_time = TimeWorldToBall(NOW);
  float delta_t = current_time - mStartTime;

  if ( mIsRolling )
  {
    if (!mStoppedRolling) 
    { // dopóki nie przesta³a sie toczyæ - obliczaj tarcie i prêdkoœæ k¹tow¹
       mVelocity *= (1 - FLOOR_DRAG) *delta_t;
       RecalcAngularVelocity();
    }
    if (mVelocity.LengthSq() < 0.001)
    {// Hack - czasemn sie zdarza³o ¿e pi³ka l¹dowa³a na pod³odze bez eventa "GE_BALL_HIT_FLOOR"
      //upewnienie sie ¿e tego eventa dosta³a
      if (CGame::Instance()->GetGamePhase() != GP_LIGHTS && !mStoppedRolling)
      {
        POST_EVENT((ET_GAME | ET_TEAM_0 | ET_TEAM_1 | ET_STADION),GE_BALL_HIT_FLOOR,true, NULL);
      }
      mStoppedRolling = true;
    }
  }
  else
  {// jeœli przeszliœmy przez siatke, oblicz kolizje
    if (current_time > mNetHitTime)
      {
        CalcNetHit();
        TestCollisions();
      }
      // jeœli zderzyliœmy sie z pod³og¹ oblicz kolizje
    if (current_time > mFloorHitTime )
      {
        CalcFloorHit();
        TestCollisions();
      }

  }
  delta_t = current_time - mStartTime;
  if (!mStoppedRolling) // jeœli nie skoñczy³a sie toczyæ - obliczaj aktualn¹ pozycje i k¹t
  {
     mCurrentPosition = mStartPosition + mVelocity * delta_t;
     mCurrentAngle = mAngle+mAngularVelocity * delta_t;
  }
  // jeœli sie nie toczy to oblicz wp³yw grawitacji
  if(!mIsRolling)
  {
    mCurrentPosition.z -= GRAVITY/2 * delta_t * delta_t;
  }

  // jeœli odbija sie ju¿ bardzo powoli niech sie zacznie toczyæ
  if (!mIsRolling && mVelocity.Length() <= 1.0f )
  {
    mStoppedRolling = false;
    mIsRolling = true;
    mVelocity.z = 0;
    mCurrentPosition.z = BALL_RADIUS;
    mStartPosition = mCurrentPosition;
    mStartTime = current_time;
  }
}

void CBall::Render(CMatrix4 *pViewProj)
{
  // nie ma nas w œwiecie nie renderuj
  if (!mIsInWorld) return;
  CVector3 z(0.0f,0.0f,1.0f);
  CVector3 Vel = mVelocity;
  CVector3 rotvec;

// obliczanie obrotu pi³ki
  Vel.Normalize();
  Vel.Cross(&rotvec,&z);
  rotvec.Normalize();
 
  Quaternion Q;
  Q.RotationAxis(&rotvec,mCurrentAngle);
  CMatrix4 rot,scale;
  Q.ConvertToRotationMatrix(&rot);
  worldMatrix.SetIdentity();
  
  scale.SetScale(BALL_SCALE,BALL_SCALE,BALL_SCALE);

  worldMatrix *= rot;
  //naprawiæ obrót!
  worldMatrix *= scale;
 
// ustawianie pozycji pi³ki
  CMatrix4 trans;
  trans.SetTranslate(mCurrentPosition.x,mCurrentPosition.y,mCurrentPosition.z);
  worldMatrix *= trans;
  CMatrix4 WordViewProj;
  MatMat4Multiply(WordViewProj, this->worldMatrix, *pViewProj);
  CMeshManager::Instance()->Render(this->mesh, &WordViewProj);
}

//odpowiadanie na eventy zagrania i odbicia

void CBall::ProcessEvent(Event *event)
{
  switch(event->mID)
  {
  case BE_GOT_HIT: 
    {
      BallHitStruct *hs = (BallHitStruct *) event->mData;
      if(hs->HitCount < this->HitCount) return; // zabezpieczenie przed eventami "nadpisanymi"
      CalculateHit(event->mTime, hs);
      if (this->nextBlock != NULL) // mog³o zostaæ zachowane z poprzedniego testu - sprawdŸ czy ktoœ nie chce nas blokowaæ
      {
        this->TestForBlock(nextBlock);
      }         
      return;
    }
  case BE_SERVING: CalculateServe(event->mTime, (BallServeStruct *) event->mData); return;
  }
}

// obliczanie ounktu na aktualnej paraboli w zale¿nosci od czasu

void CBall::GetPointByTime(float time,CVector3 *result)
{
  float delta_t = TimeWorldToBall(time) - mStartTime;
  *result = mStartPosition + mVelocity *delta_t;
  result->z -= (GRAVITY/2) *delta_t *delta_t;
}

// pobieranie punktu na paraboli dla okreslonej wysokosci z

float CBall::GetPointByZ(float z, CVector3 *result)
{
  float VzPrzezG = mVelocity.z/GRAVITY;
  float deltaZ = mStartPosition.z - z;
  float delta = VzPrzezG * VzPrzezG + (2/GRAVITY) * deltaZ;
  if (delta < 0) return -1e6;
  float deltaT = VzPrzezG + sqrtf(delta);
  if( result != NULL )
  {
	  result->x = mVelocity.x * deltaT + mStartPosition.x;
	  result->y = mVelocity.y * deltaT + mStartPosition.y;
    result->z = z;
  }
  return TimeBallToWorld(deltaT + mStartTime);
}


// funkcja obliczajaca serw z podanych w strukturze BallServeStruct danych 

void CBall::CalculateServe(float time, BallServeStruct *data)
{
  GUI::Instance()->HidePowerBar();
  time = TimeWorldToBall(time);
  mIsInWorld = true;
  mIsRolling = false;
  mStartPosition = data->ServePoint; 
  mStartTime = time; 
  float Vx , Vy , Vz , Vxy;
  Vz  = data->Velocity * sinf (data->Alfa );
  Vxy = data->Velocity * cosf (data->Alfa );
  Vx  = Vxy   * sinf (data->Gamma);
  Vy  = Vxy   * cosf (data->Gamma);

  mVelocity = CVector3(Vx,Vy,Vz);
  float VzPrzezG =  Vz / GRAVITY;
  mFlightTime  = VzPrzezG + sqrtf (VzPrzezG * VzPrzezG + (2/GRAVITY) * data->ServePoint.z);
  mTargetPosition = mStartPosition + CVector3(Vx * mFlightTime , Vy * mFlightTime , 0 );
 // mFlightTime +=time;
  this->TestCollisions();

  CTargetPrzebicia::Instance()->Hide();
  StopRegisteringHit();

  this->mTeamOwner = data->TeamNum;
  {
    GetPointByZ(0, &this->mTargetPosition); 
    CVector3 *tar = new CVector3();
    tar->Set(&this->mTargetPosition);
    POST_EVENT((ET_GAME | ET_TEAM_0 | ET_TEAM_1), GE_BALL_TARGET, false, tar);
  }
  RecalcAngularVelocity();
  this->HitCount++;
}


// obliczanie odbicia z punktow znajdujacych sie w strukturze BallHitStruct

void CBall::CalculateHit(float time, BallHitStruct *data)
{
  // pasek ³adowania si³y ju¿ napewno nam nie jest potrzebny ;)
  GUI::Instance()->HidePowerBar();
  
  // konwersja czasu przyjœcia eventa na czas pi³ki
  time = TimeWorldToBall(time);
  // powrót pi³ki do œwiata
  mIsInWorld = true;
  // ustawienie pocz¹tkowej pozycji paraboli na t¹ z data
  mStartPosition = data->HitPoint;
  // je¿eli u¿ywamy celu przebicia 
  if (mUsePrzebicieTarget)
  {
    mPrzebicieTarget.z = 0;
    data->TargetPoint = mPrzebicieTarget; // ustaw cel w data na cel przebicia
    mUsePrzebicieTarget = false;
  }


  this->mErrorHit = data->isError;
  // randomizacja podañ z b³êdami (œcina drugie podanie i podanie stop¹
  if(this->mErrorHit)
  {
    float modX = (myrand(99) > 50 ? 1.0f : -1.0f);
    float modY = (myrand(99) > 50 ? 1.0f : -1.0f);
    if (mScina) // œcina przy drugim podaniu ma o wiele mniejszy b³¹d ni¿ stopa
    {
      modX *= 0.2f;
      modY *= 0.2f;
    }
    /* add +/- 0 ... 4.5f */
    data->TargetPoint.x += modX * ((float)myrand(450) / 100.0f);
    data->TargetPoint.y += modY * ((float)myrand(450) / 100.0f);
  }

   
 
  // je¿eli mamy œcine, to AI powinna zrobiæ blok
  if(this->mScina)
  {
    POST_EVENT((data->TeamNum ? ET_TEAM_0 : ET_TEAM_1), TE_MAKE_BLOK, false, NULL);
  }
 
// punkt docelowy podania
  mTargetPosition = data->TargetPoint;
  mStartTime = time;
  float deltax, deltay, deltaz;
	deltax = data->TargetPoint.x  - data->HitPoint.x;
	deltay = data->TargetPoint.y  - data->HitPoint.y;
	// byl blad delta z powinna dla dalszych wzorow wychodzic dodatnia
	deltaz = data->HitPoint.z - data->TargetPoint.z;
	float DoceloweAlfa;
	float R = sqrtf(deltax *deltax + deltay * deltay);
  
   
  // wylosowaæ jakieœ parametry je¿eli nie mamy zarejstrowanego ¿adnego ³adowania paska
  if (!mIsRegisteringHit &&  !CGame::Instance()->IsTeamAI(data->TeamNum))
  {
   if(mScina)
   {
     mHitAlpha = GaussRand(0.5f *
            (MIN_SCINA_ALPHA + MAX_SCINA_ALPHA),0.2f,
             MIN_SCINA_ALPHA, MAX_SCINA_ALPHA);
   }
   else
  {
    mHitAlpha = GaussRand(0.5f *
          (MIN_HIT_ALPHA + MAX_HIT_ALPHA),0.2f,
           MIN_HIT_ALPHA,  MAX_HIT_ALPHA);
  }
  }
  StopRegisteringHit();
  // hak dla bardzo bliskich odleg³oœci - parabola ma za nisk¹ amplitude
  if (R < 0.5f)
  {
    mHitAlpha += PI/4; 
  }
  if (mHitAlpha > (PI/2 - PI/128))
    mHitAlpha = (PI/2 - PI/128);
    
  float tg = tanf(mHitAlpha);
  float param = deltaz + R*tg;
  // problem g³ównie dla œciny
  // k¹t podany jest ni¿szy ni¿ k¹t w trójk¹cie prostok¹tnym o przeciwprostok¹tnych
  // R i deltaz 
  // obliczamy minimalny i dodajemy odrobine ¿eby szybkoœæ nie by³a nieskoñczona
  if (param < 0)
  {
    mHitAlpha = atanf(-deltaz/R) + SCINA_SPEED_TWEAK;
    param = deltaz + R*tanf(mHitAlpha);
  }

  // k¹t poni¿ej 45 stopni - odbicie na k¹t powy¿ej 45
  if (!mScina && mHitAlpha < PI/4)
    mHitAlpha =  PI/2 - mHitAlpha;

  float cosSq = cosf(mHitAlpha);
  cosSq *= cosSq;
  
	float minPredkoscDlaAlfaMaxSq =(GRAVITY/2) * R *  R/(param*cosSq);
  DIE(minPredkoscDlaAlfaMaxSq > 0.0f);
  // prêdkoœæ dla zadanego k¹ta alfa
  float speed = sqrtf(minPredkoscDlaAlfaMaxSq);
  DoceloweAlfa = mHitAlpha;

  float Vz, Vxy, Vx, Vy;
  Vz  = speed * sinf (DoceloweAlfa);
  Vxy = speed * cosf (DoceloweAlfa);
  mFlightTime = R / Vxy;
  Vx = deltax / mFlightTime;
  Vy = deltay / mFlightTime;
  mVelocity = CVector3(Vx,Vy,Vz);
  this->TestCollisions();
  
  //schowaj cel przebicia
  CTargetPrzebicia::Instance()->Hide();

  //wyœli event którym ¿yje ta gra
  this->mTeamOwner = data->TeamNum;
  {
    GetPointByZ(0, &this->mTargetPosition); 
    CVector3 *tar = new CVector3();
    tar->Set(&this->mTargetPosition);
    POST_EVENT((ET_GAME | ET_TEAM_0 | ET_TEAM_1), GE_BALL_TARGET, false, tar);
  }
    
  RecalcAngularVelocity();
  this->HitCount++;
  this->mScina = false; 
}


//funkcje skaluj¹ce czas - pozwalaj¹ na przyspieszanie i zwalnianie pi³ki
float CBall::TimeWorldToBall(float time)
{
  return (time - this->mTimeScaleStartTime) * this->mTimeScale + this->mTimeScaleStartTime;  
}

float CBall::TimeBallToWorld(float time)
{
  return (time - this->mTimeScaleStartTime) / this->mTimeScale + this->mTimeScaleStartTime;
}

// rozpocznij "³adowanie paska
void CBall::StartRegisteringHit()
{
  mIsRegisteringHit = true;
  this->mHitRegisterTime = NOW;
  // wyzeruj zawartoœæ paska si³y
  GUI::Instance()->SetBallForce(0.0f);
  if(this->mScina)
  {
    mHitAlpha = MAX_SCINA_ALPHA;
  }
  else
  {
    mHitAlpha = MIN_HIT_ALPHA;
  }
}

float CBall::GetAlpha01(float alpha, bool scina)
{
  if(scina)
  { // dla œciny wzrost paska odpowiada zmniejszaniu sie k¹ta
    return 1.0f - (alpha - MIN_SCINA_ALPHA) /(MAX_SCINA_ALPHA - MIN_SCINA_ALPHA);
  }
  else
  {
    return (alpha - MIN_HIT_ALPHA  ) /(MAX_HIT_ALPHA - MIN_HIT_ALPHA);
  }
}

void CBall::RegisterHit()
{
//jeœli nie rejestrujesz - nie rób nic
 if (!mIsRegisteringHit) return;
 float gui = (NOW - mHitRegisterTime);
// 
 if(this->mScina)
 {
   gui *= D_SCINA_ALPHA;
   mHitAlpha += D_SCINA_ALPHA/30;//MAX_SCINA_ALPHA + gui;
   if (mHitAlpha < MIN_SCINA_ALPHA)
   {
     mHitAlpha = MIN_SCINA_ALPHA;
     gui = 1.0f;
   }
   else
   {
     gui = 1.0f - (mHitAlpha - MIN_SCINA_ALPHA) /(MAX_SCINA_ALPHA - MIN_SCINA_ALPHA);
   }
 }
 else
 {
   gui *= D_ALPHA;
   mHitAlpha += D_ALPHA/30;// MIN_HIT_ALPHA + gui; 
   if (mHitAlpha > MAX_HIT_ALPHA)
   {
     mHitAlpha = MAX_HIT_ALPHA;
   }
   gui = (mHitAlpha - MIN_HIT_ALPHA)/(MAX_HIT_ALPHA - MIN_HIT_ALPHA);
 }
 // ustaw pasek si³y
 GUI::Instance()->SetBallForce(gui);
}


void CBall::SetAIAlpha(float alpha)
{
  // ukryj pasek si³y 
  GUI::Instance()->HidePowerBar();
  // ustaw parametry si³y
  this->mHitRegisterTime = NOW;
  mIsRegisteringHit = false;
  mHitAlpha = alpha;
}


#define TWEAK_SCALE 1.5f

void CBall::RecalcAngularVelocity()
{
  // oblicz prêdkoœæ k¹tow¹ jako funkcje prêdkoœci liniowej
  mAngularVelocity = mVelocity.Length() * TWEAK_SCALE;// * delta_t;
}



bool CBall::TestForBlock(BallBlockStruct *blockDef)
{
// jeœli cel tego podania nie jest na po³owie blokuj¹cych znaczy ¿e ktoœ za wczeœnie odpalil i trzeba
  // dla pewnoœci zostawiæ na przysz³oœæ
  if (SGN(this->mTargetPosition.y) != SGN(blockDef->BlockPositions[0].y))
  {
#ifdef DEBUG
    LogError("CBall : Test Blok Later !!!!");
#endif
    if(this->nextBlock && blockDef != this->nextBlock)
    { // jak jest ju¿ jakiœ to olej i zapisz ten
      delete this->nextBlock;
    }
    this->nextBlock = blockDef;
    return false;
  }
#ifdef DEBUG
  LogError("CBall : Test Blok !!!!");
#endif
  for (int i = 0; i < blockDef->NumBlocking ;i ++)
  {
    CVector3 pos;
    float rd;
    if (blockDef->BlockTimes[i] < mStartTime) continue;
    this->GetPointByTime(blockDef->BlockTimes[i], &pos);
    rd = CGame::Instance()->GetTeam(blockDef->TeamNum)->GetBlockRadius();
    // gigantyczny promieñ blokowania , szeœcian 1m wokó³ r¹k zawodników
    if (FABS(pos.x - blockDef->BlockPositions [i].x) > 8.5f * BALL_RADIUS * rd) continue;
    if (FABS(pos.y - blockDef->BlockPositions [i].y) > 8.5f * BALL_RADIUS * rd) continue;
    if (FABS(pos.z - blockDef->BlockPositions [i].z) > 8.5f * BALL_RADIUS * rd) continue;

    // je¿eli nawet pi³ka jest w tym sdzeœcianie to mo¿e zawodnik jej nie zablokowaæ
    /*if(!CGame::Instance()->GetTeam(blockDef->TeamNum)->CanBlock(GetAlpha01(mHitAlpha)))
    {
      break;
    }*/
    // jak ju¿ zablokowa³ to wyœlij do siebie eventa ¿e bêdziesz odbita
    BallHitStruct *hs = new BallHitStruct();
    hs->isError = false;
    hs->TeamNum = blockDef->TeamNum;
    hs->HitPoint = blockDef->BlockPositions [i];
    hs->TargetPoint = blockDef->BlockPositions[i];
    hs->TargetPoint.z = 0.0f;
    hs->TargetPoint.y *= -1.0f;  
    hs->HitCount = this->HitCount;
    
    // a do zespo³ów informacje ¿e sie blok uda³
    POST_EVENT((blockDef->TeamNum ? ET_TEAM_1 : ET_TEAM_0), TE_SUCCESSFUL_BLOCK, true, NULL);
    POST_EVENT((blockDef->TeamNum ? ET_TEAM_0 : ET_TEAM_1 ), TE_RESET_HITCOUNT , true, NULL);
    CTargetPrzebicia::Instance()->Hide();
    POST_EVENT3(ET_BALL, BE_GOT_HIT, blockDef->BlockTimes[i], hs);
    if (SetupManager::Instance()->GetSound()->ball)
    {
      POST_EVENT3(ET_AUDIO, WAV_5 , blockDef->BlockTimes[i], NULL);
    }
    SetAIAlpha(GaussRand(0.5f * (MIN_HIT_ALPHA + MAX_HIT_ALPHA),0.2f, MIN_HIT_ALPHA, MAX_HIT_ALPHA));

    this->mUsePrzebicieTarget = false;
#ifdef DEBUG
    LogError("CBall : Udany Blok !!!!");
#endif
    if(this->nextBlock && blockDef != this->nextBlock)
    {
      delete this->nextBlock;
    }
    delete blockDef;
    this->nextBlock = NULL;
    return true;
  }

  if(this->nextBlock && blockDef != this->nextBlock)
  {
    delete this->nextBlock;
  }
  delete blockDef;
  this->nextBlock = NULL;
  return false;
}
E:\Project\Kopia (5) VBEngine\Core\Ball.h
#ifndef _BALL_H
#define _BALL_H

/*
class       :
description :

methods     :

*/

// domyslne parametry dla pilki
#define BALL_SCALE       1.15f               // skala piłki
#define BALL_RADIUS       0.1f * BALL_SCALE  // promień piłki

//wymiary siatki dla testowania kolizji
#define NET_MIN_Z         1.0f 
#define NET_MAX_Z         2.43f
#define NET_MIN_X        -5.0f
#define NET_MAX_X         5.0f


//domylne (nie pobierane z piliku) wartoci parametrów 
#define DEFAULT_GRAVITY          9.81f           // grawitacja
#define DEFAULT_FLOOR_DAMPENING   0.7f           // współczynnik tłumienia podłogi
#define DEFAULT_NET_DAMPENING     0.6f           // współczynnik tłumienia siatki
#define DEFAULT_FLOOR_DRAG         0.05f         // tarcie o podłoge
#define DEFAULT_MAX_SCINA_ALPHA    10 * PI/180   // maksymalny kšt dla podania cinš
#define DEFAULT_MIN_SCINA_ALPHA   -30 * PI/180   // minimalny kšt dla œciny
#define DEFAULT_SCINA_SPEED_TWEAK   2 * PI/180   // dodatkowy kšt przy za niskich œcinach (param < 0)
#define DEFAULT_MIN_HIT_ALPHA      65 * PI/180   // minimalny kšt podania
#define DEFAULT_MAX_HIT_ALPHA      80 * PI/180   // maksymalny kšt podania
#define DEFAULT_D_ALPHA            15 * PI/180   // zmiana kšta przy "ładowaniu paska" podania
#define DEFAULT_D_SCINA_ALPHA     -15 * PI/180   // zmiana kšta przy "ładowaniu paska" sciny    
#define DEFAULT_MAX_BALL_VELOCITY  15.0f         // maksymalna prędkoć piłki

#define DEFAULT_ZAGRYWKA_MAX_GAMMA           45.0f*PI/180 // graniczny kšt w płaszczynie x,y dla 
#define DEFAULT_ZAGRYWKA_MIN_GAMMA          -45.0f*PI/180 // zagrywki

#define DEFAULT_ZAGRYWKA_SCINA_DELTA_ALPHA 0.02f // zmiana kšta przy zagrywce scina gracza
#define DEFAULT_ZAGRYWKA_SCINA_DELTA_GAMMA 0.02f 
#define DEFAULT_ZAGRYWKA_SCINA_MAX_ALPHA           30.0f*PI/180 // maksymalne nachylenie paraboli przy zagrywce œcinš
#define DEFAULT_ZAGRYWKA_SCINA_MIN_ALPHA          -30.0f*PI/180 // minimalne nachylenie paraboli przy zagrywce œcinš
#define DEFAULT_ZAGRYWKA_SCINA_V_INCREASE_PER_SEC  2.5f         // przyrost siły podania dla gracza

#define DEFAULT_ZAGRYWKA_LOP_DELTA_ALPHA 0.05f    // patrz parametry powyżej - te sš dla zagrywki lobem
#define DEFAULT_ZAGRYWKA_LOP_DELTA_GAMMA 0.1f
#define DEFAULT_ZAGRYWKA_LOP_MAX_ALPHA   85.0f*PI/180
#define DEFAULT_ZAGRYWKA_LOP_MIN_ALPHA   30.0f*PI/180
#define DEFAULT_ZAGRYWKA_LOP_V_INCREASE_PER_SEC  2.0f 

#define DEFAULT_ZAGRYWKA_MIN_SCINA_VELOCITY        10.0f  // wartoci graniczne prędkoci dla zagrywki cinš
#define DEFAULT_ZAGRYWKA_MAX_SCINA_VELOCITY        25.0f
#define DEFAULT_ZAGRYWKA_MIN_LOP_VELOCITY        8.0f  // wartoci graniczne prędkoci dla zagrywki lobem
#define DEFAULT_ZAGRYWKA_MAX_LOP_VELOCITY        20.0f

#define DEFAULT_ZAGRYWKA_GAUSS_LOP_ALPHA        45.0f*PI/180  // wartoci mediany dla obliczeń GaussRand
#define DEFAULT_ZAGRYWKA_GAUSS_SCINA_ALPHA      15.0f*PI/180  // dla zagrywek AI

// Typy przejć przez siatke
enum NetPassTypes
{
  NET_PASS_OVER,  // ponad siatkš
  NET_PASS_UNDER, // pod siatkš
  NET_HIT_NET,  // uderzenie w siatke
  NET_HIT_TOP,  // uderzenie w szczyt siatki (nie obsługiwane)
  NET_HIT_BOTTOM // uderzenie w spód siatki
};


// Eventy przychodzšce do piłki
enum BallEvents
{
  BE_GOT_HIT,        // uderzenie przy podaniu, cinie, bloku
  BE_SERVING,        // uderzenie przy serwach
  BE_TRYING_TO_BLOCK // próba bloku - nie używana
};

// struktura przesyłana w evencie "GE_HIT_NET"
struct NetHitStruct
{
  CVector3 position; // pozycja piłki w momencieodbicia
  CVector3 velocity; // prędkoć
  float time;        // czas odbicia
};

//struktura przesyłana w evencie "BE_SERVING"
struct BallServeStruct
{
  CVector3 ServePoint;  // punkt zaserwowania
  float Velocity;       // prędkoć

  float Gamma,Alfa;     // kšt obrotu wokół osi z i nachylenia nad płaszczyznš x,y
  int TeamNum;          // zespół który zaserwował
};

// struktura przesyłana w evencie "BE_GOT_HIT"
struct BallHitStruct
{
 CVector3 HitPoint;  // punkt uderzenia 
 CVector3 TargetPoint;  // punkt docelowy podania
 unsigned int HitCount;  // iloć odbić
 unsigned char TeamNum;  // zespół odbijajšcy
 bool isError;           // czy piłka powinna dane podanie "zrandomizować"
};

// struktura przesyłana do funkcji TestForBlock
struct BallBlockStruct
{ 
  int TeamNum;  // zespół blokujšcy
  unsigned char NumBlocking; //iloć zawodników na bloku
  float BlockTimes[MAX_PLAYERS_ON_FIELD];  // czasy w których blok dojdzie do maksymalnej wysokoci
  CVector3 BlockPositions[MAX_PLAYERS_ON_FIELD]; // pozycje w których będš ręce zawodników przy maksymalnej wysokoci
};

/*
Klasa Piłki 

Odpowiada za wszelkie operacje zwišzane z piłkš w wiecie gry, od renderowania, poprzez obsługe eventów
odbicia, testowanie bloku, sprawdzania kolizji ze wiatem (podłogš i siatkš na razie)



*/
class CBall : public Singleton<CBall> , MeshSceneObject, EventHandler
{

/* parametry do obliczeń balistyki piłki:
  mStartPosition - pozycja rozpoczęcia paraboli
  mTargetPosition - pozycja docelowa paraboli
  mVelocity - prędkoć piłki
  mCurrentPosition - wyliczona w Update aktualna pozycja piłki
  mCurrentVelocity - aktualna prędkoć piłki;
*/

  CVector3 mStartPosition, mTargetPosition;
  CVector3 mVelocity;
  CVector3 mCurrentPosition,mCurrentVelocity;

  // typ najbliższego czasowo przejcia przez płaszczyzne siatki
  NetPassTypes mNetPassTypes;
  
  int mTeamOwner; /* Kto odbil te pilke */
  // czas startu lotu, i czas trwania lotu
  float mStartTime, mFlightTime;
  // czas uderzenia w siatke (lub 1e6 jesli nie uderzy w siatke )
  float mNetHitTime;
  // czas uderzenia w podłoge
  float mFloorHitTime;
  // czy przestała sie już toczyć ( zatrzymanie)
  bool mStoppedRolling;
  // czy toczy sie
  bool  mIsRolling;
  // czy piłka jest w wiecie?
  bool  mIsInWorld;

  // czas (rzeczywisty) rozpoczęcia skalowania czasu dla piłki (przyspieszanie zwalnianie itp.)
  float mTimeScaleStartTime;
  // skala czasu dla piłki
  float mTimeScale;
  // czas rozpoczęcia rejestrowania "ładowania paska"
  float mHitRegisterTime;
  // kšt zarejestrowany przy "ładowaniu paska"
  float mHitAlpha;
  // Cel przebicia dla piłki
  CVector3 mPrzebicieTarget;
  // czy następne odbicie ma używać powyższego wektora zamiast tego z eventa
  bool mUsePrzebicieTarget;
  // czy następne przebicie będzie cinš
  bool mScina;
  // czy rejestruje "ładowanie paska"
  bool mIsRegisteringHit;
  // prędkoć kštowa
  float mAngularVelocity; 
  // kšt obliczany z prędkoci kštowej
  float mAngle;
  // aktualny kšt
  float mCurrentAngle;
  // iloć odbić
  unsigned int HitCount;
  // czy odbicie było z błędem 
  bool mErrorHit;  
  //struktura przechowujšca dane o bloku do czasu następnego BE_GOT_HIT
  BallBlockStruct *nextBlock;

  //sprawd kolizje z siatkš
  bool TestNetHit();
  //oblicz efekt kolizji z siatkš
  void CalcNetHit();
  //sprawd kolizje z podłogš 
  void TestFloorHit();
  //oblicz efekt kolizji z podłogš
  void CalcFloorHit();
  //sprawd któa kolizja będzie pierwsza
  void TestCollisions();
  
  
  // pobierz kšt alfa przeskalowany od 0 do 1 (dla "ładowania paska")
  float GetAlpha01(float alpha, bool scina = true);
  // ponownie przelicz prędkoć kštowš
  void RecalcAngularVelocity();


    //skalowanie czasu - funkcje urzywana wewnętrznie
  // czas "rzeczywisty" na czas piłki
  float TimeWorldToBall(float time);
  //czas piłki na czas "rzeczywisty"
  float TimeBallToWorld(float time);
public:
//wartoci pobierane z Game.dat albo ustawiane z definów powyżel
  float GRAVITY;
  float FLOOR_DAMPENING;
  float NET_DAMPENING;
  float FLOOR_DRAG;
  float MAX_SCINA_ALPHA; 
  float MIN_SCINA_ALPHA;
  float SCINA_SPEED_TWEAK;
  float MIN_HIT_ALPHA;
  float MAX_HIT_ALPHA;
  float D_ALPHA; 
  float D_SCINA_ALPHA; 
  float MAX_BALL_VELOCITY;

  float ZAGRYWKA_MAX_GAMMA;
  float ZAGRYWKA_MIN_GAMMA;

  float ZAGRYWKA_SCINA_DELTA_ALPHA;
  float ZAGRYWKA_SCINA_DELTA_GAMMA;
  float ZAGRYWKA_SCINA_MAX_ALPHA;
  float ZAGRYWKA_SCINA_MIN_ALPHA;
  float ZAGRYWKA_SCINA_V_INCREASE_PER_SEC;

  float ZAGRYWKA_LOP_DELTA_ALPHA;
  float ZAGRYWKA_LOP_DELTA_GAMMA;
  float ZAGRYWKA_LOP_MAX_ALPHA;
  float ZAGRYWKA_LOP_MIN_ALPHA;
  float ZAGRYWKA_LOP_V_INCREASE_PER_SEC;

  float ZAGRYWKA_MIN_SCINA_VELOCITY;
  float ZAGRYWKA_MAX_SCINA_VELOCITY;
  float ZAGRYWKA_MIN_LOP_VELOCITY;
  float ZAGRYWKA_MAX_LOP_VELOCITY;

  float ZAGRYWKA_GAUSS_LOP_ALPHA;
  float ZAGRYWKA_GAUSS_SCINA_ALPHA;

  CBall();
  ~CBall();
  void Update();

  //zwraca numer zespołu który za ostatnim razem odbił piłke
  int GetTeamOwner(void) {return this->mTeamOwner;};
  // zwrace pointer na pozycje docelowš piłki
  CVector3 *GetTargetPosition(void) { return &this->mTargetPosition; };
  //ProcessEvent - odziedziczony z EventHandler
  void ProcessEvent(Event *event);
  //Render - odziedziczony ze SceneObject 
  void Render(CMatrix4 *pViewProj);

  //funkcja obliczajšca serw w odpowiedzi na event BE_SERVING
  void CalculateServe(float time,BallServeStruct *data);
  //funkcja obliczajšca podanie w odpowiedzi na event BE_GOT_HIT
  void CalculateHit(float time,BallHitStruct *data);
  // funkcja wypełniajšca result pozycjš piłki w danej chwili w czasei
  void GetPointByTime(float time,CVector3 *result);
  // funkcja podajšca czas i pozycje w której piłka znajdzie sie na danej wysokoci
  float GetPointByZ(float z, CVector3 * result);
  // usuń ze wiata, przestań przetwarzać Update 
  // powrót do wiata poprzez CalculateServe, albo CalculateHit
  void RemoveFromWorld() {mIsInWorld = false;};
  // sprawdzenie czy piłka jest przetwarzana
  bool IsInWorld() {return mIsInWorld;}
  //sprawdzenie czy piłka uderzy w siatke (dokładniej czy będzie jakie nielegalne przejćie)
  bool WillHitNet() {return (mNetPassTypes != NET_PASS_OVER);};
  //sprawdzenie szczegółowo czy piłka przeleci pod siatkš
  bool WillPasUnder(void) {return (mNetPassTypes == NET_PASS_UNDER);};
  // pobranie czasu zderzenia z podłogš
  float  GetFloorHitTime() {return TimeBallToWorld(mStartTime + mFlightTime);};

  //rozpocznij rejestrowanie "ładowania paska"
  void StartRegisteringHit();
  // zakończ rejestrowanie "ładowania paska"
  void StopRegisteringHit() {mIsRegisteringHit = false;};
  // czy jest w trybie "ładowania paska"
  bool IsRegisteringHit(void) {return this->mIsRegisteringHit;};
  // dodaj kolejnš porcje do zakumulowanego kšta
  void RegisterHit();
  // ustaw kšt następnego podania na zadanš wartoć
  void SetAIAlpha(float alpha);
  // pobierz wektor docelowy przebicia
  CVector3 *GetPrzebicieTarget() {return &mPrzebicieTarget;}
  // ustaw uyżywanie celu przebicia
  void UsePrzebicieTarget() {mUsePrzebicieTarget = true;}
  // ustaw następne podanie jako cine
  void SetScina(bool s) {this->mScina = s;}
  // pobierz czas w któym piłka pokona dany procent toru
  float GetFlightTimeByPercentage(float p) {return TimeBallToWorld(mFlightTime *p +mStartTime);}
  // pobierz pointer na pozycje starowš
  CVector3 *GetBallStartPosition() {return &this->mStartPosition;}
  //pobierz pointer na aktualnš pozycje piłki
  CVector3 *GetCurrentBallPosition() {return &this->mCurrentPosition;} 

  //funkcja sprawdzajšca blok zwraca true jeli piłka zostanie zablokowana
  bool TestForBlock(BallBlockStruct *blockDef);
  //pobierz iloć odbić
  unsigned int GetHitCount(void) {return this->HitCount;};
  // sprawdzenie czy poprzednie odbicie było "randomizowane"
  bool WasErrorHit(void) {return this->mErrorHit;};
};

#endif /* _BALL_H */
E:\Project\Kopia (5) VBEngine\Core\EuroLeague.cpp
#include "..\config.h"

#include <memory.h>
#include <assert.h>
#include <stdlib.h>
#include <search.h>

#include "..\utility\defines.h"
#include "..\utility\tools.h"
#include "..\utility\singleton.h"
#include "EuroLeague.h"


// konstruktor ligi - losuje tabele meczy 
EuroLeague::EuroLeague(eTeams player_team)
{
  this->mSwappedMatch = false;
  this->mPlayerTeam = player_team;
  char teams[12];
  char pools[12];
  for (int i = 0; i < 8 ; i ++)
  {
    teams[i] = i+12;  // wype³nij tabele offsetami dru¿yn
  }
  int k;
  for (int i = 0; i < 8 ; i ++)
  {
   do 
   {
     k = myrand(7);  // wylosuj pozycje w tabeli 
     pools[i] = teams[k]; // wype³nij losow¹ liste zespo³ów 
   } 
   while(teams[k] == -1); 
   teams[k] = -1;  // usuñ zespó³ ju¿ u¿yty
  }
  // wyzeruj parametry
  this->mCurrentWeekend = 0; 
  memset (this->mWeekends,0, sizeof(this->mWeekends)); 
  memset (this->mCurrentRanking ,0, sizeof(this->mCurrentRanking));  
  memset (this->mFinals ,0, sizeof(this->mFinals));  

  for (int i = 0 ; i < 8 ; i++)
  {
    this->mPools[i/4][i%4] = (eTeams)pools[i]; // przypo¿¹dkuj wylosowane zespo³y do pul
  }

  for (int i = 0 ; i < 6 ; i ++)
  {
    // dla ka¿dej puli stwórz mecze zgodnie z tablic¹ "parowania"
    for (int j = 0; j < 2 ; j++)
    {
      this->mWeekends[0][i].matches[j].teams[0] =  mPools[0][matchMap[i][j*2]];
      this->mWeekends[0][i].matches[j].teams[1] =  mPools[0][matchMap[i][j*2+1]];
    }
    // oraz rewan¿e bêd¹ce po prostu obróconymi meczami powy¿ej
    for (int j = 2; j < 4 ; j++)
    {
      this->mWeekends[0][i].matches[j].teams[0] = this->mWeekends[0][i].matches[j-2].teams[1];
      this->mWeekends[0][i].matches[j].teams[1] = this->mWeekends[0][i].matches[j-2].teams[0];
    }
        for (int j = 0; j < 2 ; j++)
    {
      this->mWeekends[1][i].matches[j].teams[0] =  mPools[1][matchMap[i][j*2]];
      this->mWeekends[1][i].matches[j].teams[1] =  mPools[1][matchMap[i][j*2+1]];
    }
    for (int j = 2; j < 4 ; j++)
    {
      this->mWeekends[1][i].matches[j].teams[0] = this->mWeekends[1][i].matches[j-2].teams[1];
      this->mWeekends[1][i].matches[j].teams[1] = this->mWeekends[1][i].matches[j-2].teams[0];
    }
  }
  mMatchPlayed = false;
  mCurrentMatch =0;
  mCurrentPool = 0;
  mFinalStage = 0;
}


match *EuroLeague::GetNextMatch()
{
  // pobierz mecz je¿eli jest w nim zespó³ gracza, je¿eli nie wylosuj coœ dla tego meczu
  
  while (mCurrentWeekend < 6)
  {
    while (mCurrentMatch < 4)
    {
      while (mCurrentPool < 2)
      {
        match *temp = &mWeekends[mCurrentPool][mCurrentWeekend].matches[mCurrentMatch];
        if (temp->teams[0] == mPlayerTeam )
        {
          this->mSwappedMatch = false;
          return temp; // wyjœcie z pentli i z funkcji
        }
        else
        if (temp->teams[1] == mPlayerTeam)
        {
          this->mSwappedMatch = true;
          return temp;// wyjœcie z pentli i z funkcji
        }
        else
        {
         this->RandomiseScore(temp);
        }
        mCurrentPool++;
      }
      mCurrentPool = 0;
      mCurrentMatch++;
    }
    mCurrentMatch = 0;
    this->CalcRanking();
    mCurrentWeekend++;
  }
  // mecze fina³owe maj¹ specjalny format obliczania zespo³ów bior¹cych udzia³
  while (this->mFinalStage < 3)
  {
    if (this->mFinalStage == 0)
    {
      // pierwszy gra zawsze zespó³ gracza (organizator)
      this->mFinals[0][0].teams[0] = this->mPlayerTeam; 
      // jeœli drugi w rankingu pierwszej puli jest gracz to na to miejsce wchodzi pierwszy z pierwszej puli
      this->mFinals[0][0].teams[1] = this->mCurrentRanking[0][5][1].team  == this->mPlayerTeam ? this->mCurrentRanking[0][5][0].team  : this->mCurrentRanking[0][5][1].team ;
      // jeœli pierwszy w rankingu drugiej puli jest gracz to na to miejsce wchodzi pierwszy z pierwszej puli
      this->mFinals[0][1].teams[0] = this->mCurrentRanking[1][5][0].team  == this->mPlayerTeam ? this->mCurrentRanking[0][5][0].team  : this->mCurrentRanking[1][5][0].team ;
      // jeœli drugi w rankingu drugiej puli jest gracz to na to miejsce wchodzi pierwszy z pierwszej puli
      this->mFinals[0][1].teams[1] = this->mCurrentRanking[1][5][1].team  == this->mPlayerTeam ? this->mCurrentRanking[0][5][0].team  : this->mCurrentRanking[1][5][1].team ; 
    } else
    if (this->mFinalStage == 1 )
    { // pierwszy mecz drugiej fazy - przegrany pierwszego meczu z wygranym drugiego z poprzedniej
      this->mFinals[1][0].teams[0] = this->mFinals[0][0].teams[this->mFinals[0][0].loser];
      this->mFinals[1][0].teams[1] = this->mFinals[0][1].teams[this->mFinals[0][1].winner];
     // drugi mecz drugiej fazy - wygrany pierwszego meczu z przegranym drugiego z poprzedniej
      this->mFinals[1][1].teams[0] = this->mFinals[0][0].teams[this->mFinals[0][0].winner];
      this->mFinals[1][1].teams[1] = this->mFinals[0][1].teams[this->mFinals[0][1].loser];
    } else
    {
      // mecz o trzecie miejsce miêdzy przegranymi poprzednich meczy
      this->mFinals[2][0].teams[0] = this->mFinals[1][0].teams[this->mFinals[1][0].loser];
      this->mFinals[2][0].teams[1] = this->mFinals[1][1].teams[this->mFinals[1][1].loser];
      // mecz o pierwsze i drugie miejsce
      this->mFinals[2][1].teams[0] = this->mFinals[1][0].teams[this->mFinals[1][0].winner];
      this->mFinals[2][1].teams[1] = this->mFinals[1][1].teams[this->mFinals[1][1].winner];
    }
// podobnie jak z fazy przedfina³owej
    while (this->mCurrentMatch < 2)
    {
       match *temp = &mFinals[mFinalStage][mCurrentMatch];
       if (temp->teams[0] == mPlayerTeam )
        {
          this->mSwappedMatch = false;
          return temp; // wyjœcie z pêtli
        }
        else
        if (temp->teams[1] == mPlayerTeam)
        {
          this->mSwappedMatch = true;
          return temp; // wyjœcie z pêtli
        } 
        else
        {
         this->RandomiseScore(temp);
        }
       mCurrentMatch++;
    }
    mCurrentMatch = 0;
    this->mFinalStage++;
  }
  return NULL;
}

// funkcja losuj¹ca wyniki

void EuroLeague::RandomiseScore(match *_match)
{
  unsigned int vals[2];
  vals[0] = (unsigned int)(100.0f * SkillTweaks[_match->teams[0]]); // u³amek skutecznoœci zespo³ów
  vals[1] = (unsigned int)(100.0f * SkillTweaks[_match->teams[1]]); // u³amek skutecznoœci zespo³ów
  unsigned int winner,loser,set_winner,set_loser,sets[2],current_set;
  if (myrand(vals[0]) > myrand(vals[1]))  // je¿eli wylosuje wiêcej to jest zwyciêzc¹
  {
    winner = 0; 
    loser = 1;
  }
  else
  {
    winner = 1;
    loser = 0;
  }
  _match->winner = winner;
  _match->loser = loser;
  
  // zwyciêzca ma zawsze 3 sety
  _match->sets_won[winner] = sets[winner] = 3;
  _match->sets_won[loser] =  sets[loser] = myrand(28)/10; // przegrany ma do 2ch
  // iloœæ rozegranych setów - suma powy¿szych
  _match->sets_played = sets[winner]+sets[loser];
  current_set = 0;

  // podczas gdy jeszcze s¹ jakieœ sety do wylosowania
  while (sets[winner] || sets[loser])
  {
    if (sets[winner] && sets[loser]) // je¿eli maj¹ oba jeszcze niewylosowane sety
    {
     if (myrand(1)) // wylosuj kto jest zwyciêzca tego seta
     {
       set_winner = loser;
       set_loser = winner;
     }
     else
     {
       set_winner = winner;
       set_loser = loser;
     }
    } else
    if (sets[winner]) //jak przegrany nie ma 
    {
      set_winner = winner;
      set_loser = loser;
    }
    else // jak wygrany nie ma
    {
       set_winner = loser;
       set_loser = winner;
    }

   
    unsigned int loser_score,winner_score;
    loser_score = myrand(28) + 5; // przegrany mo¿e mieæ max 33 punkty

    // wygrany ma zawsze o 2 wiêcej, chyba ¿e  przegrany ma mniej ni¿ 24 to wtedy wygrany ma równo 25
    if (loser_score < 24)
    {
      winner_score = 25;
    }
    else
    {
      winner_score = loser_score + 2;
    }
    _match->score[current_set].Score[set_winner] = winner_score; 
    _match->score[current_set].Score[set_loser] = loser_score;
    _match->score[current_set].winningTeam = set_winner;
    sets[set_winner]--; // zmniejsz zwyciêzcy iloœæ setów do wygrania
    current_set++; // zwiêksz aktualny set
  }
}


void EuroLeague::MatchOver(unsigned char sets,SetStruct *result)
{
  // mecz sie rozegra³
  mMatchPlayed= true;
  //polfinal
  char one,zero;
  // ustaw kolejnoœæ zespo³ów w strukturze result
  if (this->mSwappedMatch)
  {
   one = 0;
   zero = 1;
  }
  else
  {
    zero = 0;
    one =1;
  }
  //je¿eli nie jest fina³
  if (mCurrentWeekend < 6)
  {
    // pobierz aktualny mecz
    match *temp = &mWeekends[mCurrentPool][mCurrentWeekend].matches[mCurrentMatch];
    temp->sets_played = sets ;// ustaw mu iloœæ setów
    char wins = 0;

    for (int i = 0 ; i < temp->sets_played; i++)
    {// ustaw wyniki i okreœl zwyciêzce
      temp->score[i].Score[0] = result[i].Score[zero]; 
      temp->score[i].Score[1] = result[i].Score[one];
      temp->score[i].winningTeam = result[i].winningTeam ? one : zero;
      temp->sets_won[temp->score[i].winningTeam]++;
      wins += temp->score[i].winningTeam ? 1 : -1;
    }
    temp->winner = (wins > 0 ) ? 1 : 0;
    temp->loser  = (wins > 0 ) ? 0: 1;
    mCurrentPool++; // zwiêksz pule ¿eby nastêpnym razem nie wybraæ tego samego meczu
  }
  else
  {
     match *temp = &mFinals[mFinalStage][mCurrentMatch];
     temp->sets_played = sets ;//< 5 ? sets + 1 : 5;
     char wins = 0;
     for (int i = 0 ; i < temp->sets_played; i++)
     {
       temp->score[i].Score[0] = result[i].Score[zero]; 
       temp->score[i].Score[1] = result[i].Score[one];
       temp->score[i].winningTeam = result[i].winningTeam ? one : zero;
       temp->sets_won[temp->score[i].winningTeam]++;
       wins += temp->score[i].winningTeam ? 1 : -1;
     }
     temp->winner = (wins > 0 ) ? 1 : 0;
     temp->loser  = (wins > 0 ) ? 0: 1;
     mCurrentMatch++;
  }
  //final
}

// oblicz miejsce w rankingu

void EuroLeague::CalcRanking()
{
  if (mCurrentWeekend < 6) // je¿eli jesteœmy w pó³finale
  {
    for (int i = 0 ; i < 2 ; i ++)
      for (int j = 0 ; j < mCurrentWeekend+1; j++)
        for (int k = 0; k < 4 ;k ++)
        {
          match *temp = &mWeekends[i][j].matches[k];
          for (int m = 0 ; m < 4; m++)
          {
            eTeams curTeam = this->mPools[i][m];
            // obliczaj ranking tylko z meczy z udzia³em danego zespo³u
            if (temp->teams[0] != curTeam &&
                temp->teams[1] != curTeam) continue;
            // mecze s¹ mapowane 1/0 wiêc trzeba zrobiæ mapowanie do tego
            unsigned char thisTeam = temp->teams[0] == curTeam ? 0 : 1;
            unsigned char otherTeam =  temp->teams[0] == curTeam ? 1 : 0;
            if (temp->winner == thisTeam)
              this->mCurrentRanking[i][mCurrentWeekend][m].matches_won++;// zwiêksz iloœæ zwyciêstw
            else
              this->mCurrentRanking[i][mCurrentWeekend][m].matches_lost++; // zwiêksz iloœæ przegranych
            for (int n = 0; n < temp->sets_played; n++)
            {
              if (temp->score[n].winningTeam == thisTeam)
                this->mCurrentRanking[i][mCurrentWeekend][m].sets_won++; // /ilosc wygranych setów
              else
                this->mCurrentRanking[i][mCurrentWeekend][m].sets_lost++; //iloœæ przegranych setów
              // iloœæ puntów zdobytych
              this->mCurrentRanking[i][mCurrentWeekend][m].points_won += temp->score[n].Score[thisTeam];  
              // iloœæ punktów przegranych
              this->mCurrentRanking[i][mCurrentWeekend][m].points_lost += temp->score[n].Score[otherTeam];
            }
          }
        }

    for (int i = 0 ; i < 2 ; i ++)
    {
      for (int j = 0 ; j < 4 ; j++)
        this->mCurrentRanking[i][mCurrentWeekend][j].team  = this->mPools[i][j];
// posortuj - definicja w WorldLeague.cpp
      qsort(this->mCurrentRanking[i][mCurrentWeekend],4,sizeof(ranking),&qsort_func);
    }
  }
}
E:\Project\Kopia (5) VBEngine\Core\EuroLeague.h
#ifndef EUROLEAGUE_H
#define EUROLEAGUE_H


#include "LeagueStructs.h"

class EuroLeague :public Singleton<EuroLeague>
{
  // jakie zespo³y s¹ w której puli
  eTeams mPools[2][4];
  // wszystkie mecze w fazie przed fina³em
  weekend mWeekends[2][6];
  // aktualny weekend - je¿eli nie ma fina³u < 6
  unsigned char mCurrentWeekend;
  // zespó³ gracza
  eTeams mPlayerTeam;
  // aktualny mecz ( ma znaczenie przez ca³y czas)
  unsigned char mCurrentMatch;
  // aktualna pula - ma tylko sens przed fina³em
  unsigned char mCurrentPool;
  // mecze fina³owe
  match mFinals[3][2];
  // faza w finale 
  unsigned char mFinalStage;
  // ranking przedfina³owy
  ranking mCurrentRanking[2][6][4];
  // czy by³ ju¿ rozegrany jeden mecz
  bool mMatchPlayed;
  // czy aktualny mecz jest "obrócony" tzn czy zespó³ gracza w ustawieniu jest drugi
  bool mSwappedMatch;
  
public:
  
  EuroLeague(eTeams player_team);
  ~EuroLeague() 
  {
   int i = 0;
  };
  // pobierz nastêpny mecz - obs³uguje ca³¹ logike wyboru spotkania
  match *GetNextMatch();
  // oblicz ranking
  void CalcRanking();
  // pobierz zespó³ zajmuj¹cy dan¹ pozycje w rankingu danej puli
  ranking *GetTeamByRanking(unsigned int pool,unsigned int rank)  {return &this->mCurrentRanking[pool][mCurrentWeekend-1][rank];}
  // pobierz aktualny weekend
  unsigned char GetCurrentWeekend() {return mCurrentWeekend;}
  // zakoñcz mecz i zapisz wyniki meczu w tabeli
  void MatchOver(unsigned char sets,SetStruct *result);
  // wylosuj jakieœ wyniki dla danego meczu
  void RandomiseScore(match *_match);
  // pobierz mecz przez parametry (u¿ywane przy wyœwietlaniu drabinki)
  match *GetMatchByParams(unsigned char pool, unsigned char weekend, unsigned char match) { return &mWeekends[pool][weekend].matches[match];} 
  // czy jakiœ mecz zosta³ ju¿ rozegrany
  bool WasMatchPlayed() {return mMatchPlayed;}
  // czy mecz jest "obrócony"
  bool IsMatchSwapped() {return mSwappedMatch;}
  // pobierz aktualny mecz
  unsigned char GetCurrentMatch() {return mCurrentMatch;}
  // pobierz aktualn¹ faze fina³ow¹
  unsigned char GetFinalStage() {return mFinalStage;}
  // pobierz mecz fina³owy
  match *GetFinalMatch(unsigned char p, unsigned char m) {return &mFinals[p][m];}
}; 

#endif 
E:\Project\Kopia (5) VBEngine\Core\Game.cpp
#include "..\config.h"

#include <assert.h>
#include <memory.h>

#include "..\utility\Misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\Logger.h"
#include "..\utility\VBmath.h"
#include "..\utility\Tools.h"
#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\utility\CTime.h"
#include "..\utility\conf.h"

#include "..\graphics\meshmanager.h"
#include "..\graphics\animation.h"
#include "..\graphics\animationmanager.h"
#include "..\graphics\SceneObject.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\Stadion.h"
#include "..\graphics\GUI.h"

#include "..\Ai\state.h"
#include "..\Ai\States\StateIdle.h"
#include "..\Ai\Tactic.h"
#include "..\Ai\TacticManager.h"

#include "..\Core\zawodnik.h"

#include "User.h"
#include "UserManager.h"
#include "SetupManager.h"

#include "Team.h"
#include "Ball.h"
#include "game.h"


const char *TeamName[] = 
{
  "Brazil",
  "Greece",
  "Spain",
  "Portugal",
  "France",
  "Bulgaria",
  "Japan",
  "Poland",
  "Italy",
  "China",
  "Serbia",
  "Cuba",
  "Russia",
  "Czech",
  "Croatia",
  "Turkey",
  "Germany",
  "Holland",
  "Finland",
  "Slovakia"
};



CGame::CGame(char *team0, char *team1 , bool ai,int stadion,bool swapped) : EventHandler(ET_GAME)
{
  // czy koszulki zespo³ów s¹ z nazwiskami czy bez
  bool GenShirts = false;
  char buffer[MAX_FILE_NAME];
  mGamePhase = GP_LIGHTS;
  this->mServingTeam = TEAM_0;
  
  this->mSetOverDelay = false;
  memset(this->Set,0,sizeof(Set));
  this->mCurrentSet = 0;

  this->rotatedTeam = TEAM_1;

  this->RotatedIn5Set = false;
  this->mServeChange = false;

  {
    ConfFile config;
    my_snprintf(buffer, MAX_FILE_NAME, "%s%s", DataPath, "game.dat");
    if (SUCCEEDED(config.Init(buffer)))
    {
      int tmp = 0;
      config.GET_INT("GENERATE_SHIRTS",&tmp);
      GenShirts = tmp == 1;
    }
    config.DeInit();
  }

  //stwórz oba zespo³y
  this->Team[0] = new CTeam(team0, TEAM_0, GenShirts);
  this->Team[1] = new CTeam(team1, TEAM_1, GenShirts);
// i ustaw im ai

#ifndef DEMO
  this->Team[0]->SetAi(false);
  this->Team[1]->SetAi(ai);
#else
  this->Team[0]->SetAi(true);
  this->Team[1]->SetAi(true);
#endif

  

  // jeœli stadion nie jest ustawiony
  if (stadion == -1)
  {
    if (swapped) // dla meczów "obróconych"
    {// pobierz stadion z datów
      stadion = this->Team[1]->GetHomeStadium();
    }
    else
    {
      stadion = this->Team[0]->GetHomeStadium();
    }
  }

  // i wczytaj go
  my_snprintf(buffer, 64, "stadion_%d.dat", stadion);
  this->pStadion = new CStadion(buffer);
  
  this->pTarget  = new CTarget();
  this->pTarget->Hide();
  this->pBall = new CBall();
  
  this->pSiatka  = new CSiatka("stadion1\\siatka.x");
    
  new CArrow(); // strza³ka serwów
  new CTargetPrzebicia(); // celownik
  new CBlocker(); // bloker - nie dzia³a ale jest

  // sêdziowie
  this->mSedzia = new CSedzia();
  this->mSedziaStojacy = new CSedziaStojacy();
  this->mSedziowieLiniowi[0] = new CSedziaLiniowy(false);
  this->mSedziowieLiniowi[1] = new CSedziaLiniowy(true);

  this->mPublikaPlaying = false;
  this->mIsMatchOver = false;
  this->mIsSetOver = false;
  //ustaw kamere na domyœln¹
  SceneManager::Instance()->GetCamera()->ChangeCamera(0);
}

CGame::~CGame()
{
  // wy³¹cz wreszcie publike 
  POST_EVENT2(ET_AUDIO, MUSIC_0,0,true, NULL);
  delete CBlocker::Instance();
  delete CArrow::Instance();
  delete CTargetPrzebicia::Instance();
  delete Team[0];
  delete Team[1];
  delete pSiatka;
  delete pTarget;
  delete pStadion;
  delete pBall;
//  delete Tactics;
  delete mSedzia;
  delete this->mSedziaStojacy;
  delete this->mSedziowieLiniowi[0];
  delete this->mSedziowieLiniowi[1];
}
#ifdef DEBUG  
char *StrGamePhase[] = 
{
  "GP_TEAM_0_SERVING\n",
  "GP_TEAM_1_SERVING\n",
  "GP_GAMEPLAY\n",
  "GP_LIGHTS\n"
};
#endif 

void CGame::Update()
{
  // wywo³ane za pierwsz¹ iteracj¹ 
  if (!mPublikaPlaying)
  {
    // puœæ dŸwiêk publiki
    POST_EVENT2(ET_AUDIO, MUSIC_0,1, false, NULL);
    POST_EVENT(ET_AUDIO, EFFECT_0, false, NULL);
    mPublikaPlaying = true;
  }
#ifdef DEBUG  
  Logger::Instance()->LogToScreen(StrGamePhase[mGamePhase]);
#endif  
  this->Team[0]->Update();
  this->Team[1]->Update();
  this->pBall->Update();
  this->pStadion->Update();
  this->pSiatka->Update();
}

void CGame::ProcessEvent(Event *event)
{
  switch (event->mID)
  {// wysy³ane jak pi³ka przelatuje nad siatk¹
    case GE_BALL_PASS_OVER:
      if (CBall::Instance()->GetTargetPosition()->y > 0.0f)
      {
        mSedziaStojacy->GotoRight(); // sêdzia ma "œledziæ" pozycje pi³ki
      }
      else
      {
        mSedziaStojacy->GotoLeft();
      }
    break;
    case GE_TEAM0_CHANGE_TACTIC:       
      if(mGamePhase != GP_GAMEPLAY || CBall::Instance()->GetTeamOwner() == TEAM_1)
      {
        //this->Team[TEAM_0]->SetCurrentTactic(this->Tactics->GetCurrent());
        this->Team[TEAM_0]->ResetPositions();
      }
    break;
    case GE_TEAM1_CHANGE_TACTIC:
      if (mGamePhase != GP_GAMEPLAY|| CBall::Instance()->GetTeamOwner() == TEAM_0)
      {
        //this->Team[TEAM_1]->SetCurrentTactic(this->Tactics->GetTactic(myrand(MAX_TACTIC-1)));
        this->Team[TEAM_1]->ResetPositions();
      }
    break;
    case GE_BREAK_LIGHTS:
    { 
      if (this->mIsMatchOver) return; // nie przerywaj jak jest ju¿ koniec meczu

      if (this->mIsSetOver && TestForGameOver()) 
        // je¿eli set sie skoñczy³ i okazuje sie ¿e mecz te¿ sie powinien
        // skoñczyæ - to go skoñcz
      { 
        DoGameOver();
        return;
      }
      // je¿eli set sie skoñczy³ a jeszcze nie wyœwietlamy panelu "set over" 
      // to wyœwietlajmy
      if (this->mSetOverDelay)
      {
        this->mSetOverDelay = false;
        this->mIsSetOver = true;
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+10.0f, NULL);
        return;
      }
      // je¿eli jest menu w czasie gry w³¹czone olewamy te ewenty
      if (!GUI::Instance()->CanBrakeLights()) return;
      // tak samo jak w ogóle w œwiate³kach nie jesteœmy
      if (mGamePhase != GP_LIGHTS) return;
      // jeœli jest pi¹ty set i mamy ju¿ 8 punktów to  rotacja
      if (ShouldChangeSides())
      {
        this->mServeChange = false;
        this->RotatedIn5Set = true;
        pSiatka->SwitchOrientation();
        pStadion->SwitchOrientation();
        this->mSedzia->SwitchOrientation();
        this->mSedziaStojacy->SwitchOrientation();
        this->rotatedTeam = this->rotatedTeam ? TEAM_0 : TEAM_1;
        this->Team[TEAM_0]->RotateSubs();
        this->Team[TEAM_1]->RotateSubs();
      }
      // je¿eli mamy koniec seta to go koñczymy
      if (this->mIsSetOver)
      {
        this->mIsSetOver = false;
        this->mServingTeam = this->Set[mCurrentSet].winningTeam = GetSetWinner();
        this->mServeChange = false;
        EndSet();
      }
#ifndef DEMO
      // organy ;P
      POST_EVENT((/*ET_AUDIO |*/ ET_STADION), EFFECT_4, false, NULL);
#else
      POST_EVENT((ET_AUDIO | ET_STADION), EFFECT_4, false, NULL);
#endif
      // zmiana serwów - rotacja zawodników z nowego zespo³u serwuj¹cego
      if(this->mServeChange)
      {
        this->Team[this->mServingTeam]->RotatePlayers();
        this->mServeChange = false;
      }
  
      // pi³ki i tak na razie nie potrzebujemy 
      this->pBall->RemoveFromWorld();

      // ustawiaj faze gry i sêdziów 
      if (mServingTeam == TEAM_0)
      {
        mGamePhase = GP_TEAM_0_SERVING;
        mSedzia->ZezwalajZagrywkaLeft();
        mSedziaStojacy->GotoRight();
      }
      else
      {
        mGamePhase = GP_TEAM_1_SERVING;
        mSedzia->ZezwalajZagrywkaRight();
        mSedziaStojacy->GotoLeft();        
      }
 
      // ustaw parametry serwowania i zresetuj ustawienia
      this->Team[this->mServingTeam]->MakeServing();
      this->Team[TEAM_0]->ResetPositions();
      this->Team[TEAM_1]->ResetPositions();


      // hak a¿ tylko p³akaæ - ustawianie zawodnika z pozycji 2 na serwach
      for(unsigned int i = 0; i < MAX_PLAYERS_IN_TEAM; i++)
      {
        if(this->Team[mServingTeam]->GetPlayer(i)->GetPosOnField() == POS_2)
        {
          this->Team[mServingTeam]->GetPlayer(i)->SetPosOnField(POS_ZAGRYWKA);
          this->Team[mServingTeam]->GetPlayer(i)->SetGotoPosition(POS_ZAGRYWKA);          
          this->Team[mServingTeam]->SetPlayerToZeroPriority(this->Team[mServingTeam]->GetPlayer(i));
          break;
        }
      }
      
    }
  break;
  case  GE_BALL_TARGET       :
    { // ustaw cel wyl¹dowania pi³ki i go poka¿
      mGamePhase = GP_GAMEPLAY;
      pTarget->GetPosition()->Set((CVector3*)(event->mData));
      // sprawdzic czy stan gry pozwala!
      pTarget->Show();
      return;
    }
  case GE_BALL_HIT_NET       :
    { // przeœlij dane do falowania siatki do obiektu siatki
      NetHitStruct *NHS =(NetHitStruct *) event->mData; 
      this->pSiatka->RegisterHit(NHS->time,&NHS->position,&NHS->velocity);
      // je¿eli pi³ki nie ma w œwiecie to nie ma sensu iœæ dalej
      // tak samo jak s¹ œwiate³ka 
      if (mGamePhase == GP_LIGHTS || !CBall::Instance()->IsInWorld()) return;

      if(!(this->Team[CBall::Instance()->GetTeamOwner()]->IsServing() ||
           this->Team[CBall::Instance()->GetTeamOwner()]->GetHits() > 2)) return;

      // zresetuj grafike
      CTargetPrzebicia::Instance()->Hide();
      CBlocker::Instance()->Hide();
      GUI::Instance()->HidePowerBar();
      mSedziaStojacy->GotoHint();
      pTarget->Hide();

      // zlicz punkty 
      if (CBall::Instance()->GetTeamOwner() == TEAM_0)
      {
        if (mServingTeam == TEAM_0)
        {
          this->mServingTeam = TEAM_1;
          this->mServeChange = true;
        }
        Set[mCurrentSet].Score[TEAM_1]++; 
        mSedzia->WygranaAkcjaRight(); 
      }
      else
      {
        if (mServingTeam == TEAM_1)
        {
          this->mServingTeam = TEAM_0;
          this->mServeChange = true;
        }
        Set[mCurrentSet].Score[TEAM_0]++; 
        mSedzia->WygranaAkcjaLeft();
      }
      this->Team[0]->ResetSettins();
      this->Team[1]->ResetSettins();
      //przejdŸ do œwiate³ek
      mGamePhase = GP_LIGHTS;
      // puœæ dŸwiêki
      if (SetupManager::Instance()->GetVideo()->crawd)
      {
        POST_EVENT(ET_AUDIO, EFFECT_3, false, NULL);
      }
      if (SetupManager::Instance()->GetSound()->ball)
      {
        POST_EVENT(ET_AUDIO, WAV_0, false, NULL);
      }
     // jak sie set skoñczy³ to opóŸnij o 3 sekundy wyœwietlanie panelu 
     if (this->IsSetOver())
      {
        this->mSetOverDelay = true;
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+3.0f, NULL);
      }
      else
      {
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+5.0f, NULL);
      }
      return;
    }
  case GE_BALL_PASS_UNDER_NET:
    {
      if (mGamePhase == GP_LIGHTS || !CBall::Instance()->IsInWorld()) return;
      GUI::Instance()->SetGamePhase(-1);
      CTargetPrzebicia::Instance()->Hide();
      CBlocker::Instance()->Hide();
      GUI::Instance()->HidePowerBar();
      mSedziaStojacy->GotoHint();
      if (CBall::Instance()->GetTeamOwner() == TEAM_0)
      {
        if (mServingTeam == TEAM_0)
        {
          this->mServingTeam = TEAM_1;
          this->mServeChange = true;
        }
        Set[mCurrentSet].Score[TEAM_1]++; 
        mSedzia->WygranaAkcjaRight();
      }
      else
      {
        if (mServingTeam == TEAM_1)
        {
          this->mServingTeam = TEAM_0;
          this->mServeChange = true;
        }
        Set[mCurrentSet].Score[TEAM_1]++; 
        mSedzia->WygranaAkcjaLeft();
      }
      this->Team[0]->ResetSettins();
      this->Team[1]->ResetSettins();
      mGamePhase = GP_LIGHTS;
      pTarget->Hide();
      if (SetupManager::Instance()->GetVideo()->crawd)
      {
        POST_EVENT(ET_AUDIO, EFFECT_2, false, NULL);
      }
      if (this->IsSetOver())
      {
        this->mSetOverDelay = true;
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+3.0f, NULL);
      }
      else
      {
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+5.0f, NULL);
      }
      return;
    }
  case GE_BALL_HIT_FLOOR     :
    {
      if (mGamePhase == GP_LIGHTS || !CBall::Instance()->IsInWorld()) return;
      mSedziaStojacy->GotoHint();
      if (this->IsPointOut(CBall::Instance()->GetBallStartPosition()))
      {
        mSedzia->Out();
        if (CBall::Instance()->GetBallStartPosition()->y > 0.0f)
        {
          this->mSedziowieLiniowi[0]->Out();
        }
        else
        {
          this->mSedziowieLiniowi[1]->Out();
        }
      }
      else
      {
        if (CBall::Instance()->GetBallStartPosition()->y > 0.0f)
        {
          this->mSedziowieLiniowi[0]->PilkaWBoisko(); 
        }
        else
        {
          this->mSedziowieLiniowi[1]->PilkaWBoisko(); 
        }
      }
      int ScoringTeam,LosingTeam;
      
      ScoringTeam = CBall::Instance()->GetTeamOwner();
      if (!Team[ScoringTeam]->IsWorldPointInTheOtherField(CBall::Instance()->GetBallStartPosition()))
      {
        ScoringTeam = ((ScoringTeam == TEAM_0) ? TEAM_1 : TEAM_0); 
      }
      
      if(ScoringTeam == TEAM_0)
      {
        mSedzia->WygranaAkcjaLeft();
        LosingTeam = TEAM_1;
      }
      else
      {
        mSedzia->WygranaAkcjaRight();
        LosingTeam = TEAM_0;
      }
      Set[mCurrentSet].Score[ScoringTeam]++; 

      if (mServingTeam == LosingTeam)
      {
        this->mServingTeam = ScoringTeam;
        this->mServeChange = true;
      }
     

      GUI::Instance()->SetGamePhase(-1);
      CTargetPrzebicia::Instance()->Hide();
      GUI::Instance()->HidePowerBar();
      CBlocker::Instance()->Hide();
     
      this->Team[0]->ResetSettins();
      this->Team[1]->ResetSettins();
      mGamePhase = GP_LIGHTS;
      pTarget->Hide();

      if (SetupManager::Instance()->GetVideo()->crawd)
      {
        POST_EVENT(ET_AUDIO, EFFECT_1, false, NULL);
      }

      if (this->IsSetOver())
      {
        this->mSetOverDelay = true;
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+3.0f, NULL);
      }
      else
      {
        POST_EVENT3(ET_GAME, GE_BREAK_LIGHTS , NOW+5.0f, NULL);
      }
      return;
    }
  }
}

int CGame::GetTeamForUser(unsigned int userMask)
{
  if ( userMask & ET_USER_1_INPUT )
    return ET_TEAM_0;

  if ( userMask & ET_USER_2_INPUT )
    return ET_TEAM_1;

  return 0;
}


bool CGame::IsPointOut(CVector3 *pt)
{
  if (pt->x >  4.5f) return true;
  if (pt->x < -4.5f) return true;
  if (pt->y >  9.0f) return true;
  if (pt->y < -9.0f) return true;
  return false;
}

void CGame::EndSet()
{
  mCurrentSet++;
// obróæ stadion zamiast obracaæ zawodników
  pSiatka->SwitchOrientation();
  pStadion->SwitchOrientation();
  this->mSedzia->SwitchOrientation();
  this->mSedziaStojacy->SwitchOrientation();
  this->rotatedTeam = this->rotatedTeam ? TEAM_0 : TEAM_1;
  // obróæ rezerwowcyh w zespole
  this->Team[TEAM_0]->RotateSubs();
  this->Team[TEAM_1]->RotateSubs();
}

bool CGame::IsSetOver()
{// sprawdzanie koñca seta
#ifndef DEMO
#define TIEBREAK 14
#define SETOVER  24
#else
#define TIEBREAK 2
#define SETOVER  5
#endif

  if (mCurrentSet == 4)
  {// je¿eli w secie pi¹tym któryœ z zespo³ów ma minimum 15
    if ( (Set[mCurrentSet].Score[TEAM_0] > TIEBREAK ||
          Set[mCurrentSet].Score[TEAM_1] > TIEBREAK ) &&
          ABS(Set[mCurrentSet].Score[TEAM_0] - Set[mCurrentSet].Score[TEAM_1]) > 1)// i ró¿nice 2
    {
      return true; // to koniec seta
    }
    else
    {
      return false;
    }
  }// takie samo sprawdzenie dla ka¿dego innego seta
  if ( (Set[mCurrentSet].Score[TEAM_0] > SETOVER ||
        Set[mCurrentSet].Score[TEAM_1] > SETOVER ) &&
        ABS(Set[mCurrentSet].Score[TEAM_0] - Set[mCurrentSet].Score[TEAM_1]) > 1)
  {
    return true;
  }
  else
  {
    return false;
  }
#undef TIEBREAK
#undef SETOVER
}

unsigned char CGame::GetSetWinner()
{
  // pobierz zwyciêzce seta - sprawdzaæ tylko po IsSetOver
  if (Set[mCurrentSet].Score[TEAM_0] > Set[mCurrentSet].Score[TEAM_1] )
    return 0;
  else
    return 1;
}
bool CGame::ShouldChangeSides()
{
  // sprawdzenie czy trzeba sie obróciæ w 5 secie
  if (mCurrentSet != 4) return false;
  if (this->RotatedIn5Set) return false;
  if (Set[mCurrentSet].Score[TEAM_0] > 7) return true;    
  if (Set[mCurrentSet].Score[TEAM_1] > 7) return true;
  return false;
}

bool CGame::TestForGameOver()
{ // sprawdzanie czy jest koniec gry
  int team0score = 0;
  int team1score = 0;
 // sprawdŸ zwyciêzców poprzednich setów
  for (int i = 0 ; i < mCurrentSet; i++)
  {
    if (Set[i].winningTeam) 
      team1score++;

    else
      team0score++;
  }
  // dodaj zwyciêzce aktualnego
  if (GetSetWinner()) 
    team1score++;
  else
    team0score++;
  //jeœli któyœ ma powy¿ej 2 to wygraj mecz
  if (team0score > 2 )
  {
    return true;
  }
  if (team1score > 2 )
  {
    return true;
  }
  return false;
}

void CGame::DoGameOver()
{ 
  mIsSetOver = false;
  mIsMatchOver = true; // flaga pokazywania panelu
  // opóŸnij koniec gry ¿eby chocia¿ coœ z panelu zobaczyæ
  POST_EVENT3(ET_GLOBAL,GEID_END_GAME,NOW+10.0f,NULL);
  int team0score = 0;
  int team1score = 0;
  // oblicz wyniki meczu
  this->Set[mCurrentSet].winningTeam = GetSetWinner();
  mCurrentSet++;
  for (int i = 0 ; i < mCurrentSet; i++)
  {
    if (Set[i].winningTeam) 
      team1score++;
    else
      team0score++;
  }
  
  assert(team1score < 4 && team0score < 4 );
  //ustaw zwyciêzce
  if (team0score > team1score)
  {
    mMatchWinner = TEAM_0;   
  }
  else
  {
    mMatchWinner = TEAM_1;
  }    
}


//#ifdef DEBUG
#if defined(DEBUG) || defined(DEMO)

void CGame::CheatLoseMatch()
{
  this->mCurrentSet = 3;
  for (int i = 0; i < 3 ; i++)
  {
    this->Set[i].Score[0] = 0;
    this->Set[i].Score[1] = 25;
    this->Set[i].winningTeam = 1;
  }
  DoGameOver();
}



void CGame::CheatWinMatch()
{
  this->mCurrentSet = 3;
  for (int i = 0; i < 3 ; i++)
  {
    this->Set[i].Score[1] = 0;
    this->Set[i].Score[0] = 25;
    this->Set[i].winningTeam = 0;
  }
  DoGameOver();

}

#endif


E:\Project\Kopia (5) VBEngine\Core\game.h
#ifndef _GAME_H
#define _GAME_H

/*
class       :
description :

methods     :

*/


// faza gry
enum GamePhase
{
  GP_TEAM_0_SERVING, //serwy zespołu 0
  GP_TEAM_1_SERVING, // serwy zespołu 1
  GP_GAMEPLAY,       // normalna gra
  GP_LIGHTS          // "wiatełka" - czas po zdobyciu punktu
};

class CTeam;
class CStadion;
class CBall;
class CSiatka;
class CTarget;
class CSedzia;
class CSedziaStojacy;
class CSedziaLiniowy;



class CGame : public Singleton<CGame> , EventHandler//EventManager
{
  // Obiekty zespołów bioršcych udział w grze
  CTeam *Team[MAX_TEAM];
  // stadion na którym mecz sie rozgrywa
  CStadion *pStadion;
  // piłka
  CBall *pBall;
  // siatka
  CSiatka *pSiatka;
  // cel upadku piłki
  CTarget *pTarget;
  //sedzia główny - ten na krzesełku
  CSedzia *mSedzia;
  //sedzia stojšcy pod siatkš
  CSedziaStojacy *mSedziaStojacy;
  // sędziowie liniowi
  CSedziaLiniowy *mSedziowieLiniowi[2];
  // faza gry - najważniejsza (i praktycznie jedynie sprawdzana jest GP_LIGHTS
  GamePhase mGamePhase;
  // który zespół serwował ostatnio
  int mServingTeam;
  // czy jest potrzebna zmiana serwów
  bool mServeChange;
  // czy zespół już został obrócony w pištym secie

  bool RotatedIn5Set;
  // punkty i zwycięzcy każdego z setów
  SetStruct Set[5];
  // numer aktualnego seta - 1
  unsigned char mCurrentSet;
  // czy mecz sie skończył 
  bool mIsMatchOver;
  //zespół który jest obrócony względem wiata
  unsigned char rotatedTeam;
  //czy jest koniec seta
  bool mIsSetOver;
  // kto wygrał mecz
  unsigned char mMatchWinner;
  // czy publika "szaleje"
  bool mPublikaPlaying;
  // opónienie wywietlenia "set over" - hak na szykbo
  bool mSetOverDelay;
public:
  // konstruktor gry - parametry:
  // team0 - nazwa datu pierwszego zespołu
  // team1 - nazwa datu drugiego zespołu
  // ai - czy zespół numer dwa jest AI (pierwszy zawsze jest pod kontrolš)
  // stadion - na którym stadionie sš rozgrywki
  // swapped - czy mecz jest zamieniony ( hak - klasa User jest jeden do jednego mapowana na klase team)
  CGame(char *team0, char *team1, bool ai,int stadion,bool swapped);
  ~CGame();
  void Update();
  // ProcessEvent - odziedziczone z EventTarget
  void ProcessEvent(Event *event);
  // pobranie zespołu dla usera - nie używane
  int GetTeamForUser(unsigned int userMask);
  // ustawianie fazy gry - nie używane
  void SetPhase(GamePhase gp) {mGamePhase = gp;};
  // pobranie zespołu serwujšcego - nie używane
  int GetServingTeam() {return mServingTeam;};
  // pobranie fazy gry
  GamePhase GetGamePhase() {return mGamePhase;}
  // czy dany punkt jest na aucie
  bool IsPointOut(CVector3 *pt);
  // skończ set
  void EndSet();
  // wyznacz zwycięzce seta
  unsigned char GetSetWinner();
  // sprawd czy setr sie skońćzył
  bool IsSetOver();
  // czy poinni sie zamienić stronami w pištym secie
  bool ShouldChangeSides();
  // sprawd czy jest koniec meczu
  bool TestForGameOver();
  // skończ mecz
  void DoGameOver();
  // pobierz zespół który jest obrócony
  unsigned char GetRotatedTeam() {return this->rotatedTeam;}
 
  // pobierz aktualny set
  unsigned char GetCurrentSet() {return mCurrentSet;}
  // pobierz wyniki meczu
  SetStruct *GetSetScores() {return Set;}
  // czy powinien wywietlać koniec seta
  bool ShouldDisplaySetOver() {return mIsSetOver;}
  // czy powinien wywietlać koniec meczu
  bool ShouldDisplayMatchOver() {return mIsMatchOver;}
  //pobierz nazwe zespołu
  char *GetTeamName(unsigned char team) { return this->Team[team]->GetTeamName() ; } 
  // pobierz trzyliterowy skrót zespołu
  char *GetTeamShortName(unsigned char team) { return this->Team[team]->GetTeamShortName(); } 
  // czy mecz sie skończył
  bool IsMatchOver() {return mIsMatchOver;}
  // czy dany zespół jest ai
  bool IsTeamAI(unsigned char team) {return this->Team[team]->IsAi();};
  // pobierz zespół o danym numerze (0-1)
  CTeam *GetTeam(int team) {return this->Team[team];};

#if defined(DEBUG) || defined(DEMO)
  void CheatWinMatch();
  void CheatLoseMatch();
#endif

};

#endif
E:\Project\Kopia (5) VBEngine\Core\LeagueStructs.h
#ifndef LEAGUESTRUCTS_H
#define LEAGUESTRUCTS_H


struct match
{
  eTeams teams[2];
  unsigned char sets_played;
  SetStruct score[5];
  unsigned char winner,loser;
  unsigned char sets_won[2];
};

struct weekend
{
  match matches[4];
};

struct ranking
{
  eTeams team;
  unsigned char matches_won;
  unsigned char matches_lost;
  unsigned char sets_won;
  unsigned char sets_lost;
  unsigned short points_won;
  unsigned short points_lost;
};

extern unsigned char matchMap[6][4];
float SkillTweaks[];


//sorting func

int qsort_func(const void * _key, const void *_val);

#endif 
E:\Project\Kopia (5) VBEngine\Core\SetupManager.cpp
#include "..\config.h"

//#include <Windows.h>
#include <assert.h>
#include <d3dx9effect.h>
#include <dinput.h>
#include <stdio.h>
//#include "
#include "..\utility\Misc.h"
#include "..\utility\defines.h"
#include "..\utility\Singleton.h"
#include "..\utility\vbmath.h"
#include "..\utility\ctime.h"
#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\Utility\logger.h"
#include "..\Utility\Tools.h"

#include "..\graphics\renderer.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\GUI.h"


#include "..\audio\AudioManager.h"
#include "..\graphics\meshmanager.h"

//#include "..\input\Mapper.h"
//#include "..\input\input.h"

#include "Team.h"
#include "game.h"

#include "SetupManager.h"


const struct RES _WH[] = { {800,600}, {1024,768}, {1280,960} };

SetupManager::SetupManager()
{
  FILE *in;
  this->WH = _WH;
  if(NULL == (in = fopen("setup.dat", "rb")))
  {
  this->sound.music_volume =100;
  this->sound.effect_volume = 100;
  this->sound.fx_volume = 100;
  this->sound.ball = true;
  this->sound.referee = true;
  this->sound.peoples = true;
  this->sound.menu = true;

  this->video.res = R1024x768;
  this->video.texture_level = 2;
  this->video.graphic_level = 2;
  this->video.crawd = true;
  this->video.referees = true;
  this->video.reflections = true;
  }
  else
  {
    fread(&this->sound, sizeof(struct SOUND), 1, in);
    fread(&this->video, sizeof(struct VIDEO), 1, in);
    fclose(in);
  }

}

SetupManager::~SetupManager()
{
  FILE *out;
  if(NULL != (out = fopen("setup.dat", "wb")))
  {
    fwrite(&this->sound, sizeof(struct SOUND), 1, out);
    fwrite(&this->video, sizeof(struct VIDEO), 1, out);
    fclose(out);
  }
}

void SetupManager::Init(void)
{
  CAudioManager::Instance()->SetVolume(this->sound.effect_volume, false);
  CAudioManager::Instance()->SetVolume(this->sound.fx_volume, true);
  CAudioManager::Instance()->SetCDVolume( this->sound.music_volume );
}

bool SetupManager::UpdateSound(SOUND *snd)
{

  if(!CAudioManager::Instance()->IsInit()) return false;
  
  if(snd)
  {
    this->sound.peoples = snd->peoples;
    this->sound.ball = snd->ball;
    this->sound.referee = snd->referee;
    this->sound.menu = snd->menu;
  }

  if (CGame::Instance() && this->sound.peoples) 
  {
    if(!CAudioManager::Instance()->IsPlaing(MUSIC_0))
    {
      CAudioManager::Instance()->Play(MUSIC_0);

    }
  }
  else
  {
    if (CAudioManager::Instance()->IsPlaing(MUSIC_0))
    {
      CAudioManager::Instance()->Stop(MUSIC_0);
    }
  }

  if (this->sound.menu && !CGame::Instance()) 
  {
    if(!CAudioManager::Instance()->IsPlaing(MUSIC_1))
    {
      CAudioManager::Instance()->Play(MUSIC_1);
    }
  }
  else
  {
    if (CAudioManager::Instance()->IsPlaing(MUSIC_1))
    {
      CAudioManager::Instance()->Stop(MUSIC_1);
    }
  }

  if(!snd)
  {
    CAudioManager::Instance()->SetVolume(this->sound.effect_volume, false);
    CAudioManager::Instance()->SetVolume(this->sound.fx_volume, true);
    CAudioManager::Instance()->SetCDVolume( this->sound.music_volume );
    return true;
  }

  if(snd->effect_volume != this->sound.effect_volume)
  {
    this->sound.effect_volume = snd->effect_volume;
    CAudioManager::Instance()->SetVolume(this->sound.effect_volume, false);
  }
  if(snd->fx_volume != this->sound.fx_volume)
  {
    this->sound.fx_volume = snd->fx_volume;
    CAudioManager::Instance()->SetVolume(this->sound.fx_volume, true);
  }
  if(snd->music_volume != this->sound.music_volume)
  {
    this->sound.music_volume = snd->music_volume;
    CAudioManager::Instance()->SetCDVolume(this->sound.music_volume);
  }
  return true;
}

bool SetupManager::UpdateVideo(VIDEO *vid)
{
  if(!vid) return false;

  if (this->video.res != vid->res)
  {
    memcpy(&this->video, vid, sizeof(this->video));
    Renderer::Instance()->screen_h = WH[this->video.res].h;
    Renderer::Instance()->screen_w = WH[this->video.res].w;
    Renderer::Instance()->Reset();
    return true;
  }

  if (this->video.texture_level != vid->texture_level)
  {
    this->video.texture_level = vid->texture_level;
    CMeshManager::Instance()->ResetTM(this->video.texture_level);
  }

  if (this->video.graphic_level != vid->graphic_level)
  {
    this->video.graphic_level = vid->graphic_level;
    CMeshManager::Instance()->ResetSM(this->video.graphic_level);
  }

  if (this->video.reflections != vid->reflections)
  {
    this->video.reflections = vid->reflections;
    CMeshManager::Instance()->Reflection(this->video.reflections);
  }

  this->video.referees = vid->referees;
  this->video.crawd = vid->crawd;
  if(!this->video.crawd)
  {
    POST_EVENT(ET_STADION, EFFECT_4, false, NULL);
  }
  return true;
};
E:\Project\Kopia (5) VBEngine\Core\SetupManager.h
#ifndef _SETUPMANAGER_H
#define _SETUPMANAGER_H


/*
class       : SetupManager
description : 

methods     :          
            
*/
enum Resolution
{
  R800x600 = 0,
  R1024x768,
  R1280x960
};

struct VIDEO
{
  Resolution res;
  int texture_level;
  int graphic_level;
  bool reflections;
  bool referees;
  bool crawd;
}; 

struct SOUND
{
  int music_volume;/* percent */
  int effect_volume;/* percent */
  int fx_volume;/* percent */
  bool ball;
  bool referee;
  bool peoples;
  bool menu;
};

struct RES {
  unsigned int w,h;
};

class SetupManager : public Singleton<SetupManager>
{
  VIDEO video;
  SOUND sound;
  const struct RES *WH;
 public:
  SetupManager();
  ~SetupManager();
  void Init(void);
  VIDEO * GetVideo(void) {return &this->video; };
  SOUND * GetSound(void) {return &this->sound; };
  bool UpdateSound(SOUND *snd);
  bool UpdateVideo(VIDEO *vid);
  int GetW(void) {return this->WH[this->video.res].w;}
  int GetH(void) {return this->WH[this->video.res].h;}
};




#endif
E:\Project\Kopia (5) VBEngine\Core\Team.cpp
#include "..\config.h"

//#define NO_COLLISIONS


#include <assert.h>

#include "..\Utility\Misc.h"
#include "..\Utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\utility\CTime.h"

#include "User.h"
#include "UserManager.h"

#include "..\graphics\meshmanager.h"
#include "..\graphics\animation.h"
#include "..\graphics\animationmanager.h"

#include "..\graphics\SceneObject.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\Stadion.h"
#include "..\graphics\GUI.h"

#include "..\Ai\state.h"
#include "..\Ai\States\StateIdle.h"

#include "..\utility\defines.h"
#include "..\utility\conf.h"

#include "..\utility\logger.h"
#include "..\Utility\tools.h"

#include "..\Ai\StateManager.h"
#include "Ball.h"
#include "zawodnik.h"

#include "..\Ai\TacticManager.h"
#include "..\Ai\AStarSolver.h"

#include "Team.h"
#include "game.h"

#define MAX_CURRENT_DIR_VECTORS 8

//#define CHODZENIE

/* noralne dla kierunków chodzenia -> enum Direction */
CVector3 CurrentDirVector[MAX_CURRENT_DIR_VECTORS] = 
  {
    CVector3(0.0f,         -1.0f,        0.0f),
    CVector3(-0.70710678f, -0.70710678f, 0.0f),
    CVector3(-1.0f,         0.0f,        0.0f),
    CVector3(-0.70710678f,  0.70710678f, 0.0f),
    CVector3(0.0f,          1.0f,        0.0f),
    CVector3(0.70710678f,   0.70710678f, 0.0f),
    CVector3(1.0f,          0.0f,        0.0f),
    CVector3(0.70710678f,  -0.70710678f, 0.0f),
  };

const int DefBlockChanses[] = {100, 90, 80, 75, 50};

/* ================================================================================ */
/* ================================================================================ */
/* ================================================================================ */

CTeam::CTeam(char *teamname, TeamNumber teamNum, bool GenShirt) : EventHandler(0)
{  
  mCurrentPhase = 0;
  mTacticPhase[0] = 0;
  mTacticPhase[1] = 0;
  mTacticPhase[2] = 0;
  mHitCount = 0;
  mBlockCounter = 0;
  mBlockDirection = false;
  this->TeamTexture = 0;
  mScinam = false;
  mBedeScinac = false;
  mBedePrzebijac = false;
  mInBlock = false;
  mBlockHoldingOffReceive = false;
  this->mTeamQuality = 1.0f;
  pReceivingPlayer = NULL;
  pControledPlayer = NULL;
  mIsSomeoneReceiving = false;

  mIsServing   = false;
  mIsBallOwner = false;
  isAi = true;
  teamNumber = teamNum;


  memcpy(this->BlockChance, DefBlockChanses, sizeof(DefBlockChanses));
  BlockRadius = 1.0f;

  this->Init(teamname, GenShirt); 

  this->lastPhaseInd = 0;
  mTeamPhase = TP_RECEIVE_1;
  if (teamNum == TEAM_0)
  {
    AddMask(ET_TEAM_0);    
    mTeamMatrix.SetIdentity();
  }
  else
  {
    AddMask(ET_TEAM_1);    
    mTeamMatrix.SetRotateZ(PI);
  }
  

#ifdef CHODZENIE
  if (GetTeamNumber() == TEAM_0)
  {
      Players[3]->AddUserMask(ET_USER_1_INPUT);
      Players[3]->SetAI(false);
      pControledPlayer = Players[3];
      this->SetPlayerToZeroPriority(pControledPlayer);
  }
#endif

 float len;
  if ( len=CurrentDirVector[7].Length() < 0.9f )
    for (int i=0; i < MAX_CURRENT_DIR_VECTORS; i++)
      CurrentDirVector[i].Normalize();

}

/**
\fn void CTeam::Init(char *teamname)
\brief przeprowadza inicjalizacje teamu, laduje z pliku dat
\param teamname nazwa pliku dat (np.: poland.dat)
\return VB_OK lub VB_FAIL
*/
int CTeam::Init(char *teamname, bool GenShirt)
{  
  ConfFile Config;
  int LibColorNumber = 0, ColorNumber = 1;
  char *str0;
  char buffer[64];
  my_snprintf(buffer, 64, "%s\\%s",TeamDataPath, teamname);
  
  int i, libero = 0, libero_substitute = 0;
  if (SUCCEEDED(Config.Init(buffer))) 
  { 

    if (NULL == (this->mTeamName = Config.GET_STR("TEAM_NAME")))
    {
      this->mTeamName = strdup("TEAM_UNKNOWN");
    }
    this->mTeamShortName = Config.GET_STR("TEAM_SHORT_NAME");
    str0 = Config.GET_STR("TEAM_SHIRT_TEXTURE_NAME");
    if (str0 != NULL)
    { 
      this->TeamTexture = CMeshManager::Instance()->GetTextureHandlerLoad(str0);
      free(str0);
    }
    else
    {
      this->TeamTexture = DEFAULT_TEXTURE;
    }

    str0 = Config.GET_STR("TEAM_LIBERO_SHIRT_TEXTURE_NAME");
    if (str0 != NULL)
    { 
      this->TeamLiberoTexture = CMeshManager::Instance()->GetTextureHandlerLoad(str0);
      free(str0);
    }
    else
    {
      this->TeamLiberoTexture = DEFAULT_TEXTURE;
    }

    str0 = Config.GET_STR("TEAM_SHOE_TEXTURE_NAME");
    if (str0 != NULL)
    { 
      this->TeamShoeTexture = CMeshManager::Instance()->GetTextureHandlerLoad(str0);
      free(str0);
    }
    else
    {
      this->TeamShoeTexture = DEFAULT_TEXTURE;
    }

    Config.GET_INT("COLOR", &ColorNumber);
    Config.GET_INT("COLOR_LIB", &LibColorNumber);    

    Config.GET_FOLAT("BLOCKRADIUS", &BlockRadius);
    for(i=0; i<MAX_BLOCK_CHANCES; i++)
    {
      my_snprintf(buffer, 64, "BLOCK_CHANCES_%d", i);
      Config.GET_INT(buffer, &BlockChance[i]);
    }

    /* to musi byc przed initem playerów */
    this->mHomeStadium = 0;
    Config.GET_INT("LIBERO", &libero);
    Config.GET_INT("LIBERO_SUBSTITUTE", &libero_substitute);
    Config.GET_INT("HOME_STADIUM",&mHomeStadium);
    //libero = libero_substitute = 0xff;
    for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
      my_snprintf(buffer, 64, "PLAYER_%d_CONFFILE", i);      
      if (NULL == (str0 = Config.GET_STR(buffer)))
      {
        Config.DeInit();
        return VB_FAIL;
      }
      else
      {
        this->Players[i] = new CPlayer(this, str0, (libero == i),(libero_substitute == i));
        this->Players[i]->SetNumber(i+1);
        this->Players[i]->SetIndex(i);
        this->Players[i]->AddPersonalTexture(GenShirt,
                    ((libero == i) ? (LibColorNumber != 0) : (ColorNumber != 0)));
        free(str0);        
      }
    }

    int nrp;
    for(i=0;i<MAX_PLAYERS_ON_FIELD;i++)
    {
      my_snprintf(buffer, 64, "ON_FIELD_%d", i);            
      if (FAILED(Config.GET_INT(buffer,&nrp)))
      {
        Config.DeInit();
        return VB_FAIL;
      }
      else
      {
        this->Players[nrp]->SetIsOnPlane(true);
        this->Players[nrp]->SetStartPosition((PositionOnField)i); 
        if (teamNumber == TEAM_0)
        {
          this->Players[nrp]->SetPriority(i);
          this->Players[nrp]->AddMask(ET_TEAM_0_PLAYER);
        }
        else
        {
          this->Players[nrp]->SetPriority(i);
          this->Players[nrp]->AddMask(ET_TEAM_1_PLAYER);
        }
      }

      my_snprintf(buffer, 64, "ON_SUB_%d", i);            
      if (FAILED(Config.GET_INT(buffer,&nrp)))
      {
        Config.DeInit();
        return VB_FAIL;
      }
      else
      {
        this->Players[nrp]->SetIsOnPlane(false);
        this->Players[nrp]->SetStartPosition((PositionOnField)(i+6));
        if (teamNumber == TEAM_0)
        {
          this->Players[nrp]->AddMask(ET_TEAM_0_SUB);
          this->Players[nrp]->SetPriority(i+6);
        }
        else
        {
          this->Players[nrp]->AddMask(ET_TEAM_1_SUB);
          this->Players[nrp]->SetPriority(i+6);
        }
      }

      nrp = 0;
      Config.GET_INT("MAIN", &nrp);
      this->Players[nrp]->SetMain(true);
      CTacticManager::Instance()->SetMain(this->teamNumber, this->Players[nrp]->GetPosOnField());
      
      if (FAILED(Config.GET_FOLAT("TEAM_QUALITY",&this->mTeamQuality)))
      {
        this->mTeamQuality = 1.0f;
      }
       
    }

/*    
    if (FAILED(Config.GET_INT("CAPITAN",&nrp)))
    {
      Config.DeInit();
      return VB_FAIL;
    }
    else
    {
      //this->Players[nrp].SetIsCapitan(true);
    }
*/
    this->mASolver= new AStarSolver(this);
    return VB_OK;
  }

  return VB_FAIL;
}

void CTeam::DeInit()
{
  for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
  {
    delete this->Players[i];
    this->Players[i] = NULL;
  }
  if (this->mTeamName) free (this->mTeamName);
  if (this->mTeamShortName) free (this->mTeamShortName);
  this->teamNumber = -1;
  delete this->mASolver;
}

CTeam::~CTeam()
{
  if(this->teamNumber != -1)
  {
    this->DeInit();
  }
}

/* funkcja przywracaj¹ca pozycje na start (domyslnie faza z numerem 0) */
/* moze byc przydatna aby ustawic taktyke obronna po prrzebiciu */
void CTeam::ResetPositions()
{
  int i;
 mIsBallOwner = false;
 this->mTacticPhase[0] = 0;
 this->mTacticPhase[1] = 0;
 this->mTacticPhase[2] = 0;
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
 {
   this->Players[i]->GetCurrentState()->SnipStatesToThis();
 }
 this->SetPhase(0);
  if(mIsServing)
  {
    for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
      PositionOnField pos = this->Players[i]->GetPosOnField();
      switch(pos)
      {
        case POS_5:
          this->SetPlayerToPriority(this->Players[i], 1);
          this->Players[i]->SetGotoPosition(POS_BLOK_4);
          this->Players[i]->SetPosOnField(POS_5);
        break;
        case POS_4:
          this->SetPlayerToPriority(this->Players[i], 0);
          this->Players[i]->SetGotoPosition(POS_BLOK_1);
          this->Players[i]->SetPosOnField(POS_4);
        break;
        case POS_3:
          this->SetPlayerToPriority(this->Players[i], 2);
          this->Players[i]->SetGotoPosition(POS_BLOK_3);
          this->Players[i]->SetPosOnField(POS_3);
        break;
        default:
          /* nothing */
        break;
      }
    }
  }
}

void CTeam::ResetSettins()
{
 mScinam = false;
 mBedeScinac = false;
 mBedePrzebijac = false;
 mIsServing = false;
 mInBlock = false;
 mBlockHoldingOffReceive = false;
 
 mTeamPhase = TP_RECEIVE_1;
#ifndef CHODZENIE
 pControledPlayer = NULL;
#endif
 pReceivingPlayer = NULL;
 mIsSomeoneReceiving = false;
 mHitCount = 0;

 for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
 {
   this->Players[i]->ClearWasReceiving();
   this->Players[i]->ClearUserMask();
   this->Players[i]->SetAI(true);
   
   if (this->Players[i]->IsBlocking())
   {

      this->Players[i]->ClearBlocking();
      this->Players[i]->GetCurrentState()->SetNextState(NULL);
      this->Players[i]->GetCurrentState()->SetProposedNext(STATE_IDLE);
      this->Players[i]->GetCurrentState()->SetEndTime(NOW);
#ifdef DEBUG
      LogError("Team %d : Player %d , Cancel Blok (R)", this->teamNumber, Players[i]->GetPosOnField());
#endif
   }
   
   if(Players[i]->GetPosOnField() == POS_ZAGRYWKA)
   {
       Players[i]->SetPosOnField(POS_2);
       Players[i]->SetOdbijam(false);
       this->Players[i]->GetCurrentState()->SetNextState(NULL);
       this->Players[i]->GetCurrentState()->SetProposedNext(STATE_IDLE);
       this->Players[i]->GetCurrentState()->SetEndTime(NOW);
   }    

   Players[i]->SetPosOnField(Players[i]->GetRealPosition(Players[i]->GetPosOnField()));
   
 }
}

#ifdef DEBUG
const char *PhaseStr[] =
{
  "TP_DEFENCE",
  "TP_RECEIVE_1",
  "TP_RECEIVE_2",
  "TP_RECEIVE_3",
};
#endif

void CTeam::Update()
{
#ifdef DEBUG
  /*
  char buffer[128];
  my_snprintf(buffer,128,"TEAM_%i is in phase : %s and has %i points ( %s )\n",teamNumber,PhaseStr[mTeamPhase+1],this->mPointCount, (this->mBedeScinac ? "BEDE" : "NIEBEDE"));
  Logger::Instance()->LogToScreen(buffer);
  */
#endif

  mASolver->PurgeMap();
  mASolver->Update();
  
#ifdef CHODZENIE

    if(pControledPlayer && pControledPlayer->GetPriority())
    {
      this->SetPlayerToZeroPriority(pControledPlayer);
    }

    if(false)
#else
   if(pControledPlayer && !pControledPlayer->IsAI())
#endif
       
    {
      CVector3 delta;
      
      delta.Set(CBall::Instance()->GetTargetPosition());
      TeamToWorld(&delta);

      Vector3Subtract(delta.tab, delta.tab, pControledPlayer->GetCurrentState()->GetLastPosition()->tab);

      if(delta.LengthSq() < CIRCLE * CIRCLE + 0.01f)
      {
        int phase = this->mTeamPhase - 1;
       
        DIE(phase >= TP_RECEIVE_1);

      if(this->IsCurrentTargetValid(phase))
      {
        delta.Set(CTacticManager::Instance()->GetBallTarget(mTacticPhase[phase]));
        delta.z = 0.0f;
      }
      else
      {
        if(phase == TP_RECEIVE_3)
        {
        /* pojawienie sie celownika w punkcie 0,0 (pod siatka)*/
        delta.Set(0.0f, 0.0f, 0.0f);       
        }
        else
        {
            //delta.Set(pControledPlayer->GetCurrentState()->GetLast()->GetStartPosition());
            delta.Set(0.0f, 4.5f, 0.0f);
        }
      }
        
        if(pControledPlayer->SelectReceiveState(&delta, false, (phase == TP_RECEIVE_1)))
        {

          CTargetPrzebicia::Instance()->SetPosition(&delta);

          CBall::Instance()->GetPrzebicieTarget()->Set(&delta);
        GUI::Instance()->SetBallForce(0.0f);
          CBall::Instance()->UsePrzebicieTarget();
              
          CTargetPrzebicia::Instance()->Show();
        }
        pControledPlayer->SetAI(true);
        mIsSomeoneReceiving = true;
      }
    }

    
  if(pControledPlayer && pControledPlayer->IsAI() && !CTargetPrzebicia::Instance()->IsShow())
  {
    CVector3 delta;
    
    delta.Set(CBall::Instance()->GetTargetPosition());
    TeamToWorld(&delta);

    Vector3Subtract(delta.tab, delta.tab, pControledPlayer->GetCurrentState()->GetLastPosition()->tab);


    if(delta.LengthSq() < CIRCLE * CIRCLE + 0.01f)
    {

      /* Ustwwia losowy punkt ataku */
#if 0
      delta.z = 0.0f;
      /* pozwalam na plad w x-ach */
      delta.x = (myrand(99) > 50 ? 1.0f : -1.0f) * ((float)myrand(450) / 100.0f);
      delta.y = (0.5f + ((float)myrand(850) / 100.0f));
#else
      delta.Set(pControledPlayer->GetCurrentState()->GetLast()->GetStartPosition());
#endif
      CTargetPrzebicia::Instance()->SetPosition(&delta);

      GUI::Instance()->SetBallForce(0.0f);
      CBall::Instance()->UsePrzebicieTarget();
      CBall::Instance()->GetPrzebicieTarget()->Set(&delta);
            
      CTargetPrzebicia::Instance()->Show();
      mIsSomeoneReceiving = true;

      CancelBlock();
    }
  }

  int indd;
  for ( int i = 0; i < MAX_PLAYERS_IN_TEAM; i++)
  {     
    indd = GetPlayerIndByPriority(i);
      this->Players[indd]->Update(); 
      this->mASolver->FillMap(indd);
  }
}

void CTeam::ProcessEvent(Event *event)
{

  if((event->mMask & ET_USER_MASK_SUM))
  {
    
    if (CGame::Instance()->GetGamePhase() != GP_GAMEPLAY) return;
      
    /* napraw to puzniej - moze bruzdzic drugi user bo target jest singeltonem */
    if (CTargetPrzebicia::Instance()->IsShow())
    {
      unsigned int key = this->TranslateControls(event->mID);

      CVector3 delta(0.2f,0.2f,0.0f);
      CVector3 *trg = CBall::Instance()->GetPrzebicieTarget();
      
      TeamToWorld(&delta);

      if (CheckFlag(key, VBK_DOWN)) 
      {
        trg->y += delta.y;
      }
      else
      {
        if (CheckFlag(key, VBK_UP))
        {
          trg->y -= delta.y;
        }
      }
      if (CheckFlag(key, VBK_LEFT)) 
      {
        trg->x += delta.x;
      }
      else
      {
        if (CheckFlag(key, VBK_RIGHT))
        {
          trg->x -= delta.x;
        }
      }

      if(!CBall::Instance()->IsRegisteringHit()
          && (CheckFlag(event->mID2, VBK_ACTION_1) || CheckFlag(event->mID2, VBK_ACTION_2)))
      {
        CBall::Instance()->StartRegisteringHit();
      }
      

      if(CheckFlag(event->mID, VBK_ACTION_2))
      {
        mBedeScinac = true; 
        CBall::Instance()->RegisterHit();
      }
      else
      {
        if(CheckFlag(event->mID, VBK_ACTION_1))
        {
          CBall::Instance()->RegisterHit();
        }
      }

      CTargetPrzebicia::Instance()->SetPosition(trg);

      return;
    } 

    if(pControledPlayer && !CBall::Instance()->IsRegisteringHit()
       && (CheckFlag(event->mID2, VBK_ACTION_1) || CheckFlag(event->mID2, VBK_ACTION_2)))
    {
      CBall::Instance()->StartRegisteringHit();
    }

    if(pControledPlayer && CheckFlag(event->mID, VBK_ACTION_2))
    {
      mBedeScinac = true;
      // mScinam = true;
    }

    if (mInBlock && (CheckFlag(event->mID2, VBK_ACTION_1)))
    {
      CommenceBlock();
      return;
    }

    if (mInBlock && !pControledPlayer && (CheckFlag(event->mID2, VBK_ACTION_2)))
    {
      ReorderBlockPositions();
      return;
    }

    if (!pControledPlayer && CheckFlag(event->mID2, VBK_ACTION_3))
    {
      if (mInBlock)
      {
        CancelBlock();
      }
      else 
      {
        CVector3 pos;

        pos.Set(CBall::Instance()->GetTargetPosition());
        this->TeamToWorld(&pos);

        if(pos.y < 0)
        {
          for (int i = 0; i < MAX_PLAYERS_IN_TEAM ;i ++)
          {
            if (Players[i]->GetIsOnPlane() && (Players[i]->IsBlocking() || Players[i]->CzyOdbijam()))
            {
#ifdef DEBUG
              LogError("Team %d : Nie moge przejsc do bloku Bo blokuje player %d (B : %d) / (O : %d)", this->teamNumber, Players[i]->GetPosOnField(), (Players[i]->IsBlocking()? 1 : 0), (Players[i]->CzyOdbijam() ? 1 : 0));
#endif
              CancelBlock();
              return; //upewnienie sie czy wszyscy ukonczyli blok
            }
          }
          SelectPlayersForBlock(NULL);
        }
      }
    }

    return;
  }


  switch (event->mID)
  {
    
    case GE_BALL_TARGET:
      {
#ifdef DEBUG
        LogError("TEAM_%i: Dostalem Ball Target!",this->teamNumber);
#endif
        if (!this->isAi)
        {
          GUI::Instance()->SetGamePhase(-1);
        }

        pControledPlayer = NULL;
        pReceivingPlayer = NULL;
        mIsSomeoneReceiving = false;
        this->mBlockHoldingOffReceive = false; 
        GUI::Instance()->HidePowerBar();

        for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
        {
           if (Players[i]->IsBlocking()) continue;
           this->Players[i]->ClearUserMask();
           this->Players[i]->SetAI(true);
        }

        CVector3 point;

        point.Set(((CVector3*) event->mData));

        WorldToTeam(&point);
 
        if (mIsServing)
        {
          mScinam = false;
          mBedeScinac = false;
          mBedePrzebijac = false;
          mTeamPhase = TP_RECEIVE_1;
          mIsServing = false;
#ifdef DEBUG
          LogError("Team %d : Reset Fazy do 1 (z Serving)", this->teamNumber);
#endif
          break;
        }
        
        if (!this->IsPointInField(&point)
            && !(CBall::Instance()->GetTeamOwner() == this->teamNumber && 
                (CBall::Instance()->WillHitNet() || CBall::Instance()->WillPasUnder()))
            ) 
        {
          mIsBallOwner = false;
          mBedeScinac = false;
          mBedePrzebijac = false;
          mScinam = false;
          mTeamPhase = TP_RECEIVE_1;
          mIsServing = false;
#ifdef DEBUG
          LogError("Team %d : Reset Fazy do 1 (z InField)", this->teamNumber);
#endif
          if(mInBlock) break;

          PositionOnField position;
          for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
          {
            position = this->Players[i]->GetPosOnField();
            switch(position)
            {
              case POS_0:
                Players[i]->SetGotoPosition(POS_DEFENDER_0);
                Players[i]->SetPosOnField(POS_0); /* this is hack to fix SetGotoPosition settings */
              break;
              case POS_1:
                Players[i]->SetGotoPosition(POS_DEFENDER_1);
                Players[i]->SetPosOnField(POS_1); /* this is hack to fix SetGotoPosition settings */
              break;
              case POS_2:
                Players[i]->SetGotoPosition(POS_DEFENDER_2);
                Players[i]->SetPosOnField(POS_2); /* this is hack to fix SetGotoPosition settings */
              break;
              case POS_3:
                Players[i]->SetGotoPosition(POS_BLOK_0);
                Players[i]->SetPosOnField(POS_3); /* this is hack to fix SetGotoPosition settings */
              break;
              case POS_4:
                Players[i]->SetGotoPosition(POS_BLOK_1);
                Players[i]->SetPosOnField(POS_4); /* this is hack to fix SetGotoPosition settings */
              break;
              case POS_5:
                Players[i]->SetGotoPosition(POS_BLOK_2);
                Players[i]->SetPosOnField(POS_5); /* this is hack to fix SetGotoPosition settings */
              break;
              default:
                /* idz na normalna pozycje twej POZYCJI :) */
                //Players[i]->SetGotoPosition(position);
              break;
            }
          }

          break;
        }

        if (mHitCount > 2) 
        {
          mIsBallOwner = false;
          mBedeScinac = false;
          mBedePrzebijac = false;
          mScinam = false;
          mTeamPhase = TP_RECEIVE_1;
          mIsServing = false;
#ifdef DEBUG
          LogError("Team %d : Reset Fazy do 1 (z mHitCount)", this->teamNumber);
#endif
          
          break;
        }

        if((CBall::Instance()->WillPasUnder() && IsPointInTheOtherField(&point)) ||
           (CBall::Instance()->GetTeamOwner() != this->teamNumber && CBall::Instance()->WillHitNet()))
        {
          ResetSettins();
#ifdef DEBUG
          LogError("Team %d : Reset Fazy do 1 (z HitNet)", this->teamNumber);
#endif
          break; 
        }

    
        mHitCount++;

        POST_EVENT((this->teamNumber ? ET_TEAM_0 : ET_TEAM_1 ), TE_RESET_HITCOUNT , true, NULL);

        mIsBallOwner = true;

        if (!this->isAi)
        {
          GUI::Instance()->SetGamePhase(PP_PLAY);
        }

        if (!mIsServing)
        {
          short tac;
          if(this->isAi)
          {
            if (mTeamPhase == TP_RECEIVE_1)
            {
              CVector3 target;

              target.Set(&point);
              for(int p = (int)TP_RECEIVE_1 ; p <= (int)TP_RECEIVE_3; p++)
              {
                 tac = CTacticManager::Instance()->GetPhaseIndexFromTarget(
                                             this->teamNumber, p, &target);
                 if(tac < 0) tac = 0;
                 this->mTacticPhase[p] = tac;
                 target.Set(CTacticManager::Instance()->GetBallTarget(tac));
              }
            }
          }
          else
          {
            if (mBedeScinac || mBedePrzebijac)
            {
              tac = CTacticManager::Instance()->GetPhaseIndexFromTarget(
                                              this->teamNumber, TP_RECEIVE_3, &point);
              if(tac < 0)
              {
                tac = CTacticManager::Instance()->GetPhaseIndex(this->teamNumber, TP_RECEIVE_3);
              }
          }
          else
          {
              tac = CTacticManager::Instance()->GetPhaseIndexFromTarget(
                                              this->teamNumber, mTeamPhase, &point);
              if(tac < 0)
              {
                tac = CTacticManager::Instance()->GetPhaseIndex(this->teamNumber, mTeamPhase);
              }
            }
            if(tac < 0) tac = 0;
            this->mTacticPhase[mTeamPhase] = tac;
          }
        }

        /* ustawia punkty dojscia (nie generuje lancuszki) */
        this->SetPhase(mTeamPhase);

        /* this function set 'pReceivingPlayer' */
        this->SelectPlayerForReceive((CVector3*) event->mData, mTeamPhase);

        PositionOnField position = pReceivingPlayer->GetPosOnField();

        if(this->IsCurrentTargetValid(mTeamPhase))
        {
          point.Set(CTacticManager::Instance()->GetBallTarget(mTacticPhase[mTeamPhase]));
        }
        else
        {
          if (mTeamPhase == TP_RECEIVE_1)
          {
            /* Ustwwia losowy punkt ataku */ 
            point.z = 0.0f;
            /* pozwalam na plad w x-ach */
            point.x = (myrand(99) > 50 ? 1.0f : -1.0f) * ((float)myrand(450) / 100.0f);
            point.y = (0.5f + ((float)myrand(850) / 100.0f));
          }
          else
          {
            if(this->isAi)
        {
              mBedeScinac = true;
        }
        else
        {
          point.Set(0.0f, 0.0f, 0.0f);
        }
          }
        }

        if (mBedeScinac || mBedePrzebijac)
        {
          if (mBedeScinac)
          {
            mScinam = true;
          }
          if (this->isAi)
          {
             mScinam = true;

             /* Ustwwia losowy punkt ataku */ 
             point.z = 0.0f;
             /* pozwalam na plad w x-ach */
             point.x = (myrand(99) > 50 ? 1.0f : -1.0f) * ((float)myrand(500) / 100.0f);
             point.y = -1.0f * (3.0f + ((float)myrand(600) / 100.0f));
          }
          else
          {
            point.Set(0.0f, -4.5f, 0.0f);
            pReceivingPlayer->SetAI(true);
          }
        }

        /* to jest prawdziwe dla AI i raczej tylko on to uzywa */
        bool przebijam = (point.y < 0.0f) && this->IsAi();

        if ( !this->IsAi() && !mInBlock && !(mBedeScinac || mBedePrzebijac))
        {
          SetUserFromTeam(pReceivingPlayer);
          pControledPlayer = pReceivingPlayer;
          mIsSomeoneReceiving = false;
#ifdef DEBUG
          LogError("Team %d : Add User Control to player %d", this->teamNumber, pControledPlayer->GetPosOnField());
#endif
        }
        else
        {
  
          point.z = 0.0f; /* Just in case */
          if(pReceivingPlayer->SelectReceiveState(&point, (mScinam || przebijam), (mTeamPhase == TP_RECEIVE_1)))
          {
        if ( !this->IsAi() )
        {

          TeamToWorld(&point);
          CTargetPrzebicia::Instance()->SetPosition(&point);
          CBall::Instance()->UsePrzebicieTarget();
          CBall::Instance()->GetPrzebicieTarget()->Set(&point);

              if( mInBlock )
        {
          pControledPlayer = pReceivingPlayer;
                pControledPlayer->SetAI(true);
        }
        else
        {
                GUI::Instance()->SetGamePhase(PP_ATTACK);
                CTargetPrzebicia::Instance()->Show();
                GUI::Instance()->SetBallForce(0.0f);
              }
  
            mIsSomeoneReceiving = false;
          }
          }
          else
          {
            CancelBlock();
          }
        }

        mTeamPhase++;
        if(mTeamPhase > TP_RECEIVE_3 || przebijam)
        {
#ifdef DEBUG
          LogError("Team %d : Reset Fazy do 1 (z 3)", this->teamNumber);
#endif
          mTeamPhase = TP_RECEIVE_1;
          mScinam = false;
          mBedeScinac = false;
          mBedePrzebijac = false;
          mIsBallOwner = false;
         // CTargetPrzebicia::Instance()->Hide();
          for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
          {
            this->Players[i]->ClearWasReceiving();
          }
          
        }
        else
        {
          if (!mScinam && mTeamPhase == TP_RECEIVE_3) //a z taktyk wynika scina
          {
            //mBedeScinac = true;
            mBedePrzebijac = true;
          }

          if(mScinam)
          {
#ifdef DEBUG
            LogError("Team %d : Reset Fazy do 1 (z Scinam)", this->teamNumber);
#endif
            mTeamPhase = TP_RECEIVE_1;
            mScinam = false;
            mBedeScinac = false;        
            mBedePrzebijac = false;
          }

        }

        if (mIsServing)
        {
          mTeamPhase = TP_RECEIVE_1;
          mIsServing = false;
        }
      }       
        break;
    case TE_RESET_HITCOUNT :
      {
      mHitCount = 0;
      for(int i=0; i<MAX_PLAYERS_IN_TEAM; i++)
      {
        if (Players[i]->IsBlocking()) continue;
        this->Players[i]->ClearUserMask();
        //this->Players[i]->SetAI(true);
      }
      }
    break;
    case TE_PRZEBICIE  :
#ifdef DEBUG
      LogError("Team %d : PRZEBICIE !", this->teamNumber);
#endif
      if (!this->isAi)
      {
        /* wyswietlanie miejsca bloku dla Usera */
        CBlocker::Instance()->GetPosition()->Set(&(((BlockData*) event->mData)->HitPos));
        CBlocker::Instance()->Show();
      }
      else
      {
        //if(!mInBlock)
        {
          SelectPlayersForBlock((BlockData *)event->mData);

          CBlocker::Instance()->GetPosition()->Set(&(((BlockData*) event->mData)->HitPos));
          CBlocker::Instance()->Show();
        }
      }
    break;
    case TE_MAKE_BLOK :
#ifdef DEBUG
      LogError("Team %d : MAKE_BLOK !", this->teamNumber);
#endif
      if (mInBlock && this->isAi)
      {
        CommenceBlock();
      }
    break;
    case TE_MAKE_DECOY  :
      {
#ifdef DEBUG
        LogError("Team %d : MAKE_DECOY !", this->teamNumber);
#endif
#if 0
        PositionOnField position;
        States decoy;
        for(int i=0; i < MAX_PLAYERS_IN_TEAM; i++)
        {
          position = this->Players[i]->GetPosOnField();
          
          if(!this->Players[i]->CzyOdbijam() && this->Players[i]->IsBlocking() &&
              position == POS_3 || position == POS_4 || position == POS_5)
          {
            decoy = CTacticManager::Instance()->GetProposedState(mCurrentTactic, mTeamPhase, (unsigned char)position );
            if(decoy != STATE_IDLE)
            {
              this->Players[i]->GetCurrentState()->SetNextState(NULL);
              this->Players[i]->GetCurrentState()->SetEndTime(NOW);
              this->Players[i]->GetCurrentState()->SetProposedNext( decoy );
              this->Players[i]->ForceUpdate();
            }
          }
        }
#endif        
      }
    break;
    case TE_SUCCESSFUL_BLOCK:
      if (pReceivingPlayer)
      {
#ifdef DEBUG
        LogError("Team %d : Player %d : SUCCESSFUL BLOK : Player = NULL", this->teamNumber, pReceivingPlayer->GetPosOnField());
#endif
        pReceivingPlayer->SetOdbijam(false);
        pReceivingPlayer->GetCurrentState()->SetNextState(NULL);
        pReceivingPlayer->GetCurrentState()->SetProposedNext(STATE_IDLE);
        pReceivingPlayer->ClearWasReceiving();
      }
      mTeamPhase = TP_RECEIVE_1;
      mScinam = false;
      mBedeScinac = false;        
      mBedePrzebijac = false;
    break;

  }
  
}


bool CTeam::CanBlock(float alpha01)
{
  float Steps[] = {0.2f, 0.4f, 0.6f, 0.8f, 1.0f};
  int index;

  for (index = 0; index < MAX_BLOCK_CHANCES; index++)
  {
    if ( alpha01 <= Steps[index] )
    {
      break;
    }
  }
  return (this->BlockChance[index] <= myrand(100));
}


/*wybieranie gracza do odbioru - pobniera najbli¿szego który w poprzednim odbiciu nie odbiera³*/
void CTeam::SelectPlayerForReceive(CVector3 *target, int phase)
{ 
  int i;
  CVector3 delta, pos;
  float len = 0.0f;
  CPlayer *selPlayer = NULL;
  float BallHitTime;

  this->WorldToTeam(target);

  /*
   * Znajdz najblizszego wedlug taktyk.
   * Przeciwskazania:
   * - tylko dla AI.
   * - nie robi akurat bloku.
   * - taktyka ma ustawionego gracza który ma odebrac.
   * - poprzednie odbicie bylo z STOPY (losowy cel podania) i podawane od swojego zawodnika.
   */
  if(this->IsAi() && !mInBlock && CTacticManager::Instance()->IsHitmanValid(mTacticPhase[phase])
    && !(CBall::Instance()->WasErrorHit() && CBall::Instance()->GetTeamOwner() == this->teamNumber))
  {
    PositionOnField hitman = CTacticManager::Instance()->GetHitMan(mTacticPhase[phase]);
    
    for (i = 0; i < MAX_PLAYERS_IN_TEAM ;i++)
    { 
      if (Players[i]->GetPosOnField() == hitman) break;
    }

    if(i < MAX_PLAYERS_IN_TEAM && !Players[i]->WasReceiving() &&
       hitman <= POS_5 && !Players[i]->IsBlocking() && !Players[i]->CzyOdbijam())
    {
      selPlayer = Players[i];
      for ( i = 0; i < MAX_PLAYERS_IN_TEAM ;i ++)
      {
        Players[i]->ClearWasReceiving();
      }
      goto FOUND;
    }
    else
    {
      /* to i tak nie bendzie dzialac poniewaz nie ma jeszcze wygenerowanych lancuszkow dojscia */
      BallHitTime = CBall::Instance()->GetFloorHitTime();
    }
  }
  else
  {
    BallHitTime = NOW;
  }

  /*
   * Zincjalizuj najblizszego wedlug taktyk i jego pozycji z taktyk.
   */
  if(CTacticManager::Instance()->IsHitmanValid(mTacticPhase[phase]))
  {
    PositionOnField hitman = CTacticManager::Instance()->GetHitMan(mTacticPhase[phase]);
    
    for (i = 0; i < MAX_PLAYERS_IN_TEAM ;i++)
    { 
      if (Players[i]->GetPosOnField() == hitman) 
      {
        if(!Players[i]->WasReceiving() && !Players[i]->IsBlocking() && !Players[i]->CzyOdbijam())
        {
         selPlayer = this->Players[i];
         pos.Set(selPlayer->GetNewPosFromTactic());
         delta = pos - *target;
         len = delta.LengthSq();
        }
        break;
      }
    }
  }

  if (selPlayer && phase == TP_RECEIVE_2 && len < 9.0f) // len < 3.0f * 3.0f
  {
    goto FOUND;
  }

  /*
   * Znajdz najblizszego wedlug odleglosci.
   * Przeciwskazania:
   * - tylko dla zawodnikow na boisku.
   * - nie dla zagrywajacego.
   * - nie dla zawodnika który podawal (podwujne odbicie).
   * - nie dla zawodnika który blokuje lub jeszcze odbija.
   */
  for ( i = 0; i < MAX_PLAYERS_IN_TEAM ; i++)
  {
    /* olej rezerwowych */
    if (Players[i]->GetPosOnField() > POS_5) continue;
    /* olej rozgrywajacego w czasie pierwszego odbicia */
    if (!mInBlock && phase == TP_RECEIVE_1 && Players[i]->IsMain()) continue; 
    /* olej goscia co poprzednio odbil */
    if (Players[i]->WasReceiving()) 
    {
      Players[i]->ClearWasReceiving();
      continue;
    }
    /* olej goscia co blokuje i sa w trakcie odbicia */
    if (Players[i]->IsBlocking() || Players[i]->CzyOdbijam())
    {
      continue; 
    }
    if (!selPlayer)
    {
      selPlayer = this->Players[i];
      selPlayer->GetCurrentState()->GetPositionByTime(&pos,BallHitTime);
      delta = pos - *target;
      len = delta.LengthSq();
      continue;
    }
    float tlen;
    Players[i]->GetCurrentState()->GetPositionByTime(&pos,BallHitTime);
    delta = pos - *target;
    tlen = delta.LengthSq();
    if (tlen < len)
    {
      len = tlen;
      selPlayer = Players[i];
    }
  }

FOUND:  
  pReceivingPlayer = selPlayer;
  selPlayer->SetWasReceiving();
  SetPlayerToZeroPriority(selPlayer);

}

CVector3 *CTeam::WorldToTeam(CVector3 *vec)
{
  if (this->teamNumber == TEAM_1)
  {
    vec->x = -vec->x;
    vec->y = -vec->y;
  }
  return vec;
}

CVector3 *CTeam::TeamToWorld(CVector3 *vec)
{
  if (this->teamNumber == TEAM_1)
  {
    vec->x = -vec->x;
    vec->y = -vec->y;
  }
  return vec;
}

CVector3 *CTeam::ModSubPosition(CVector3 *vec)
{
  if (this->teamNumber == TEAM_1)
  {
    vec->x = -vec->x;
  }
  return vec;
}

bool CTeam::IsCurrentTargetValid(unsigned char phase)
{  
  if(!CTacticManager::Instance()->IsTargetValid(mTacticPhase[phase]))
  {
    LogCritical("Team %d : Use InValid Ball Target from Tactic in phase : %d", this->teamNumber, phase);
    return false;
  }
  return true;
}

/*
\fn void CTeam::TranslateControls(unsigned int key)
\param key - VBK_ przychodz¹ce w evencie do playera

dla drugiego teamu, klawisze sa odwracane - wywolywana przez playera dla
swojego teamu
*/
unsigned int CTeam::TranslateControls(unsigned int key)
{
  if ( this->teamNumber == TEAM_1 )
  {
    if (CheckFlag(key, VBK_DOWN)) 
    {
      key &= ~VBK_DOWN;
      key |= VBK_UP;
    }
    else
    {
      if (CheckFlag(key, VBK_UP)) 
      {
        key &= ~VBK_UP;
        key |= VBK_DOWN;
      }
    }

    if (CheckFlag(key, VBK_LEFT))
    {
      key &= ~VBK_LEFT;
      key |= VBK_RIGHT;
    }
    else
    {
      if (CheckFlag(key, VBK_RIGHT))
      {
        key &= ~VBK_RIGHT;
        key |= VBK_LEFT;
      }
    }
  }
  
  return key;
}

float CTeam::AngleTeamToWorld(float angle)
{
  if (this->teamNumber == TEAM_1)
  {
    return angle;
  }
  return angle - PI;
}

void CTeam::SetPhase(int phaseNum)
{
  int i;
  this->lastPhaseInd = phaseNum;
  PositionOnField position;


  for ( i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    if ( this->Players[i]->GetIsOnPlane() )
    {
      position = this->Players[i]->GetPosOnField();
      if (position > POS_5 && position < POS_ZAGRYWKA) continue;
      position = Players[i]->GetRealPosition(position);
      this->Players[i]->SetPriority( 
        CTacticManager::Instance()->GetPriority(mTacticPhase[phaseNum] , (unsigned char)position ) );
    }
  }
  
  if(!ValidatePlayersPriority())
  {
    DIE(!"Przyznano n-ty raz ten sam Priorytet");
  }

  for ( i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    position = this->Players[i]->GetPosOnField();
    if (position > POS_5 && position < POS_ZAGRYWKA) continue;
    if(CTacticManager::Instance()->IsPositionValid(mTacticPhase[phaseNum] , (unsigned char)position ))
    {
      this->Players[i]->GetCurrentState()->SetNextState(NULL);
      this->Players[i]->SetPosFromTactic(
        CTacticManager::Instance()->GetPosition(mTacticPhase[phaseNum] , (unsigned char)position )
        );
    }
    else
    {
      CVector3 pos;
      this->Players[i]->GetCurrentState()->GetCurrentPosition(&pos);
      this->Players[i]->SetPosFromTactic(&pos);
    }
  }
}

State *CTeam::GetMoveStates(CPlayer * player, CVector3 * newPosition)
{
  return GetMoveStates(player, player->GetCurrentState(), newPosition);
}
 
State *CTeam::GetMoveStates(CPlayer * player, State* forState, CVector3 * newPosition)

{ 
  int ret = this->mASolver->FindPath(player,newPosition,forState);
  if(ret > 0)
  {
  return forState->GetLast();/**/
  }
  if(ret == 0) return forState;
  return NULL;
}

void CTeam::SetUserFromTeam(CPlayer *selPlayer)
{
  if (this->isAi) return;
  selPlayer->SetAI(false);
  switch(GetTeamNumber())
  {
    case TEAM_0: selPlayer->AddUserMask(ET_USER_1_INPUT); return;
    case TEAM_1: selPlayer->AddUserMask(ET_USER_2_INPUT); return;
    default: DIE(!"Jaki dales numer Teamu ... Balwanie!!!");
  }

}

/*sprawdzanie czy punkt le¿y na boisku , albo w przypadku fazy innej ni¿ obrony sprawdza czy trzeba odebrac
  punkt z out'u */

// wymaga powaznej modyfikacji - faza gry owinna byc zdefiniowana
bool CTeam::IsPointInField (CVector3 *point)
{
  
  if (!mIsBallOwner && this->isAi)
  { // rozszerzaæ te wielkoœci odwrotnie proporcjonalnie do trudnosci druzyny
    float AiFieldTweak = (1.0f - this->mTeamQuality) * 2.5f; 
    if (point->x >  (4.5f + AiFieldTweak)) return false;
    if (point->x < -(4.5f + AiFieldTweak)) return false;
    if (point->y >  (9.0f + AiFieldTweak)) return false;
  }

  if (point->y < 0.0f) 
  {
    return false;
  }  

  return true;
}

bool CTeam::IsWorldPointInTheOtherField(CVector3 *point)
{
  CVector3 point_tmp;
  point_tmp.Set(point);
  this->WorldToTeam(&point_tmp);
  return IsPointInTheOtherField(&point_tmp);
}

bool CTeam::IsPointInTheOtherField(CVector3 *point)
{
  if (point->x >  4.5f) return false;
  if (point->x < -4.5f) return false;
  if (point->y < -9.0f) return false;
  if (point->y >  0.0f) return false;
  return true;
}


bool CTeam::ValidatePlayersPriority(void)
{ 
#if 1
  
  CPlayer *priTab[MAX_PLAYERS_IN_TEAM][MAX_PLAYERS_IN_TEAM];
  unsigned char PriCount[MAX_PLAYERS_IN_TEAM];

  memset(priTab,0, sizeof(priTab));
  memset(PriCount,0,sizeof(PriCount));

  int i;
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
  {
    if (this->Players[i]->IsAI() == false)
    {
      continue;
    }
    if ( this->Players[i]->GetPriority() > 11 || this->Players[i]->GetPriority() < 0)
    {
      this->Players[i]->SetPriority(6);
    }
    priTab[this->Players[i]->GetPriority()][PriCount[this->Players[i]->GetPriority()]] = this->Players[i];
    PriCount[this->Players[i]->GetPriority()]++;
  }
   
  int k = 0;
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
        {
   if (this->Players[i]->IsAI() == false)
          {
     this->Players[i]->SetPriority(k++);
    }
  }

  
  while( k < MAX_PLAYERS_IN_TEAM)
  {
   for (int j = 0; j < MAX_PLAYERS_IN_TEAM; j++)
     for (int m = 0; m < PriCount[j] ; m++)
  {
       priTab[j][m]->SetPriority(k++);
     }
  }
    
  return true;
  
#else
  char tab[MAX_PLAYERS_IN_TEAM]={0};   

    
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
    if ( this->Players[i]->GetPriority() > 11  || this->Players[i]->GetPriority() < 0)
    {
      this->Players[i]->SetPriority(6);
    }
    tab[this->Players[i]->GetPriority()]++;
  }
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    { 
    if(tab[i]!=1)
      {
      return false;
      }
      }
  return true;
#endif
}

// nie w pelni przetestowane
void CTeam::SetPlayerToPriority(CPlayer *player, int priority)
{

#ifdef DEBUG    
  if(!ValidatePlayersPriority())
      {
    DIE(!"SetPlayerToPriority I : Przyznano n-ty raz ten sam Priorytet");
      }
#endif

  int i;
  int pr , oldPlayerPr = player->GetPriority();

  if (oldPlayerPr == priority) return;
        
  if(oldPlayerPr > priority)
        {
    for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
        {
      pr = this->Players[i]->GetPriority();
      if ( pr < oldPlayerPr && pr >= priority )
        {          
        this->Players[i]->SetPriority( pr + 1 );
      }
        }
      }
      else
      {
    for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
      pr = this->Players[i]->GetPriority();
      if ( pr > oldPlayerPr && pr <= priority )
      {
        this->Players[i]->SetPriority( pr - 1 );
    }
  }
  }
  player->SetPriority(priority);
  
#ifdef DEBUG
  char tab2[MAX_PLAYERS_IN_TEAM]={0};   
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
    tab2[this->Players[i]->GetPriority()]++;
    }
  for(i=0; i<MAX_PLAYERS_IN_TEAM; i++)
    {
    DIE(tab2[i]==1 && "SetPlayerToPriority II : Przyznano n-ty raz ten sam Priorytet");
    }
#endif
    
}

        
void CTeam::SetPlayerToZeroPriority(CPlayer *player)
{
  SetPlayerToPriority(player, 0);
}
        
int CTeam::GetPlayerIndByPriority(int priority)
{
  for ( int i=0; i < MAX_PLAYERS_IN_TEAM; i++)
        {
    if ( this->Players[i]->GetIsOnPlane() && this->Players[i]->GetPriority() == priority )  return i;
  }
  return -1;
}

/*

*/

void CTeam::RotatePlayers()
{
  int i;
  PositionOnField position;

  for ( i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    position = Players[i]->GetRealPosition(this->Players[i]->GetPosOnField());
    this->Players[i]->SetPosOnField(position);
  }

  for ( i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    if  (this->Players[i]->GetPosOnField() == POS_0)
    {
      if (Players[i]->IsLibero())
      {
        LiberoSchodzi();
      }
      else
        break;
    }
  }

  for ( i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    position = this->Players[i]->GetPosOnField();
    if ( position < SUB_0 ) 
    {
      if (position == POS_0)
      {
        this->Players[i]->SetGotoPosition/*SetPosOnField*/(POS_5);
      }
      else
      {
            this->Players[i]->SetGotoPosition/*SetPosOnField*/((PositionOnField)(position - 1));
        }
      }
    if(this->Players[i]->IsMain())
    {
      CTacticManager::Instance()->SetMain(this->teamNumber, this->Players[i]->GetPosOnField());
    }
  }
}

bool CTeam::FixFieldPositions(CPlayer *player)
{
  bool ret = false;
  State *forState = player->GetCurrentState();

  if (forState->GetCurrent() != RUN_FAST) return false;

  //awaryjnie jesli kolizje wyzej zawiod¹
  CVector3 pos;
  forState->GetCurrentPosition(&pos);
  if ( pos.y < 0.3f )
  {
    forState->SetNextState(NULL);
    forState->SetEndTime(NOW);
    forState->RecalcLastPosition();
    forState->SetProposedNext(STATE_IDLE);
    forState = player->ForceUpdate();
    forState->GetStartPosition()->y = 0.3f;
    forState->GetLastPosition()->Set(forState->GetStartPosition());
    ret = true;
  }    
  if ( !ret && pos.x > 7.5f)
  {
    forState->SetNextState(NULL);
    forState->SetEndTime(NOW);
    forState->RecalcLastPosition();
    forState->SetProposedNext(STATE_IDLE);
    forState = player->ForceUpdate();
    forState->GetStartPosition()->x = 7.5f;
    forState->GetLastPosition()->Set(forState->GetStartPosition());
    ret = true;
  }    
  if ( !ret && pos.x < -7.5f )
  {
    forState->SetNextState(NULL);
    forState->SetEndTime(NOW);
    forState->RecalcLastPosition();
    forState->SetProposedNext(STATE_IDLE);
    forState = player->ForceUpdate();
    forState->GetStartPosition()->x = -7.5f;
    forState->GetLastPosition()->Set(forState->GetStartPosition());
    ret = true;
  }    
  if ( !ret && pos.y > 17.0f )
  {
    forState->SetNextState(NULL);
    forState->SetEndTime(NOW);
    forState->RecalcLastPosition();
    forState->SetProposedNext(STATE_IDLE);
    forState = player->ForceUpdate();
    forState->GetStartPosition()->y = 17.0f;
    forState->GetLastPosition()->Set(forState->GetStartPosition());
    ret = true;
  }

  return ret;
}



void CTeam::SetAi(bool bl)
{ 
  this->isAi = bl; 
  if (!bl)
  {
    this->teamNumber == TEAM_0 ? this->AddMask(ET_USER_1_INPUT) :this->AddMask(ET_USER_2_INPUT); 
  }
  else
  {
    this->teamNumber == TEAM_0 ? this->RemoveMask(ET_USER_1_INPUT) :this->RemoveMask(ET_USER_2_INPUT); 
  }
}

void CTeam::SelectPlayersForBlock(BlockData *pBlokData)
{
  mBlockCounter = 0;
  mBlockDirection = false;
  if(!this->isAi)
  {
    for (int i = 0; i < MAX_PLAYERS_IN_TEAM ;i ++)
    {
      //if (!Players[i]->GetIsOnPlane()) continue;
  
      PositionOnField position = Players[i]->GetPosOnField();
      if (position > POS_5) continue;
  
      //if (position == POS_0 || position == POS_1 || position == POS_2) continue;

      mInBlock = true;
     
      Players[i]->SaveBlokReturnPosition();

      switch(position)
      {
        case POS_0:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_0 For Defence on POS_DEFENDER_0", this->teamNumber);
#endif
          Players[i]->SetGotoPosition(POS_DEFENDER_0);
          Players[i]->SetPosOnField(POS_0); /* this is hack to fix SetGotoPosition settings */
        break;
        case POS_1:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_1 For Defence on POS_DEFENDER_1", this->teamNumber);
#endif
          Players[i]->SetGotoPosition(POS_DEFENDER_1);
          Players[i]->SetPosOnField(POS_1); /* this is hack to fix SetGotoPosition settings */

        break;
        case POS_2:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_2 For Defence on POS_DEFENDER_2", this->teamNumber);
#endif
          Players[i]->SetGotoPosition(POS_DEFENDER_2);
          Players[i]->SetPosOnField(POS_2); /* this is hack to fix SetGotoPosition settings */
        break;
        case POS_3:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_3 For Blok on POS_BLOK_0", this->teamNumber);
#endif
          Players[i]->SetPosOnField(POS_BLOK_0);
          Players[i]->SetGotoPosition(POS_BLOK_0);
          SetPlayerToZeroPriority(Players[i]);
        break;
        case POS_4:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_4 For Blok on POS_BLOK_1", this->teamNumber);
#endif
          Players[i]->SetPosOnField(POS_BLOK_1);
          Players[i]->SetGotoPosition(POS_BLOK_1);
          SetPlayerToZeroPriority(Players[i]);
        break;
        case POS_5:
#ifdef DEBUG
          LogError("Team %d : Sellect Player POS_5 For Blok on POS_BLOK_2", this->teamNumber);
#endif
          Players[i]->SetPosOnField(POS_BLOK_2);
          Players[i]->SetGotoPosition(POS_BLOK_2);
          SetPlayerToZeroPriority(Players[i]);
        break;
        default:
          /* idz na normalna pozycje twej POZYCJI :) */
          Players[i]->SetGotoPosition(position);
        break;
      }
    }
  }
  else
  {
#define CENTER_BLOK  0
#define LEFT_BLOK    1
#define RIGHT_BLOK   2
#define PLAYER_0     0
#define PLAYER_1     1
#define PLAYER_2     2

    CPlayer *BLOKER_I[3] = {NULL, NULL, NULL};
    CPlayer *BLOKER_II[3] = {NULL, NULL, NULL};
    CVector3 StartPos[3];
    float Times[9] = {0.0f};
    int i;

    /* obys wiedzail co robisz !!! */
    this->WorldToTeam(&pBlokData->HitPos);

    StartPos[CENTER_BLOK].Set( pBlokData->HitPos.x       , 0.5f, 0.0f);
    StartPos[LEFT_BLOK].Set  ( pBlokData->HitPos.x + 1.0f, 0.5f, 0.0f);
    StartPos[RIGHT_BLOK].Set ( pBlokData->HitPos.x - 1.0f, 0.5f, 0.0f);

    {
      int j = 0;
      PositionOnField position;
      /* wypelni tablice playerów */
      for (i = 0; i < MAX_PLAYERS_IN_TEAM ;i++)
      {
        if (Players[i]->CzyOdbijam()) continue;
        position = Players[i]->GetPosOnField();
        switch(position)
        {
          case POS_0:
#ifdef DEBUG
            LogError("Team %d : Auto Sellect Player POS_0 For Defence on POS_DEFENDER_0", this->teamNumber);
#endif
            Players[i]->SaveBlokReturnPosition();
            Players[i]->SetGotoPosition(POS_DEFENDER_0);
            Players[i]->SetPosOnField(POS_0); /* this is hack to fix SetGotoPosition settings */
          break;
          case POS_1:
#ifdef DEBUG
            LogError("Team %d : Auto Sellect Player POS_1 For Defence on POS_DEFENDER_1", this->teamNumber);
#endif
            Players[i]->SaveBlokReturnPosition();
            Players[i]->SetGotoPosition(POS_DEFENDER_1);
            Players[i]->SetPosOnField(POS_1); /* this is hack to fix SetGotoPosition settings */
          break;
          case POS_2:
#ifdef DEBUG
            LogError("Team %d : Auto Sellect Player POS_2 For Defence on POS_DEFENDER_2", this->teamNumber);
#endif
            Players[i]->SaveBlokReturnPosition();
            Players[i]->SetGotoPosition(POS_DEFENDER_2);
            Players[i]->SetPosOnField(POS_2); /* this is hack to fix SetGotoPosition settings */
          break;       
          case POS_3:
          case POS_4:          
          case POS_5:
            BLOKER_I[j++] = Players[i];
          break;
          default:
            continue;
          break;
        }
        if(j > 2) break;
      }
    }

    if (!BLOKER_I[0])
    {
#ifdef DEBUG
      LogError("Team %d : Auto Sellect Player For Blok : Can't find free player", this->teamNumber);
#endif
      return;
    }

    {
      int j;
      State *LastState;
      /* wypelni tablice czasow dla kazadego playera do kazdego punku bloku */
      for(i = 0 ;i < 3 && BLOKER_I[i]; i++ )
      {
        for(j = 0 ;j < 3 ; j++ )
        {
          //this->GetMoveStates(BLOKER_I[i], &StartPos[j] ,false, false);
          //LastState = BLOKER_I[i]->GetCurrentState()->GetLast();
          LastState = this->GetMoveStates(BLOKER_I[i], &StartPos[j]);
          if(LastState)
          {
            Times[i * 3 + j] = LastState->GetEndTime();
            BLOKER_I[i]->GetCurrentState()->SetNextState(NULL);
          }
        }
      }
    }

    {
      /* Znajdz playera do centralnego bloku */
      int player = -1;
      float best = pBlokData->HitTime + 0.25f;

      if(Times[0] && best > Times[0]) {best = Times[0]; player = PLAYER_0;};
      if(Times[3] && best > Times[3]) {best = Times[3]; player = PLAYER_1;};
      if(Times[6] && best > Times[6]) {best = Times[6]; player = PLAYER_2;};

      if(best > pBlokData->HitTime)
      {
#ifdef DEBUG
        LogError("Team %d : Auto Sellect Player For Blok : No time to Block !", this->teamNumber);
#endif
        return;
      }
      BLOKER_II[CENTER_BLOK] = BLOKER_I[player];
      BLOKER_I[player] = NULL;
      Times[player * 3    ] = 0.0f;
      Times[player * 3 + 1] = 0.0f;
      Times[player * 3 + 2] = 0.0f;
    }

    /* znajz pierwszego wolnego playera (sprawdza czy blok robi tylko centralny) */
    i = 0;
    while(i < 3 && !BLOKER_I[i]) i++;
    if(i < 3)
    {
      /* Ten algorytm jest zly i tyle a w dodatku (oby) dziala tylko dla 3 blokujacych playerow */
      int PL = -1, PR = -1, PL_prev = -1, PR_prev = -1;
      float bestLeft  = pBlokData->HitTime + 0.25f;
      float bestRight = pBlokData->HitTime + 0.25f;
      
      /* znajdz najlebszy czas dojscia do lewego bloku i zapamietaj playera */
      if(Times[1] && bestLeft > Times[1]) {bestLeft = Times[1]; PL = PLAYER_0;};
      if(Times[4] && bestLeft > Times[4])
      {
        bestLeft = Times[4];
        if (PLAYER_1 != PL)
        {
          PL_prev = PL;
        }
        PL = PLAYER_1;
      }
      else
      {
        if(Times[4] && PL != -1)
        {
          PL_prev = PLAYER_1;
        }
      }
      if(Times[7] && bestLeft > Times[7])
      {
        bestLeft = Times[7];
        if(PLAYER_2 != PL)
        {
          PL_prev = PL;
        }
        PL = PLAYER_2;
      }
      else
      {
        if(Times[7] && PL != -1)
        {
          PL_prev = PLAYER_2;
        }
      }

      /* znajdz najlebszy czas dojscia do prawego bloku i zapamietaj playera */
      if(Times[2] && bestRight > Times[2]) {bestRight = Times[2]; PR = PLAYER_0;};
      if(Times[5] && bestRight > Times[5])
      {
        bestRight = Times[5];
        if(PLAYER_1 != PR)
        {
          PR_prev = PR;
        }
        PR = PLAYER_1;
      }
      else
      {
        if(Times[5] && PR != -1)
        {
          PR_prev = PLAYER_1;
        }
      }
      if(Times[8] && bestRight > Times[8])
      {
        bestRight = Times[8];
        if(PLAYER_2 != PR)
        {
          PR_prev = PR;
        }
        PR = PLAYER_2;
      }
      else
      {
        if(Times[8] && PR != -1)
        {
          PR_prev = PLAYER_2;
        }
      }

      /* sprawdz czy najlebsze czasy ma ten sam player */
      if(PL == PR && PL != -1)
      {
        if(bestLeft <= bestRight)
        {
          /*
           * Sprawdz czy istnieje poprzedni zapamietany player o gorszym czasie dojscia do
           * prawego bloku. Jsli intnieje to uzyj go do dojscia do prawego bloku.
           * Jesli nie istieje to nie mamy innego czasu dojsia, mniejszego od
           * czasu odbicia.
           */
          if(PR_prev != -1)
          {
            bestRight = Times[PR_prev * 3 + 2];
            PR = PR_prev;
          }
          else
          {
            /*
             * Sprawdz czy istnieje poprzedni zapamietany player o gorszym czasie dojscia do
             * lewego bloku. Jsli intnieje to uzyj go do dojscia do lewego bloku.
             * Jesli nie istieje to nie mamy innego czasu dojsia mniejszego od
             * czasu odbicia.
             */
            if(PL_prev != -1)
            {
              bestLeft = Times[PL_prev * 3 + 1];
              PL = PL_prev;
            }
            else
            {
               /*
                * Mamy tylko jednego playera do wykonania lewego i prawego bloku
                * Idziemy tak gdzie jest krutszy czas dojcia.
                * Tutaj na lewo.
                */
                bestRight = pBlokData->HitTime + 0.25f;
                PR = -1;
            }
          }
        }
        else
        {
          /*
           * Sprawdz czy istnieje poprzedni zapamietany player o gorszym czasie dojscia do
           * lewego bloku. Jsli intnieje to uzyj go do dojscia do lewego bloku.
           * Jesli nie istieje to nie mamy innego czasu dojsia mniejszego od
           * czasu odbicia.
           */
          if(PL_prev != -1)
          {
            bestLeft = Times[PL_prev * 3 + 1];
            PL = PL_prev;
          }
          else
          {
            /*
             * Sprawdz czy istnieje poprzedni zapamietany player o gorszym czasie dojscia do
             * prawego bloku. Jsli intnieje to uzyj go do dojscia do prawego bloku.
             * Jesli nie istieje to nie mamy innego czasu dojsia, mniejszego od
             * czasu odbicia.
             */
            if(PR_prev != -1)
            {
              bestRight = Times[PR_prev * 3 + 2];
              PR = PR_prev;
            }
            else
            {
               /*
                * Mamy tylko jednego playera do wykonania lewego i prawego bloku
                * Idziemy tak gzej est krutszy czas dojcia.
                * Tutaj na prawo.
                */
                bestLeft = pBlokData->HitTime + 0.25f;
                PL = -1;
            }
          }
        }
      }

      if(bestLeft <= pBlokData->HitTime)
      {
        BLOKER_II[LEFT_BLOK] = BLOKER_I[PL];
        BLOKER_I[PL] = NULL;
      };

      
      if(bestRight <= pBlokData->HitTime)
      {
        BLOKER_II[RIGHT_BLOK] = BLOKER_I[PR];
        BLOKER_I[PR] = NULL;
      };

      /* ustaw wlasciwa kolejnosc nadawania zerowego priorytetu dojscia */
      if(bestLeft <= bestRight)
      {
        if(BLOKER_II[RIGHT_BLOK])
        {
#ifdef DEBUG
          LogError("Team %d : Auto Sellect Player %d For Blok on POS_BLOK_3", this->teamNumber, BLOKER_II[RIGHT_BLOK]->GetPosOnField());
#endif
          BLOKER_II[RIGHT_BLOK]->SaveBlokReturnPosition();
          BLOKER_II[RIGHT_BLOK]->SetPosOnField(POS_BLOK_3);
          BLOKER_II[RIGHT_BLOK]->SetPosFromTactic(&StartPos[RIGHT_BLOK]);
          SetPlayerToZeroPriority(BLOKER_II[RIGHT_BLOK]);
        }

        if(BLOKER_II[LEFT_BLOK])
        {
#ifdef DEBUG
          LogError("Team %d : Auto Sellect Player %d For Blok on POS_BLOK_4", this->teamNumber, BLOKER_II[LEFT_BLOK]->GetPosOnField());
#endif
          BLOKER_II[LEFT_BLOK]->SaveBlokReturnPosition();
          BLOKER_II[LEFT_BLOK]->SetPosOnField(POS_BLOK_4);
          BLOKER_II[LEFT_BLOK]->SetPosFromTactic(&StartPos[LEFT_BLOK]);
          SetPlayerToZeroPriority(BLOKER_II[LEFT_BLOK]);
        }
      }
      else
      {
        if(BLOKER_II[LEFT_BLOK])
        {
#ifdef DEBUG
          LogError("Team %d : Auto Sellect Player %d For Blok on POS_BLOK_4", this->teamNumber, BLOKER_II[LEFT_BLOK]->GetPosOnField());
#endif
          BLOKER_II[LEFT_BLOK]->SaveBlokReturnPosition();
          BLOKER_II[LEFT_BLOK]->SetPosOnField(POS_BLOK_4);
          BLOKER_II[LEFT_BLOK]->SetPosFromTactic(&StartPos[LEFT_BLOK]);
          SetPlayerToZeroPriority(BLOKER_II[LEFT_BLOK]);
        }

        if(BLOKER_II[RIGHT_BLOK])
        {
#ifdef DEBUG
          LogError("Team %d : Auto Sellect Player %d For Blok on POS_BLOK_3", this->teamNumber, BLOKER_II[RIGHT_BLOK]->GetPosOnField());
#endif
          BLOKER_II[RIGHT_BLOK]->SaveBlokReturnPosition();
          BLOKER_II[RIGHT_BLOK]->SetPosOnField(POS_BLOK_3);
          BLOKER_II[RIGHT_BLOK]->SetPosFromTactic(&StartPos[RIGHT_BLOK]);
          SetPlayerToZeroPriority(BLOKER_II[RIGHT_BLOK]);
        }
      }
    }

    if(BLOKER_II[CENTER_BLOK])
    {
#ifdef DEBUG
      LogError("Team %d : Auto Sellect Player %d For Blok on POS_BLOK_1", this->teamNumber, BLOKER_II[CENTER_BLOK]->GetPosOnField());
#endif
      BLOKER_II[CENTER_BLOK]->SaveBlokReturnPosition();
      BLOKER_II[CENTER_BLOK]->SetPosOnField(POS_BLOK_1);
      BLOKER_II[CENTER_BLOK]->SetPosFromTactic(&StartPos[CENTER_BLOK]);
      SetPlayerToZeroPriority(BLOKER_II[CENTER_BLOK]);
    }
    
    mInBlock = true;

#undef CENTER_BLOK
#undef LEFT_BLOK
#undef RIGHT_BLOK
#undef PLAYER_0
#undef PLAYER_1
#undef PLAYER_2

  }

}

bool CTeam::CommenceBlock()
{
#ifdef DEBUG
  LogError("Team %d : CommenceBlock", this->teamNumber);
#endif
  BallBlockStruct *bs = new BallBlockStruct;
  bs->TeamNum = this->teamNumber;
  bs->NumBlocking = 0;

  float CurrentTime = NOW;
  float HitDuration = CurrentTime + Players[0]->GetHitDuration(PRZYJECIE_BLOK);
  CVector3 BallOffset = AnimationManager::Instance()->
            GetAnimation(Players[0]->GetStateAnimationHandler(PRZYJECIE_BLOK,0))->GetBallOffset();

  CBlocker::Instance()->Hide();
  PositionOnField position;
  for (int i = 0 ; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    position = Players[i]->GetPosOnField();

    if ( Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK ||
         Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_END_BLOK ) continue;

    if (!Players[i]->IsBlocking())
      {
      Players[i]->SetPosOnField(Players[i]->GetRealPosition(position));
      continue;
    }

    Players[i]->ClearUserMask();
    Players[i]->SetAI(true);
    Players[i]->ClearBlocking();

    Players[i]->GetCurrentState()->SetNextState(NULL);

    if((Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK_HINT ||
         Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK_STEP_LEFT ||
         Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK_STEP_RIGHT))
    {
      Players[i]->GetCurrentState()->SetProposedNext(PRZYJECIE_BLOK);
      Players[i]->SetOdbijam(true);    

      bs->BlockTimes[bs->NumBlocking] = HitDuration;
      Players[i]->GetCurrentPosition(&bs->BlockPositions[bs->NumBlocking]);
      bs->BlockPositions[bs->NumBlocking] += BallOffset;
      bs->BlockPositions[bs->NumBlocking].z *= Players[i]->GetHeightScale();
      TeamToWorld(&bs->BlockPositions[bs->NumBlocking]);
      bs->NumBlocking++;
#ifdef DEBUG
      LogError("Team %d : Player %d , Make Blok", this->teamNumber , Players[i]->GetPosOnField());
#endif
    }
    else
    {
      Players[i]->GetCurrentState()->SetProposedNext(STATE_IDLE);
      Players[i]->SetPosOnField(Players[i]->GetRealPosition(position));
#ifdef DEBUG
      LogError("Team %d : Player %d , CM : Cancle Blok", this->teamNumber , position);
#endif
    }

    Players[i]->GetCurrentState()->SetEndTime(CurrentTime);
    if(bs->NumBlocking > 2) break;
    
  }
  mInBlock = false;

  bool ret = false;
  if (bs->NumBlocking == 0)
  {
    delete bs;
  }
  else
  {
    ret = CBall::Instance()->TestForBlock(bs);
    //POST_EVENT(ET_BALL, BE_TRYING_TO_BLOCK, true, bs);
  }
  
  return ret;
}

void CTeam::CancelBlock()
{

  CBlocker::Instance()->Hide();
  for (int i = 0 ; i < MAX_PLAYERS_IN_TEAM; i++)
  {

    if ( Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK ||
         Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_END_BLOK) 
    {
#ifdef DEBUG
      LogError("Team %d : Player on %d : Nie moge Anulowac bloku Bo Go Robie!", this->teamNumber, Players[i]->GetPosOnField());
#endif
      continue;
    }

    Players[i]->SetPosOnField(Players[i]->GetRealPosition(Players[i]->GetPosOnField()));

    if (!Players[i]->IsBlocking())
    {
      continue;
    }

    Players[i]->ClearUserMask();
    Players[i]->SetAI(true);
    Players[i]->ClearBlocking();

    
    Players[i]->GetCurrentState()->SetNextState(NULL);
    Players[i]->GetCurrentState()->SetProposedNext(STATE_IDLE);
    Players[i]->GetCurrentState()->SetEndTime(NOW);
            
  }
  mInBlock = false;
}

void CTeam::ReorderBlockPositions(void)
{
  CPlayer *PlayerTab[3] = {NULL, NULL, NULL};
  CPlayer *PlayerDeffendTab[2] = {NULL, NULL};
  int i;

    mBlockCounter++;
  if(mBlockCounter > 2)
    {
    mBlockCounter = 0;
  }

  PositionOnField position;

  for (i = 0 ; i < MAX_PLAYERS_IN_TEAM; i++)
  {

    if ( Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_BLOK ||
         Players[i]->GetCurrentState()->GetCurrent() == PRZYJECIE_END_BLOK) continue;

    position = Players[i]->GetPosOnField();

    if (!Players[i]->IsBlocking() && position != POS_3 && position != POS_5) continue;

    switch(position)
    {
      case POS_BLOK_0:
      case POS_BLOK_3:
      case POS_BLOK_5:
        PlayerTab[0] = Players[i];
      break;
      case POS_BLOK_1:
      case POS_BLOK_6:
      case POS_BLOK_7:
        PlayerTab[1] = Players[i];
      break;
      case POS_BLOK_2:
      case POS_BLOK_4:
      case POS_BLOK_8:
        PlayerTab[2] = Players[i];
      break;
      case POS_3:
        PlayerDeffendTab[0] = Players[i];
      break;
      case POS_5:
        PlayerDeffendTab[1] = Players[i];
      break;
      default:
        break;
    }
  }

  /* Hack i to niebezpieczny */
  if (PlayerTab[0])
  {
    PlayerTab[0]->ClearUserMask();
    PlayerTab[0]->SetAI(true);
  }
  if (PlayerTab[1])
  {
    PlayerTab[1]->ClearUserMask();
    PlayerTab[1]->SetAI(true);
  }
  if (PlayerTab[2])
  {
    PlayerTab[2]->ClearUserMask();
    PlayerTab[2]->SetAI(true);
  }

  switch(mBlockCounter)
  {
    case 0:
      if (PlayerTab[0])
      {
        PlayerTab[0]->SetPosOnField(POS_BLOK_0);
        PlayerTab[0]->SetGotoPosition(POS_BLOK_0);
      }
      else
      {
        if (PlayerDeffendTab[0])
        {
          PlayerDeffendTab[0]->SetPosOnField(POS_BLOK_0);
          PlayerDeffendTab[0]->SetGotoPosition(POS_BLOK_0);
        }
      }
      if (PlayerTab[1])
      {
        PlayerTab[1]->SetPosOnField(POS_BLOK_1);
        PlayerTab[1]->SetGotoPosition(POS_BLOK_1);
      }
      if (PlayerTab[2])
      {
        PlayerTab[2]->SetPosOnField(POS_BLOK_2);
        PlayerTab[2]->SetGotoPosition(POS_BLOK_2);
      }
      else
      {
        if (PlayerDeffendTab[1])
        {
          PlayerDeffendTab[1]->SetPosOnField(POS_BLOK_2);
          PlayerDeffendTab[1]->SetGotoPosition(POS_BLOK_2);
        }
      }
    break;
    case 1:
        if (PlayerTab[0])
        {
        PlayerTab[0]->SetPosOnField(POS_BLOK_3);
        PlayerTab[0]->SetGotoPosition(POS_BLOK_3);
        }
        if (PlayerTab[1])
        {
        PlayerTab[1]->SetPosOnField(POS_BLOK_1);
        PlayerTab[1]->SetGotoPosition(POS_BLOK_1);
        }
        if (PlayerTab[2])
        {
        PlayerTab[2]->SetPosOnField(POS_BLOK_4);
        PlayerTab[2]->SetGotoPosition(POS_BLOK_4);
      }
    break;
    case 2:
      {
      CVector3 ball;
      ball.Set(CBall::Instance()->GetCurrentBallPosition());
      WorldToTeam(&ball);

      if(ball.x > 0)
        {
        if (PlayerTab[2])
        {
          PlayerTab[2]->SetPosOnField(POS_BLOK_8);
          PlayerTab[2]->SetGotoPosition(POS_BLOK_8);
        }
        if (PlayerTab[1])
        {
          PlayerTab[1]->SetPosOnField(POS_BLOK_7);
          PlayerTab[1]->SetGotoPosition(POS_BLOK_7);
        }
        if (PlayerTab[0])
        {
          PlayerTab[0]->SetGotoPosition(POS_DEFENDER_3);
          PlayerTab[0]->SetPosOnField(POS_3);
          PlayerTab[0]->ClearBlocking();
        }
      }
      else
      {
        if (PlayerTab[2])
        {
          PlayerTab[2]->SetGotoPosition(POS_DEFENDER_4);
          PlayerTab[2]->SetPosOnField(POS_5);
          PlayerTab[2]->ClearBlocking();
        }
        if (PlayerTab[1])
        {
          PlayerTab[1]->SetPosOnField(POS_BLOK_6);
          PlayerTab[1]->SetGotoPosition(POS_BLOK_6);
      }
      if (PlayerTab[0])
      {
        PlayerTab[0]->SetPosOnField(POS_BLOK_5);
        PlayerTab[0]->SetGotoPosition(POS_BLOK_5);
      }
      }
      }
    break;
    
  }
}

void CTeam::LiberoSchodzi()
{
  int i;
  CPlayer *pLibero = NULL;
  CPlayer *pSubstitute = NULL;
  CPlayer *pSecondSubstitute = NULL;
  enum PositionOnField out = POS_2;
  for (i = 0; i < MAX_PLAYERS_IN_TEAM ; i++)
  {
    if(this->Players[i]->GetPosOnField() == out)
    {
      if(this->Players[i]->IsMain())
      {
        out = POS_1;
      }
      break;
    }
  }
  for (i = 0; i < MAX_PLAYERS_IN_TEAM ; i++)
  {
     if ( this->Players[i]->IsLibero() ) pLibero = Players[i];
     if ( this->Players[i]->IsLiberoSubstitute() ) pSubstitute = Players[i];
     if ( this->Players[i]->GetPosOnField() == out ) pSecondSubstitute = Players[i];
  }
  if (!pLibero || !pSubstitute)
  {
#ifdef DEBUG
    LogError("TEAM_%i : Nie znalazlem libero, albo zastepcy!", this->teamNumber);
#endif
    return;
  }
  DIE (pLibero != pSubstitute);
  
  //CVector3 posLibero,posSubstitute;
  //pLibero->GetCurrentPosition(&posLibero);
  //pSubstitute->GetCurrentPosition(&posSubstitute);
//  pSubstitute->SetIsOnPlane(true);
//  GetMoveStates(pLibero,&posSubstitute,true,true);
//  GetMoveStates(pSubstitute,&posLibero,true,true);
//  pLibero->SetIsOnPlane(false);
  PositionOnField Lpos = pLibero->GetPosOnField();
  PositionOnField Spos = pSubstitute->GetPosOnField();
  PositionOnField SSpos = pSecondSubstitute->GetPosOnField();
  pLibero->SetGotoPosition(SSpos);
  pSubstitute->SetGotoPosition(Lpos);//Lpos);
  pSecondSubstitute->SetGotoPosition(Spos);

  int pri = pLibero->GetPriority();
  pLibero->SetPriority(pSecondSubstitute->GetPriority());
  pSecondSubstitute->SetPriority(pSubstitute->GetPriority());
  pSubstitute->SetPriority(pri);
  pSubstitute->SetLiberoSubstitute(false);
  pSubstitute->GetCurrentState()->SetEndTime(NOW);
  pSubstitute->GetCurrentState()->SetProposedNext(STAND_UP);
  //pSubstitute->GetCurrentState()->GetNext();
  pSubstitute->ForceUpdate();
  pSecondSubstitute->SetLiberoSubstitute(true);
  if (this->teamNumber == TEAM_0)
  {
    pSecondSubstitute->RemoveMask(ET_TEAM_0_PLAYER);
    pSecondSubstitute->AddMask(ET_TEAM_0_SUB);
    pSubstitute->RemoveMask(ET_TEAM_0_SUB);
    pSubstitute->AddMask(ET_TEAM_0_PLAYER);
  }
  else
  {
    pSecondSubstitute->RemoveMask(ET_TEAM_1_PLAYER);
    pSecondSubstitute->AddMask(ET_TEAM_1_SUB);
    pSubstitute->RemoveMask(ET_TEAM_1_SUB);
    pSubstitute->AddMask(ET_TEAM_1_PLAYER);
  }

}


void CTeam::LiberoWchodzi()
{
  CPlayer *pLibero = NULL;
  CPlayer *pSubstitute = NULL;

  for (int i = 0; i < MAX_PLAYERS_IN_TEAM ; i++)
  {
     if ( this->Players[i]->IsLibero() ) pLibero = Players[i];
     if ( this->Players[i]->IsLiberoSubstitute()) pSubstitute = Players[i];
  }
  if (!pLibero || !pSubstitute)
  {
#ifdef DEBUG
    LogError("TEAM_%i : Nie znalazlem libero, albo zastepcy!", this->teamNumber);
#endif
    return;
  }
  DIE (pLibero != pSubstitute);
 
  CVector3 posLibero,posSubstitute;
  pLibero->GetCurrentPosition(&posLibero);
  pSubstitute->GetCurrentPosition(&posSubstitute);

  pLibero->SetIsOnPlane(true);
  //GetMoveStates(pLibero,&posSubstitute,true,true);
  //GetMoveStates(pSubstitute,&posLibero,true,true);
 // pSubstitute->SetIsOnPlane(false);
  PositionOnField pos = pLibero->GetPosOnField();
  pLibero->SetGotoPosition(pSubstitute->GetPosOnField());
  pSubstitute->SetGotoPosition(pos);
  
}


void CTeam::RotateSubs()
{
  for ( int i=0; i < MAX_PLAYERS_IN_TEAM; i++)
  {
    PositionOnField pos = this->Players[i]->GetPosOnField();
    if (pos < SUB_0 || pos > SUB_5) continue;
    this->Players[i]->SetStartPosition(this->Players[i]->GetPosOnField());
    this->Players[i]->GetCurrentState()->SetEndDir(GetSubDirection());
    this->Players[i]->GetCurrentState()->SetDir(GetSubDirection());
  }
}

Direction CTeam::GetSubDirection()
{ 
  if (CGame::Instance()->GetRotatedTeam() == this->teamNumber)
  {
    return ANGLE_270;
  }
  else
  {
    return ANGLE_90;
  }
}
E:\Project\Kopia (5) VBEngine\Core\Team.h
#ifndef _TEAM_H
#define _TEAM_H

/*
class       : CPlayer
description : Reprezentuje dane i logike gracza, moze on byc sterowany przez AI albo przez usera

methods     : int Init(char *teamname); - inicjalizuje gracza z pliku modeli, wywolywana jest z konstruktora
              void GetMoveStates(CPlayer * player, CVector3 * newPosition) - dla danego playera zwraca
                  liste stanow potrzebna aby ten doszedl do danego punktu
*/



enum TeamPhase
{ 
  TP_DEFENCE = -1,
  TP_RECEIVE_1 = 0,
  TP_RECEIVE_2,
  TP_RECEIVE_3,
};

//class CTactic;
class CPlayer;
class State;
struct BlockData;
class AStarSolver;

class CTeam : EventHandler
{
  CPlayer *Players[MAX_PLAYERS_IN_TEAM];
  int teamNumber;
  int Init(char *teamname, bool GenShirt);
  CMatrix4 mTeamMatrix;
  
  int BlockChance[MAX_BLOCK_CHANCES];
  float BlockRadius;

  int mTeamPhase;

  unsigned char mPointCount;
  unsigned char mHitCount;// licznik podan na mojej polowie

  int lastPhaseInd;

  HPhase mTacticPhase[MAX_TACTIC_PHASES]; //obecna taktyka
  HPhase mCurrentPhase;

  //CTactic *pCurrentTactic;
  CPlayer *pControledPlayer;
  CPlayer *pReceivingPlayer;
  //char mCurrentTactic;
  bool mIsSomeoneReceiving;
  bool mIsServing, mIsBallOwner;  
  bool isAi;
  bool mScinam;
  bool mBedeScinac;
  bool mBedePrzebijac;
  bool mOdbijam;
  bool mInBlock;
  //float mBlockKeypressTime;
  bool mBlockHoldingOffReceive;
  //CPlayer *mBlockingPlayers[MAX_PLAYERS_ON_FIELD];
  bool mBlockDirection;

  int mBlockCounter;
  HTexture TeamTexture;
  HTexture TeamLiberoTexture;
  HTexture TeamShoeTexture;
  float mTeamQuality;
  AStarSolver *mASolver;
  char *mTeamName;
  char *mTeamShortName;
  int mHomeStadium;
public:
  CTeam(char *teamname, TeamNumber teamNum, bool GenShirt);
  ~CTeam(); 
  HTexture GetTeamTexture(void) {return this->TeamTexture;};
  HTexture GetTeamLiberoTexture(void) {return this->TeamLiberoTexture;};
  void DeInit();
  void Update();
  void ProcessEvent(Event *event);
  bool CanBlock(float alpha01);
  float GetBlockRadius(void) {return this->BlockRadius;}
  CMatrix4 *GetTeamMatrix() {return &mTeamMatrix;};
  int GetTeamNumber() {return teamNumber;};
  CPlayer *GetPlayer(unsigned int index) {return this->Players[index];};
  CVector3 *TeamToWorld(CVector3 *vec);
  CVector3 *WorldToTeam(CVector3 *vec);
  CVector3 *ModSubPosition(CVector3 *vec);
  float AngleTeamToWorld(float angle);
  unsigned int  TranslateControls(unsigned int key);
  
  void SetUserFromTeam(CPlayer *selPlayer);
  State *GetMoveStates(CPlayer * player, CVector3 * newPosition);
  State *GetMoveStates(CPlayer * player, State* forState, CVector3 * newPosition);
  
  void SelectPlayerForReceive(CVector3 *target, int phase);
  bool IsPointInField (CVector3 *point);
  void ResetPositions();
  void ResetSettins();
  void SetPhase(int phaseNum);
  void MakeServing(void) {mIsServing = true; mIsBallOwner = true;};
  int GetPhase() {return mTeamPhase;};
  
  bool IsBallOwner() {return mIsBallOwner;};
  void ClearBallOwner() {mIsBallOwner = false;};
  unsigned char GetHits() {return mHitCount;};
  bool IsServing() {return mIsServing;}
  void RotatePlayers();
  bool IsPointInTheOtherField(CVector3 *point);
  bool IsWorldPointInTheOtherField(CVector3 *point);
  bool IsCurrentTargetValid(unsigned char phase);


  bool IsAi() { return this->isAi; }
  void SetAi(bool bl);
  void SetPlayerToZeroPriority(CPlayer *player);
  void SetPlayerToPriority(CPlayer *player, int priority);
  int  GetPlayerIndByPriority(int priority);
  
  CPlayer *GetPlayer(int i) { return Players[i]; }
  bool IsSomeoneReceiving() {return mIsSomeoneReceiving;}
  void SelectPlayersForBlock(BlockData *pBlokData);
  bool FixFieldPositions(CPlayer *player);
  bool ValidatePlayersPriority(void);
  bool CommenceBlock();
  void CancelBlock();
  void ReorderBlockPositions();
  HTexture GetShoeTexture() {return this->TeamShoeTexture;}
  void LiberoWchodzi();
  void LiberoSchodzi();

  void RotateSubs();
  Direction GetSubDirection();

  char * GetTeamName() {return mTeamName;}
  char * GetTeamShortName() {return mTeamShortName;}
  int GetHomeStadium() {return mHomeStadium;}
};



#endif /* _TEAM_H */
E:\Project\Kopia (5) VBEngine\Core\User.cpp
#include <assert.h>
#include <stdio.h>
#include "..\utility\defines.h"

#include "..\Utility\Event.h"

#include "User.h"

#include "..\Utility\conf.h"

#include "..\Utility\tools.h"

typedef struct _KeybindStruct
{
  const char *NiceKeyName;
  const char *KeyName;
  unsigned short binding;
}KeybindStruct;

const char *sKeyMaps[] =
{
 "MAPKEY_UP",
 "MAPKEY_DOWN",
 "MAPKEY_LEFT",
 "MAPKEY_RIGHT",
 "MAPKEY_1",
 "MAPKEY_2",
 "MAPKEY_3",
 "MAPKEY_4"
};




KeybindStruct sKeyBindings[] = 
      {{"ESCAPE",     "VBKEY_ESCAPE",  0x01},
        {"1",        "VBKEY_1",       0x02},
        {"2",        "VBKEY_2",       0x03},
        {"3",        "VBKEY_3",       0x04},
        {"4",        "VBKEY_4",       0x05},
        {"5",        "VBKEY_5",       0x06},
        {"6",        "VBKEY_6",       0x07},
        {"7",        "VBKEY_7",       0x08},
        {"8",        "VBKEY_8",       0x09},
        {"9",        "VBKEY_9",       0x0A},
        {"0",        "VBKEY_0",       0x0B},
        {"MINUS",    "VBKEY_MINUS",   0x0C}, 
        {"EQUALS",    "VBKEY_EQUALS",  0x0D},
        {"BACK",     "VBKEY_BACK",    0x0E},   
        {"TAB",      "VBKEY_TAB",     0x0F},
        {"Q",        "VBKEY_Q",       0x10},
        {"W",        "VBKEY_W",       0x11},
        {"E",        "VBKEY_E",       0x12},
        {"R",        "VBKEY_R",       0x13},
        {"T",        "VBKEY_T",       0x14},
        {"Y",        "VBKEY_Y",       0x15},
        {"U",        "VBKEY_U",       0x16},
        {"I",        "VBKEY_I",       0x17},
        {"O",        "VBKEY_O",       0x18},
        {"P",        "VBKEY_P",       0x19},
        {"LBRACK",   "VBKEY_LBRACKET",0x1A},
        {"RBRACK",   "VBKEY_RBRACKET",0x1B},
        {"RETURN",   "VBKEY_RETURN",  0x1C},    
        {"LEFT CTRL","VBKEY_LCONTROL",0x1D},
        {"A",        "VBKEY_A",       0x1E},
        {"S",        "VBKEY_S",       0x1F},
        {"D",        "VBKEY_D",       0x20},
        {"F",        "VBKEY_F",       0x21},
        {"G",        "VBKEY_G",       0x22},
        {"H",        "VBKEY_H",       0x23},
        {"J",        "VBKEY_J",       0x24},
        {"K",        "VBKEY_K",       0x25},
        {"L",        "VBKEY_L",       0x26},
        {"SEMICO",   "VBKEY_SEMICOLON",      0x27},
        {"APOSTR",   "VBKEY_APOSTROPHE",     0x28},
        {"GRAVE",    "VBKEY_GRAVE",   0x29},   
        {"LEFT SHIFT","VBKEY_LSHIFT",  0x2A},
        {"BACKSLASH","VBKEY_BACKSLASH",      0x2B},
        {"Z",        "VBKEY_Z",       0x2C},
        {"X",        "VBKEY_X",       0x2D},
        {"C",        "VBKEY_C",       0x2E},
        {"V",        "VBKEY_V",       0x2F},
        {"B",        "VBKEY_B",       0x30},
        {"N",        "VBKEY_N",       0x31},
        {"M",        "VBKEY_M",       0x32},
        {"COMMA",    "VBKEY_COMMA",   0x33},
        {"PERIOD",   "VBKEY_PERIOD",  0x34},    
        {"SLASH",    "VBKEY_SLASH",   0x35},   
        {"RIGHT SHIFT","VBKEY_RSHIFT",  0x36},
        {"MULTIP",    "VBKEY_MULTIPLY",0x37},   
        {"LMENU" ,   "VBKEY_LMENU",   0x38},    
        {"SPACE",    "VBKEY_SPACE",   0x39},
        {"CAPS LOCK","VBKEY_CAPITAL", 0x3A},
        {"F1",       "VBKEY_F1",      0x3B},
        {"F2",       "VBKEY_F2",      0x3C},
        {"F3",       "VBKEY_F3",      0x3D},
        {"F4",       "VBKEY_F4",      0x3E},
        {"F5",       "VBKEY_F5",      0x3F},
        {"F6",       "VBKEY_F6",      0x40},
        {"F7",       "VBKEY_F7",      0x41},
        {"F8",       "VBKEY_F8",      0x42},
        {"F9",       "VBKEY_F9",      0x43},
        {"F10",      "VBKEY_F10",     0x44},
        {"NUM LOCK", "VBKEY_NUMLOCK", 0x45},
        {"SCROLL LOCK", "VBKEY_SCROLL",  0x46},   
        {"NUMPAD 7", "VBKEY_NUMPAD7", 0x47},
        {"NUMPAD ",  "VBKEY_NUMPAD8", 0x48},
        {"NUMPAD ",  "VBKEY_NUMPAD9", 0x49},
        {"NUMPAD MINUS",     "VBKEY_SUBTRACT",0x4A},   
        {"NUMPAD 4",  "VBKEY_NUMPAD4", 0x4B},
        {"NUMPAD 5", "VBKEY_NUMPAD5", 0x4C},
        {"NUMPAD 6", "VBKEY_NUMPAD6", 0x4D},
        {"NUMPAD PLUS", "VBKEY_ADD",     0x4E},   
        {"NUMPAD 1", "VBKEY_NUMPAD1", 0x4F},
        {"NUMPAD 2", "VBKEY_NUMPAD2", 0x50},
        {"NUMPAD 3", "VBKEY_NUMPAD3", 0x51},
        {"NUMPAD 0", "VBKEY_NUMPAD0", 0x52},
        {"DELETE",   "VBKEY_DECIMAL", 0x53},    
        {"OEM_102",   "VBKEY_OEM_102", 0x56},   
        {"F11",      "VBKEY_F11",     0x57},
        {"F12",      "VBKEY_F12",     0x58},
        {"F13",      "VBKEY_F13",     0x64},  
        {"F14",      "VBKEY_F14",     0x65},  
        {"",         "VBKEY_F15",     0x66},  
        {"KANA",     "VBKEY_KANA",    0x70}, 
        {"ABNT_C",   "VBKEY_ABNT_C1", 0x73},
        {"CONVER",   "VBKEY_CONVERT", 0x79},  
        {"NOCONV",   "VBKEY_NOCONVERT",       0x7B},
        {"YEN",      "VBKEY_YEN",     0x7D},
        {"ABNT_C",   "VBKEY_ABNT_C2", 0x7E}, 
        {"NUMPAD",   "VBKEY_NUMPADEQUALS",    0x8D},
        {"PREVTR",   "VBKEY_PREVTRACK",       0x90},
        {"AT",       "VBKEY_AT",      0x91},
        {"COLON",    "VBKEY_COLON",   0x92},
        {"UNDERL",   "VBKEY_UNDERLINE",       0x93},
        {"KANJI",    "VBKEY_KANJI",   0x94},
        {"STOP",     "VBKEY_STOP",    0x95},
        {"AX",       "VBKEY_AX",      0x96},
        {"UNLABE",   "VBKEY_UNLABELED",       0x97},
        {"NEXTTR",   "VBKEY_NEXTTRACK",       0x99},
        {"NUMPAD",   "VBKEY_NUMPADENTER",     0x9C},
        {"RIGHT CTRL", "VBKEY_RCONTROL",0x9D},
        {"MUTE",     "VBKEY_MUTE",    0xA0},
        {"CALCUL",     "VBKEY_CALCULATOR",      0xA1},
        {"PLAYPA",     "VBKEY_PLAYPAUSE",       0xA2},
        {"MEDIAS",     "VBKEY_MEDIASTOP",       0xA4},
        {"VOLUME",    "VBKEY_VOLUMEDOWN",      0xAE},
        {"VOLUME ",    "VBKEY_VOLUMEUP",0xB0},
        {"WEBHOM ",    "VBKEY_WEBHOME", 0xB2},
        {"NUMPAD",     "VBKEY_NUMPADCOMMA",     0xB3},
        {"DIVIDE",     "VBKEY_DIVIDE",  0xB5},
        {"SYSRQ",    "VBKEY_SYSRQ",   0xB7},
        {"RMENU",    "VBKEY_RMENU",   0xB8},
        {"PAUSE",    "VBKEY_PAUSE",   0xC5},
        {"HOME",     "VBKEY_HOME",    0xC7},
        {"UP",       "VBKEY_UP",      0xC8},
        {"PRIOR" ,   "VBKEY_PRIOR",   0xC9},
        {"LEFT",     "VBKEY_LEFT",    0xCB},
        {"RIGHT",    "VBKEY_RIGHT",   0xCD},
        {"END",      "VBKEY_END",     0xCF},
        {"DOWN",     "VBKEY_DOWN",    0xD0},
        {"NEXT",     "VBKEY_NEXT",    0xD1},
        {"INSERT ",    "VBKEY_INSERT",  0xD2},
        {"DELETE",     "VBKEY_DELETE",  0xD3},
        {"LWIN",     "VBKEY_LWIN",    0xDB},
        {"RWIN",     "VBKEY_RWIN",    0xDC},
        {"APPS",     "VBKEY_APPS",    0xDD},
        {"POWER",    "VBKEY_POWER",   0xDE},
        {"SLEEP",    "VBKEY_SLEEP",   0xDF},
        {"WAKE",     "VBKEY_WAKE",    0xE3},
        {"WEBSEA ",    "VBKEY_WEBSEARCH",       0xE5},
        {"WEBFAV ",    "VBKEY_WEBFAVORITES",    0xE6},
        {"WEBREF ",    "VBKEY_WEBREFRESH",      0xE7},
        {"WEBSTO ",    "VBKEY_WEBSTOP", 0xE8},
        {"WEBFOR ",    "VBKEY_WEBFORWARD",      0xE9},
        {"WEBBAC ",    "VBKEY_WEBBACK", 0xEA},
        {"MYCOMP ",    "VBKEY_MYCOMPUTER",      0xEB},
        {"MAIL",     "VBKEY_MAIL",    0xEC},
        {"MEDIAS",     "VBKEY_MEDIASELECT",     0xED},
        {"JOY LEFT",	"J_X_LEFT",	401},
        {"JOY RIGHT",	"J_X_RIGHT",	402},
        {"JOY DOWN",		"J_Y_DOWN",		403},
        {"JOY UP",	"J_Y_UP",	404},
        {"THROTTLE UP",		"J_Z_UP",		405},
        {"THROTTLE DOWN",	"J_Z_DOWN",	406},
        {"BUTTON 1",    "J_RGB1", 430},
        {"BUTTON 2",    "J_RGB2", 431},
        {"BUTTON 3",    "J_RGB3", 432},
        {"BUTTON 4",    "J_RGB4", 433},
        {NULL, NULL,  0x00}
};

char * GetStringByKeybind(unsigned int key)
{
  int i = 0;
  while (sKeyBindings[i].binding != 0 &&  
         sKeyBindings[i].binding != key) i++;
  return (char *)sKeyBindings[i].KeyName; 
}

char * GetNiceStringByKeybind(unsigned int key)
{
  int i = 0;
  while (sKeyBindings[i].binding != 0 &&  
         sKeyBindings[i].binding != key) i++;
  return (char *)sKeyBindings[i].NiceKeyName; 
}


User::User(void)
{
  this->mUserNumber = 0;
  this->Mask = ET_USER_1_INPUT;
  ConfFile keymap_file;
  keymap_file.Init(".\\Config.dat");
  char *retString;
  for(int i = 0 ; i < MAX_MAPPED_KEYS ; i++)
  {
     char buffer[256];
     my_snprintf(buffer,256,"USER_1_%s",sKeyMaps[i]);
     retString = keymap_file.GET_STR(buffer);
     int j = 0;
     while(sKeyBindings[j].KeyName && (strncmp(retString,sKeyBindings[j].KeyName,128) != 0) )
     {
       j++;
     }
     free(retString);
     this->UserKeyMappings[i].realKey =  sKeyBindings[j].binding;
  }

  this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_UP;
  this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_DOWN;
  this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_LEFT;
  this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_RIGHT;
  this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_LCONTROL;
  this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_LSHIFT;
  this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_Z;
//  this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_SPACE;
}

User::User(unsigned int user_number)
{
  this->mUserNumber = user_number;
  this->KeyMask = 0;
  this->SetMask(user_number);
}

User::~User(void)
{
}

void User::SetMask(unsigned int user_number)
{
  this->Mask = 1 << (user_number + 1);
 
  ConfFile keymap_file;
  keymap_file.Init(".\\Config.dat");
  char *retString;
  for(int i = 0 ; i < MAX_MAPPED_KEYS ; i++)
  {
     char buffer[256];
     my_snprintf(buffer,256,"USER_%i_%s",user_number + 1,sKeyMaps[i]);
     retString = keymap_file.GET_STR(buffer);
     int j = 0;
     while(sKeyBindings[j].KeyName && (strncmp(retString,sKeyBindings[j].KeyName,128) != 0) )
     {
       j++;
     }
     free(retString);
     this->UserKeyMappings[i].realKey =  sKeyBindings[j].binding;
  }
  keymap_file.DeInit();
  switch (this->Mask)
  {
    case ET_USER_1_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_UP;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_DOWN;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_LEFT;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_RIGHT;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_LCONTROL;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_LSHIFT;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_Z;
//      this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_SPACE;
      return;
    case ET_USER_2_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_I;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_K;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_J;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_L;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_M;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_N;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_B;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_V;
      return;
    case ET_USER_3_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_T;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_F;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_G;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_V;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_R;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_Y;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_C;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_B;
      return;
    case ET_USER_4_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_UP;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_DOWN;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_LEFT;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_RIGHT;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_LCONTROL;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_LSHIFT;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_Z;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_SPACE;
      return;
    case ET_USER_5_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_I;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_M;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_J;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_K;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_P;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_P;
      return;
    case ET_USER_6_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_T;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_F;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_G;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_V;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_R;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_Y;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_C;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_B;
      return;
    case ET_USER_7_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_UP;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_DOWN;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_LEFT;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_RIGHT;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_LCONTROL;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_LSHIFT;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_Z;
//      this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_SPACE;
      return;
    case ET_USER_8_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_I;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_M;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_J;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_K;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_P;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_P;
      return;
    case ET_USER_9_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_T;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_F;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_G;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_V;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_R;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_Y;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_C;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_B;
      return;
    case ET_USER_10_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_UP;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_DOWN;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_LEFT;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_RIGHT;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_LCONTROL;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_LSHIFT;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_Z;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_SPACE;
      return;
    case ET_USER_11_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_I;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_M;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_J;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_K;
      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_P;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_P;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_P;
      return;
    case ET_USER_12_INPUT:
      this->UserKeyMappings[MAPKEY_UP].mappedKey = VBKEY_T;
      this->UserKeyMappings[MAPKEY_DOWN].mappedKey = VBKEY_F;
      this->UserKeyMappings[MAPKEY_LEFT].mappedKey = VBKEY_G;
      this->UserKeyMappings[MAPKEY_RIGHT].mappedKey = VBKEY_V;

      this->UserKeyMappings[MAPKEY_1].mappedKey = VBKEY_R;
      this->UserKeyMappings[MAPKEY_2].mappedKey = VBKEY_Y;
      this->UserKeyMappings[MAPKEY_3].mappedKey = VBKEY_C;
 //     this->UserKeyMappings[MAPKEY_4].mappedKey = VBKEY_B;
      return;
    default:
      assert(!"Wrong User Mask");
  }
}

void User::SetRealKey(KeyMaps Key, short NewKey)
{
  this->UserKeyMappings[Key].realKey = NewKey;
};

void User::SaveInput(FILE *file)
{
  for (int i = 0 ; i < MAX_MAPPED_KEYS; i++)
  {
    fprintf(file,"USER_%i_%s = \"%s\"\n",mUserNumber + 1,sKeyMaps[i],GetStringByKeybind(UserKeyMappings[i].realKey));
  }
}
E:\Project\Kopia (5) VBEngine\Core\User.h
#ifndef USER_H
#define USER_H

struct UserKeyMapping
{
  short realKey;
  short mappedKey;
};


char * GetStringByKeybind(unsigned int key);
char * GetNiceStringByKeybind(unsigned int key);

class User
{
  float KeyTime;
  unsigned int Mask;                                /* user mask in event msg. */
  unsigned int KeyMask;                             /* curreent keys pressed */
  unsigned int mUserNumber;
  UserKeyMapping UserKeyMappings[MAX_MAPPED_KEYS];  /* user key mapping */
public:
  short GetMappedKey(int key) {return this->UserKeyMappings[key].mappedKey;};
  void SetRealKey(KeyMaps Key, short NewKey);
  short GetRealKey(int key) {return this->UserKeyMappings[key].realKey;};

  unsigned int GetMask(void) {return this->Mask;};
  void SetMask(unsigned int mask);
  unsigned int GetKeyMask(void) {return this->KeyMask;};
  void SetKeyMask(unsigned int mask) {this->KeyMask = mask;};
  float GetKeyTime(void) {return this->KeyTime;};
  void SetKeyTime(float t) {this->KeyTime = t;};

  User();
  User(unsigned int mask);
  ~User(void);
  void SaveInput(FILE *file);
};




#endif
E:\Project\Kopia (5) VBEngine\Core\UserManager.cpp
#include "..\config.h"

//#include <Windows.h>
#include <assert.h>
#include <d3dx9effect.h>
#include <dinput.h>
#include <stdio.h>
//#include "
#include "..\utility\Misc.h"
#include "..\utility\defines.h"
#include "..\utility\Singleton.h"
#include "..\utility\vbmath.h"
#include "..\utility\ctime.h"
#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\Utility\logger.h"
#include "..\Utility\Tools.h"

#include "..\graphics\renderer.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\GUI.h"

#include "..\input\Mapper.h"
#include "..\input\input.h"

#include "Team.h"
#include "game.h"


#include "User.h"
#include "UserManager.h"


UserManager::UserManager()
{
}

UserManager::~UserManager()
{
  User *usr;
  while (usr = this->userList.Get())
  {
    delete usr;
  }
}

/*
\fn int UserManager::ProcessInput(KeyMaps key)
\brief dodaje do globalnej maski klawisze ktore byly odczytane z inputu (tablicy diks) dla danego usera
  i jego mapowania
*/
int UserManager::ProcessInput(KeyMaps key)
{
  switch(key)
  {
    case MAPKEY_UP    : KeyMask |= VBK_UP;    KeyMask &= ~VBK_DOWN;  return 0;
    case MAPKEY_DOWN  : KeyMask |= VBK_DOWN;  KeyMask &= ~VBK_UP;    return 0;
    case MAPKEY_LEFT  : KeyMask |= VBK_LEFT;  KeyMask &= ~VBK_RIGHT; return 0;
    case MAPKEY_RIGHT : KeyMask |= VBK_RIGHT; KeyMask &= ~VBK_LEFT;  return 0; 
    case MAPKEY_1     : KeyMask |= VBK_ACTION_1; return 0;
    case MAPKEY_2     : KeyMask |= VBK_ACTION_2; return 0;
    case MAPKEY_3     : KeyMask |= VBK_ACTION_3; return 0;
   // case MAPKEY_4     : KeyMask |= VBK_ACTION_4; return 0;
  }
  return -1;
}

/*
\fn void UserManager::Update()
\brief wywolywana w kazdej iteracji petli, wysyla eventy do userow ktorzy mapuja klawisze ktore sa 
  odczytywane z klasy Input
*/
void UserManager::Update()
{
  bool was_moved, was_actions;
  User *usr;
  unsigned int key, i;
  
  while( (usr = userList.Get()) )
  {
    KeyMask = 0;
    key = 0;

    for (i = 0; i < MAX_MAPPED_KEYS; i++)
    {
      if ( Input::Instance()->diks[usr->GetMappedKey(i)]) 
      {
        this->ProcessInput((enum KeyMaps)i);
      }
    }

    was_moved = (usr->GetKeyMask() & VBK_DIRECTIONS) != 0;
    was_actions = (usr->GetKeyMask() & VBK_ACTIONS) != 0;

    if(KeyMask)
    {
       key = SceneManager::Instance()->ModifyInput(KeyMask);
       if(was_moved && !(key & VBK_DIRECTIONS))
       {        
         key |= VBK_HINT;
       }
       if (was_actions && !(key & VBK_ACTIONS))
       {    
         key |= VBK_ACTION_HINT;
       }
    }
    else
    {
      if(was_moved)
      {        
        key |= VBK_HINT;
      }
      if (was_actions) 
      {        
        key |= VBK_ACTION_HINT;
      }
    }

    if(key)
    {
      POST_EVENT2(usr->GetMask(), key, (key & ~(usr->GetKeyMask())), false, NULL);
    }
    usr->SetKeyMask(KeyMask);
  }
  userList.Reset();

  Renderer::Instance()->ProcessWindowMessages();
  
  
  
  if ( Input::Instance()->WasPressed(VBKEY_F1) ) POST_EVENT(ET_SCENE, VBKEY_F1, false, NULL);    
  if ( Input::Instance()->WasPressed(VBKEY_F2) ) POST_EVENT(ET_SCENE, VBKEY_F2, false, NULL);    
  if ( Input::Instance()->WasPressed(VBKEY_F3) ) POST_EVENT(ET_SCENE, VBKEY_F3, false, NULL);        
  if ( Input::Instance()->WasPressed(VBKEY_F4) ) POST_EVENT(ET_SCENE, VBKEY_F4, false, NULL);


  
  if ( Input::Instance()->WasPressed(VBKEY_ESCAPE) ){ POST_EVENT(ET_GUI, GUIE_ESC_PRESSED, false, NULL); }
  if ( Input::Instance()->WasPressed(VBKEY_Y)){ POST_EVENT(ET_GUI, GUIE_YES_PRESSED, false, NULL); }
  if ( Input::Instance()->WasPressed(VBKEY_N)){ POST_EVENT(ET_GUI, GUIE_NO_PRESSED, false, NULL); }


  if ( Input::Instance()->WasPressed(VBKEY_RETURN) )
  {
    if (CGame::Instance())
    {
      POST_EVENT(ET_GAME, GE_BREAK_LIGHTS , false, NULL);
    }
    else
    {
      if( GUI::Instance()->IsIntroRunning())
      {
        GUI::Instance()->StopIntro();
      }
    }
  }

  if ( Input::Instance()->diks[VBKEY_INSERT] ) POST_EVENT(ET_SCENE, VBKEY_INSERT, false, NULL);
  if ( Input::Instance()->diks[VBKEY_PRIOR] )  POST_EVENT(ET_SCENE, VBKEY_PRIOR, false, NULL);    
  if ( Input::Instance()->diks[VBKEY_DELETE] ) POST_EVENT(ET_SCENE, VBKEY_DELETE, false, NULL);        
  if ( Input::Instance()->diks[VBKEY_NEXT] )   POST_EVENT(ET_SCENE, VBKEY_NEXT, false, NULL);      
  if ( Input::Instance()->diks[VBKEY_HOME] )   POST_EVENT(ET_SCENE, VBKEY_HOME, false, NULL);        
  if ( Input::Instance()->diks[VBKEY_END] )    POST_EVENT(ET_SCENE, VBKEY_END, false, NULL);

#if defined(DEBUG) || defined(DEMO)
  if ( Input::Instance()->WasPressed(VBKEY_F12) ) POST_EVENT(ET_GLOBAL, GEID_QUIT, true, NULL);
  if ( Input::Instance()->diks[VBKEY_F6] && CGame::Instance()) CGame::Instance()->CheatWinMatch();
  if ( Input::Instance()->diks[VBKEY_F7] && CGame::Instance()) CGame::Instance()->CheatLoseMatch();
#endif

#ifdef DEBUG
  if ( Input::Instance()->diks[VBKEY_C] )  POST_EVENT(ET_SCENE, VBKEY_C , false, NULL);
  if ( Input::Instance()->diks[VBKEY_X] )  POST_EVENT(ET_SCENE, VBKEY_X , false, NULL);
  if ( Input::Instance()->diks[VBKEY_W] )  POST_EVENT(ET_SCENE, VBKEY_W , false, NULL);
  if ( Input::Instance()->diks[VBKEY_S] )  POST_EVENT(ET_SCENE, VBKEY_S , false, NULL);
  if ( Input::Instance()->diks[VBKEY_D] )  POST_EVENT(ET_SCENE, VBKEY_D , false, NULL);
  if ( Input::Instance()->diks[VBKEY_A] )  POST_EVENT(ET_SCENE, VBKEY_A , false, NULL);

 // if ( Input::Instance()->WasReleased(VBKEY_SPACE) )  POST_EVENT(ET_TEAM_0 | ET_TEAM_1, VBKEY_SPACE , false, NULL);
  
  if ( Input::Instance()->WasReleased(VBKEY_Q) ) 
  {
    POST_EVENT(ET_TEAM_0 , VBK_ACTION_1 , false, NULL);
  }
  if ( Input::Instance()->WasReleased(VBKEY_E) ) 
  {
    POST_EVENT(ET_TEAM_0 , VBK_ACTION_2 , false, NULL);
  }

  if ( Input::Instance()->WasReleased(VBKEY_R) ) 
  {
    POST_EVENT(ET_TEAM_0 , VBK_ACTION_3 , false, NULL);
  }
    
  if ( Input::Instance()->WasReleased(VBKEY_T) ) 
  {
    POST_EVENT(ET_TEAM_0 , VBK_ACTION_4 , false, NULL);
  }
  
#endif

}

/*!
\fn User *UserManager::AddUser()
Dodaje nowego usera, identyfikator ET_USER_*_INPUT jest znajdowany przez najpierw, zsumowanie masek
dotychczasowo dodanych userow, oraz sprawdzeniu pierwszego 0-owego bita, bedzie to maska ET_USER_*_INPUT
naszego nowego usera. Pozniej ma miejsce mapowanie klawiszy.
*/
User *UserManager::AddUser()
{  
  User *tmpUsr;
  unsigned int mask=0, i;

  /* find free user mask */
  while(tmpUsr = userList.Get())
  {
    mask |= tmpUsr->GetMask();
  }
  userList.Reset();

  for(i = 0; i < MAX_USERS; i++)
  {
    if (!(mask & (1 << (i + 1)))) 
    {
      break;
    } 
  }
  DIE(i < MAX_USERS && "Max moze byc 12 userow!!!");
  /* end find free user mask */

  tmpUsr = new User(i);

  for (i = 0; i < MAX_MAPPED_KEYS; i++)
  {
    Input::Instance()->AddMap(tmpUsr->GetRealKey(i) , tmpUsr->GetMappedKey(i));
  }
  userList.Attach(tmpUsr);
  return tmpUsr;
}


/*
\fn void UserManager::RemapMapper()
\breif po zmianie w mapowaniach klawiszy dla userow nalezy wywolac ta funkcje,ktora zupdetuje
  te zmiany w klasie Input (w jej mapowaniach)
*/
void UserManager::RemapMapper()
{
  int i;
  User *usr;
  while ( (usr = userList.Get()) )
  {
    for (i = 0; i < MAX_MAPPED_KEYS; i++)
    {
      if ( !Input::Instance()->ChangeMapForReal(usr->GetRealKey(i), usr->GetMappedKey(i)) )
        Input::Instance()->AddMap(usr->GetRealKey(i), usr->GetMappedKey(i));
    }
  }
  userList.Reset(); 
}

/*
\fn bool UserManager::IsValidUserKey(unsigned int key)
\brief sprawdzenie czy dany klawisz mozna podpiac pod input
*/

bool UserManager::IsValidUserKey(unsigned int key)
{
  switch (key)
  {
  case VBKEY_F1:
  case VBKEY_F2:
  case VBKEY_F3:
  case VBKEY_F4:
  case VBKEY_RETURN: return false;
  default: return true;
  }

}

/*
\fn int UserManager::GetKeypressRaw()
\brief funkcia pobieraj¹ca pierwszy klawisz z tablicy dików - do mapowania;
*/

int UserManager::GetKeypressRaw(bool NoJoy)
{
  Input::Instance()->GetAllDataToObject();
  int i;
  for (i = 0 ; i < 256 ; i++)
  {
    if ((Input::Instance()->diks_real[i]&128) == 0) continue;
    if (IsValidUserKey(Input::Instance()->diks_real[i]&128)) return i;
  }
  if (NoJoy)  return -1;
  for (i = 401; i <405; i++ )
  {
    if (Input::Instance()->GetJoyInput(i)) return i;
  }

  for (i = 430; i <434; i++ )
  {
    if (Input::Instance()->GetJoyInput(i)) return i;
  }
  return -1;
}
    

/*
\fn int User * UserManager::GetUser(unsigned char user)
\brief pobiera usera o podanym indeksie;
*/

User * UserManager::GetUser(unsigned char user)
{
  User *tmpUser = NULL;
  userList.Push();
  while(((tmpUser = userList.Get()) != NULL) && user--)
  {}
  userList.Pop();
  return tmpUser;
}


void UserManager::ClearKeyInUsers(unsigned int key)
{
  User *tmpUser;
  userList.Push();
  while((tmpUser = userList.Get()) != NULL)
  {
   for (int i = 0; i < 7; i++)
   {
     if (tmpUser->GetRealKey(i) == key)
       tmpUser->SetRealKey((KeyMaps) i, 0x66);
   }
  }
  userList.Pop();
}


void UserManager::SaveInputState()
{
  User *tmpUser;
  FILE *temp = fopen(".\\Config.dat","w");
  if (temp == NULL) return;
  userList.Push();
  while((tmpUser = userList.Get()) != NULL)
  {
    tmpUser->SaveInput(temp);
  }
  userList.Pop();
  this->RemapMapper();
  fclose(temp);
}
E:\Project\Kopia (5) VBEngine\Core\UserManager.h
#ifndef _USERMANAGER_H
#define _USERMANAGER_H


/*
class       : UserManager
description : Zarzšdza inputem z directx'a, updatowany jest w kazdej iteracji petli glownej,
              w zaleznosci od mapowan dla kazdego usera wysyla eventy z inputu. Dodaje nowych
              userow i ustawia ich mapowania na standardowe (mapowania mozna zmienic dla usera i potem
              wywolujac RemapMapper() ustalic te nowe mapowania w inpucie).

methods     :          
            UserManager(); - konstruktor
            ~UserManager(); - dekonstruktor
            
            int ProcessInput(KeyMaps key);  -  dla danego inputu (UP|DOWN|LEFT|RIGHT|1|2|3|4) dodaje jego
              maske do globalnej zmiennej ktora pozniej jest wysylana do usera                  
            
            void Update(); - wywolywana w kazdej teracji petli while, dla kazdego usera zprawdza czy przez
              niego zamapowane klawisze nie zostaly w tej petli wcisniete, jesli tak to buduje maske tych
              klawiszy i wysyla event

            void RemapMapper(); - jesli User dokonal zmian w mapowaniu klawiszy typu Real - wowczas 
              wywolanie tej funkcji odnowi liste mapowan w mapper.cpp
            User *AddUser(); - dodaje nowego usera, i standowrdowe mapowanie klawiatury
*/

  
typedef ItemList<User> UserList;

class UserManager :public Singleton<UserManager>
{
  unsigned int KeyMask; /* maska klawiszy VBK_  */
  UserList userList; /* lista aktywnych userow */
  int ProcessInput(KeyMaps key); 
 public:
  UserManager();
  ~UserManager();
  //int ProcessMouseInput(unsigned int wParam, unsigned int lParam);
  void Update();
  void RemapMapper();
  User *AddUser();

  User *GetUser(unsigned char user);
  int GetKeypressRaw(bool NoJoy = false);
  bool IsValidUserKey(unsigned int key);
  void ClearKeyInUsers(unsigned int key);
  void SaveInputState();
};




#endif
E:\Project\Kopia (5) VBEngine\Core\WorldLeague.cpp
#include "..\config.h"

#include <memory.h>
#include <assert.h>
#include <stdlib.h>
#include <search.h>
#include "..\utility\defines.h"
#include "..\utility\tools.h"
#include "..\utility\singleton.h"
#include "WorldLeague.h"

// mapa "parowania" zespo³ów 
unsigned char matchMap[6][4] =
{
  {1,0,2,3},
  {0,2,1,3},
  {0,3,2,1},
  {0,1,3,2},
  {2,0,3,1},
  {1,2,3,0},
};
// tabela trudnoœci zespo³ów
float SkillTweaks[] =
{       
  1.35f,
  0.80f,
  0.80f,
  0.80f,
  0.95f,
  0.95f,
  0.95f,
  0.95f,
  1.15f,
  0.80f,
  1.25f,
  1.0f,
  1.0f,
  1.0f,
  1.0f,
  1.0f,
  1.0f,
  1.0f,
  1.0f,
  1.0f
};


// opisy kodu w EuroLeague.cpp

WorldLeague::WorldLeague(eTeams player_team)
{
  this->mSwappedMatch = false;
  this->mPlayerTeam = player_team;
  char teams[12];
  char pools[12];
  for (int i = 0; i < 12 ; i ++)
  {
    teams[i] = i;
  }
  int k;
  for (int i = 0; i < 12 ; i ++)
  {
   do 
   {
     k = myrand(11);
     pools[i] = teams[k];
   } 
   while(teams[k] == -1);
   teams[k] = -1;
  }
  this->mCurrentWeekend = 0;
  memset (this->mWeekends,0, sizeof(this->mWeekends)); 
  memset (this->mCurrentRanking ,0, sizeof(this->mCurrentRanking));  
  memset (this->mFinals ,0, sizeof(this->mFinals)); 
  for (int i = 0 ; i < 12 ; i++)
  {
    this->mPools[i/4][i%4] = (eTeams)pools[i];
  }
  for (int i = 0 ; i < 6 ; i ++)
  {
    for (int j = 0; j < 2 ; j++)
    {
      this->mWeekends[0][i].matches[j].teams[0] =  mPools[0][matchMap[i][j*2]];
      this->mWeekends[0][i].matches[j].teams[1] =  mPools[0][matchMap[i][j*2+1]];
    }
    for (int j = 2; j < 4 ; j++)
    {
      this->mWeekends[0][i].matches[j].teams[0] = this->mWeekends[0][i].matches[j-2].teams[1];
      this->mWeekends[0][i].matches[j].teams[1] = this->mWeekends[0][i].matches[j-2].teams[0];
    }
        for (int j = 0; j < 2 ; j++)
    {
      this->mWeekends[1][i].matches[j].teams[0] =  mPools[1][matchMap[i][j*2]];
      this->mWeekends[1][i].matches[j].teams[1] =  mPools[1][matchMap[i][j*2+1]];
    }
    for (int j = 2; j < 4 ; j++)
    {
      this->mWeekends[1][i].matches[j].teams[0] = this->mWeekends[1][i].matches[j-2].teams[1];
      this->mWeekends[1][i].matches[j].teams[1] = this->mWeekends[1][i].matches[j-2].teams[0];
    }
    for (int j = 0; j < 2 ; j++)
    {
      this->mWeekends[2][i].matches[j].teams[0] =  mPools[2][matchMap[i][j*2]];
      this->mWeekends[2][i].matches[j].teams[1] =  mPools[2][matchMap[i][j*2+1]];
    }
    for (int j = 2; j < 4 ; j++)
    {
      this->mWeekends[2][i].matches[j].teams[0] = this->mWeekends[2][i].matches[j-2].teams[1];
      this->mWeekends[2][i].matches[j].teams[1] = this->mWeekends[2][i].matches[j-2].teams[0];
    }
  }
  mMatchPlayed = false;
  mCurrentMatch =0;
  mCurrentPool = 0;
  mFinalStage = 0;
}


match *WorldLeague::GetNextMatch()
{
  while (mCurrentWeekend < 6)
  {
    while (mCurrentMatch < 4)
    {
      while (mCurrentPool < 3)
      {
        match *temp = &mWeekends[mCurrentPool][mCurrentWeekend].matches[mCurrentMatch];
        if (temp->teams[0] == mPlayerTeam )
        {
          this->mSwappedMatch = false;
          return temp;
        }
        else
        if (temp->teams[1] == mPlayerTeam)
        {
          this->mSwappedMatch = true;
          return temp;
        }
        else
        {
         this->RandomiseScore(temp);
        }
        mCurrentPool++;
      }
      mCurrentPool = 0;
      mCurrentMatch++;
    }
    mCurrentMatch = 0;
    this->CalcRanking();
    mCurrentWeekend++;
  }
  
  while (this->mFinalStage < 3)
  {
    if (this->mFinalStage == 0)
    { // sposób wybierania inny ni¿ w euroleague
      // pierwszy zawsze gracz
      this->mFinals[0][0].teams[0] = this->mPlayerTeam;
      //je¿eli w puli a przewodzi gracz - weŸ drugiego
      this->mFinals[0][0].teams[1] = this->mCurrentRanking[0][5][0].team  == this->mPlayerTeam ? this->mCurrentRanking[0][5][1].team  : this->mCurrentRanking[0][5][0].team ;
      // je¿eli w puli b przewodzi gracz - weŸ drugiego
      this->mFinals[0][1].teams[0] = this->mCurrentRanking[1][5][0].team  == this->mPlayerTeam ? this->mCurrentRanking[1][5][1].team  : this->mCurrentRanking[1][5][0].team ;
      // je¿eli w puli c przewodzi gracz - weŸ drugiego
      this->mFinals[0][1].teams[1] = this->mCurrentRanking[2][5][0].team  == this->mPlayerTeam ? this->mCurrentRanking[2][5][1].team  : this->mCurrentRanking[2][5][0].team ; 
    } else
    if (this->mFinalStage == 1 )
    {
      this->mFinals[1][0].teams[0] = this->mFinals[0][0].teams[this->mFinals[0][0].loser];
      this->mFinals[1][0].teams[1] = this->mFinals[0][1].teams[this->mFinals[0][1].winner];
      this->mFinals[1][1].teams[0] = this->mFinals[0][0].teams[this->mFinals[0][0].winner];
      this->mFinals[1][1].teams[1] = this->mFinals[0][1].teams[this->mFinals[0][1].loser];
    } else
    {
      this->mFinals[2][0].teams[0] = this->mFinals[1][0].teams[this->mFinals[1][0].loser];
      this->mFinals[2][0].teams[1] = this->mFinals[1][1].teams[this->mFinals[1][1].loser];
      this->mFinals[2][1].teams[0] = this->mFinals[1][0].teams[this->mFinals[1][0].winner];
      this->mFinals[2][1].teams[1] = this->mFinals[1][1].teams[this->mFinals[1][1].winner];
    }

    while (this->mCurrentMatch < 2)
    {
       match *temp = &mFinals[mFinalStage][mCurrentMatch];
       if (temp->teams[0] == mPlayerTeam )
        {
          this->mSwappedMatch = false;
          return temp;
        }
        else
        if (temp->teams[1] == mPlayerTeam)
        {
          this->mSwappedMatch = true;
          return temp;
        }
        else
        {
         this->RandomiseScore(temp);
        }
       mCurrentMatch++;
    }
    mCurrentMatch = 0;
    this->mFinalStage++;
  }
  return NULL;
}


void WorldLeague::RandomiseScore(match *_match)
{
  unsigned int vals[2];
  vals[0] = (unsigned int)(100.0f * SkillTweaks[_match->teams[0]]);
  vals[1] = (unsigned int)(100.0f * SkillTweaks[_match->teams[1]]);
  unsigned int winner,loser,set_winner,set_loser,sets[2],current_set;
  if (myrand(vals[0]) > myrand(vals[1]))
  {
    winner = 0; 
    loser = 1;
  }
  else
  {
    winner = 1;
    loser = 0;
  }
  _match->winner = winner;
  _match->loser = loser;
  
  _match->sets_won[winner] = sets[winner] = 3;
  _match->sets_won[loser] =  sets[loser] = myrand(25)/10;
  _match->sets_played = sets[winner]+sets[loser];
  current_set = 0;
  while (sets[winner] || sets[loser])
  {
    if (sets[winner] && sets[loser])
    {
     if (myrand(1))
     {
       set_winner = loser;
       set_loser = winner;
     }
     else
     {
       set_winner = winner;
       set_loser = loser;
     }
    } else
    if (sets[winner])
    {
      set_winner = winner;
      set_loser = loser;
    }
    else
    {
       set_winner = loser;
       set_loser = winner;
    }

   
    unsigned int loser_score,winner_score;
    loser_score = myrand(33);

    if (loser_score < 24)
    {
      winner_score = 25;
    }
    else
    {
      winner_score = loser_score + 2;
    }
    _match->score[current_set].Score[set_winner] = winner_score; 
    _match->score[current_set].Score[set_loser] = loser_score;
    _match->score[current_set].winningTeam = set_winner;
    sets[set_winner]--;
    current_set++;
  }
}


void WorldLeague::MatchOver(unsigned char sets,SetStruct *result)
{
          
  mMatchPlayed= true;
  //polfinal
  char one,zero;
  if (this->mSwappedMatch)
  {
   one = 0;
   zero = 1;
  }
  else
  {
    zero = 0;
    one =1;
  }
  if (mCurrentWeekend < 6)
  {
    match *temp = &mWeekends[mCurrentPool][mCurrentWeekend].matches[mCurrentMatch];
    temp->sets_played = sets ;//< 5 ? sets + 1 : 5;
    char wins = 0;

    for (int i = 0 ; i < temp->sets_played; i++)
    {
      temp->score[i].Score[0] = result[i].Score[zero]; 
      temp->score[i].Score[1] = result[i].Score[one];
      temp->score[i].winningTeam = result[i].winningTeam ? one : zero;
      temp->sets_won[temp->score[i].winningTeam]++;
      wins += temp->score[i].winningTeam ? 1 : -1;
    }
    temp->winner = (wins > 0 ) ? 1 : 0;
    temp->loser  = (wins > 0 ) ? 0: 1;
    mCurrentPool++;
  }
  else
  {
     match *temp = &mFinals[mFinalStage][mCurrentMatch];
     temp->sets_played = sets ;//< 5 ? sets + 1 : 5;
     char wins = 0;
     for (int i = 0 ; i < temp->sets_played ; i++)
     {
       temp->score[i].Score[0] = result[i].Score[zero]; 
       temp->score[i].Score[1] = result[i].Score[one];
       temp->score[i].winningTeam = result[i].winningTeam ? one : zero;
       temp->sets_won[temp->score[i].winningTeam]++;
       wins += temp->score[i].winningTeam ? 1 : -1;
     }
     temp->winner = (wins > 0 ) ? 1 : 0;
     temp->loser  = (wins > 0 ) ? 0: 1;
     mCurrentMatch++;
  }
  //final
}

//sorting func

int qsort_func(const void * _key, const void *_val)
{
  ranking *key, *val;
  key = (ranking*)_key;
  val = (ranking*)_val;
  if (key->matches_won < val->matches_won) // najpierw porównaj iloœæ meczy 
    return 1;
  if (key->matches_won > val->matches_won)
    return -1;

  // potem porównaj stosunek wygranych setów do przegranych
  float ratio1 = (float) key->sets_won / (float) key->sets_lost;   
  float ratio2 = (float) val->sets_won / (float) val->sets_lost;
  if (ratio1 < ratio2) return  1;
  if (ratio1 > ratio2) return -1;

  // na koniec porównaj stosunek zdobytych punktów do straconych
  ratio1 = (float) key->points_won/ (float) key->points_lost;   
  ratio2 = (float) val->points_won / (float) val->points_lost;
  if (ratio1 < ratio2) return  1;
  if (ratio1 > ratio2) return -1;
  return 0;
}

void WorldLeague::CalcRanking()
{
  if (mCurrentWeekend < 6)
  {
    for (int i = 0 ; i < 3 ; i ++)
      for (int j = 0 ; j < mCurrentWeekend+1; j++)
        for (int k = 0; k < 4 ;k ++)
        {
          match *temp = &mWeekends[i][j].matches[k];
          for (int m = 0 ; m < 4; m++)
          {
            eTeams curTeam = this->mPools[i][m];
            if (temp->teams[0] != curTeam &&
                temp->teams[1] != curTeam) continue;
            unsigned char thisTeam = temp->teams[0] == curTeam ? 0 : 1;
            unsigned char otherTeam =  temp->teams[0] == curTeam ? 1 : 0;
            if (temp->winner == thisTeam)
              this->mCurrentRanking[i][mCurrentWeekend][m].matches_won++;
            else
              this->mCurrentRanking[i][mCurrentWeekend][m].matches_lost++;
            for (int n = 0; n < temp->sets_played; n++)
            {
              if (temp->score[n].winningTeam == thisTeam)
                this->mCurrentRanking[i][mCurrentWeekend][m].sets_won++;
              else
                this->mCurrentRanking[i][mCurrentWeekend][m].sets_lost++;
              this->mCurrentRanking[i][mCurrentWeekend][m].points_won += temp->score[n].Score[thisTeam];  
              this->mCurrentRanking[i][mCurrentWeekend][m].points_lost += temp->score[n].Score[otherTeam];
            }
          }
        }

    for (int i = 0 ; i < 3 ; i ++)
    {
      for (int j = 0 ; j < 4 ; j++)
        this->mCurrentRanking[i][mCurrentWeekend][j].team  = this->mPools[i][j];

      qsort(this->mCurrentRanking[i][mCurrentWeekend],4,sizeof(ranking),&qsort_func);
    }
  }
}
E:\Project\Kopia (5) VBEngine\Core\WorldLeague.h
#ifndef WORLDLEAGUE_H
#define WORLDLEAGUE_H

#include "LeagueStructs.h"


class WorldLeague :public Singleton<WorldLeague>
{
  eTeams mPools[3][4];
  weekend mWeekends[3][6];
  unsigned char mCurrentWeekend;
  eTeams mPlayerTeam;
  unsigned char mCurrentMatch;
  unsigned char mCurrentPool;
  match mFinals[3][2];
  unsigned char mFinalStage;
  ranking mCurrentRanking[3][6][4];
  bool mMatchPlayed;
  bool mSwappedMatch;
  

public:
  WorldLeague(eTeams player_team);
  ~WorldLeague() 
  {
   int i = 0;
  };
  match *GetNextMatch();
  void CalcRanking();
  ranking *GetTeamByRanking(unsigned int pool,unsigned int rank)  {return &this->mCurrentRanking[pool][mCurrentWeekend-1][rank];}
  unsigned char GetCurrentWeekend() {return mCurrentWeekend;}
  void MatchOver(unsigned char sets,SetStruct *result);
  void RandomiseScore(match *_match);
  match *GetMatchByParams(unsigned char pool, unsigned char weekend, unsigned char match) { return &mWeekends[pool][weekend].matches[match];} 
  bool WasMatchPlayed() {return mMatchPlayed;}
  bool IsMatchSwapped() {return mSwappedMatch;}
  unsigned char GetCurrentMatch() {return mCurrentMatch;}
  unsigned char GetFinalStage() {return mFinalStage;}
  match *GetFinalMatch(unsigned char p, unsigned char m) {return &mFinals[p][m];}
}; 

#endif 
E:\Project\Kopia (5) VBEngine\Core\zawodnik.cpp
#define LOAD_PLAYER_DATA


#include "..\config.h"

#include <assert.h>
#include "..\utility\defines.h"
#include "..\Utility\Singleton.h"

#ifdef DEBUG

#include <d3dx9effect.h>
#include "..\graphics\renderer.h"

#endif


#include "..\utility\misc.h"


#include "..\utility\logger.h"
#include "..\utility\VBmath.h"
#include "..\utility\ctime.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"
#include "..\Utility\tools.h"
#include "..\utility\profile.h"
#include "..\utility\defines.h"
#include "..\utility\conf.h"


#include "..\graphics\meshmanager.h"

#include "..\graphics\animation.h"
#include "..\graphics\AnimationManager.h"

#include "..\graphics\SceneObject.h"
#include "..\graphics\Stadion.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"

//#include "..\Ai\state.h"
#include "..\Ai\States\States.h"
#include "SetupManager.h"
#include "Ball.h"
#include "Team.h"
#include "zawodnik.h"
#include "Game.h"

CPlayer::CPlayer(CTeam *team, char* playerFileName, bool libero,bool libero_substitute): EventHandler(0)
{
  is_main = false;
  odbijam = false;
  this->is_libero = libero;
  this->is_libero_substitute = libero_substitute;
  is_ai = true;
  mWasReceiving = false;
  this->is_blocking = false;
  pTeam = team;
  this->model[0] = '\0';
  this->SetLevel(2);
  this->Init(playerFileName);
  lastCollisionPlayerTime = 0;
  this->speed_scale = 1.0f;//GaussRand(0.75,1,0.5,1);  
  CurrentState = new StateIdle(NULL, this);
}

CPlayer::~CPlayer()
{
  SceneManager::Instance()->RemoveObject(this);
 delete CurrentState->GetFirst();
}

int CPlayer::Init(char* playerFileName)
{
  ConfFile Config;
    
  char *str0;
  char buffer[MAX_FILE_NAME];
  my_snprintf(buffer, MAX_FILE_NAME, "%s\\%s",PlayerDataPath, playerFileName);
  
  if (SUCCEEDED(Config.Init(buffer))) 
  {
    int i;
    if (NULL == (str0 = Config.GET_STR("MODEL")))
    {
      Config.DeInit();
      return VB_FAIL;
    }
    else
    {      
      my_snprintf(this->model, MAX_FILE_NAME, "%s", str0);
      free(str0);        
    }

    if (NULL == (str0 = Config.GET_STR("SECOND_NAME")))
    {
      my_snprintf(this->secondName, MAX_STRING_LENGTH, "UNKNOWN");
    }
    else
    {      
      my_snprintf(this->secondName, MAX_STRING_LENGTH, "%s", str0);
      free(str0);        
    }
    
    SceneManager::Instance()->AddObject(this);
   
    if (NULL == (str0 = Config.GET_STR("FACE")))
    {
      Config.DeInit();
      return VB_FAIL;
    }
    else
    {
      this->mFaceTexture = CMeshManager::Instance()->GetTextureHandlerLoad(str0);
      free(str0);
    }
    if (NULL == (str0 = Config.GET_STR("SKIN")))
    {
      Config.DeInit();
      return VB_FAIL;
    }
    else
    {
      this->mSkinTexture = CMeshManager::Instance()->GetTextureHandlerLoad(str0);
      free(str0);
    }

//this->speed_scale

    if (FAILED(Config.GET_FOLAT("HIGHT",&this->mHeight)))
    {
      Config.DeInit();
      return VB_FAIL;
    }
    else
    {
      this->mHeightScale = mHeight/ AVERAGE_HEIGHT;
    }
     Config.DeInit();

    this->mSkinOriginal = CMeshManager::Instance()->GetTextureHandler("skora.jpg");
    this->mFaceOriginal = CMeshManager::Instance()->GetTextureHandler("twarz6.jpg");    
    this->LinkTexture = CMeshManager::Instance()->GetTextureHandler("koszulka.jpg");
    this->LinkNumerTexture = CMeshManager::Instance()->GetTextureHandler("numerek.jpg");
    this->ShoeTexture = CMeshManager::Instance()->GetTextureHandler("but.jpg");


    this->SellectorLink = CMeshManager::Instance()->GetTextureHandlerLoad("linktxr.png");
    this->SellectorRed = CMeshManager::Instance()->GetTextureHandlerLoad("redtxr.png");
    this->SellectorGreen = CMeshManager::Instance()->GetTextureHandlerLoad("greentxr.png");
    this->SellectorBlue = CMeshManager::Instance()->GetTextureHandlerLoad("bluetxr.png");


    CMeshManager::Instance()->LinkTexture(this->mFaceOriginal ,this->mFaceTexture);
    CMeshManager::Instance()->LinkTexture(this->ShoeTexture ,pTeam->GetShoeTexture());
    CMeshManager::Instance()->LinkTexture(this->mSkinOriginal ,this->mSkinTexture);
    CMeshManager::Instance()->LinkTexture(this->LinkTexture, pTeam->GetTeamTexture());
    CMeshManager::Instance()->LinkTexture(this->LinkNumerTexture, DEFAULT_TEXTURE); 

    for( i = 0; i < MAX_IDLE_ANIMATIONS; i++)
    {
      this->GetStateAnimationHandler(STATE_IDLE, i);
    }
    for( i = 0; i < MAX_SIT_ANIMATIONS; i++)
    {
      this->GetStateAnimationHandler(SIT_IDLE, i);
    }

    for ( i = STATE_NONE+1; i < LAST_STATE; i++)
    {
       this->GetStateAnimationHandler((enum States)i, 0);
    }
    this->AnimationsHandlers[STATE_NONE] = this->AnimationsHandlers[STATE_IDLE];



/*
#ifdef LOAD_PLAYER_DATA
    is_ai = false;
    for ( int i = STATE_NONE+1; i < LAST_STATE; i++)
    {
      State * newState = StateManager::Instance()->GetState((enum States)i, NULL, this);
      delete newState;
    }
    is_ai = true;
#endif
*/

    //


    this->mSellector_Animation = AnimationManager::Instance()->GetAnimationHandlerLoad("selektor\\selector.dat");
/*
    int count = AnimationManager::Instance()->GetAnimation(this->mSellector_Animation)->GetFrameCount();
    for( i = 0; i < count; i++)
    {
      CMeshManager::Instance()->SetAllShaders(AnimationManager::Instance()->GetAnimation(this->mSellector_Animation)->GetFrameByIndex(i)->mesh, "SimpleAnim.fx");
    }
    */
    return VB_OK;
  }
 

  return VB_FAIL;
}

void CPlayer::AddPersonalTexture(bool genshirt, bool color)
{
  const char *NumColor[] = {"white", "black" };
  char buffer[64];  
  if(genshirt)
  {
    
    my_snprintf(buffer, 64, "#base=%d str1=%s num=%d color=%s",
            (this->is_libero ?
             (unsigned int)this->pTeam->GetTeamLiberoTexture() :
             (unsigned int)this->pTeam->GetTeamTexture()),
            this->secondName,
            this->personNumber, NumColor[(color ? 1 : 0)]);

  this->PersonalTexture = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
    this->NumerTexture = DEFAULT_TEXTURE;

  }
  else
  {
    my_snprintf(buffer, 64, "numer%s%d.png", NumColor[(color ? 1 : 0)], this->personNumber);
    this->NumerTexture = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);

    this->PersonalTexture = (this->is_libero ?
                             this->pTeam->GetTeamLiberoTexture() :
                             this->pTeam->GetTeamTexture());
  }
}

void CPlayer::Render(CMatrix4 *pViewProj)
{
//  if (!GetIsOnPlane() && !is_libero_substitute) return;
  PROFILE(Czadownik_render);
  MorphState mState;
  CurrentState->GetMorphState(&mState);
   
  CMatrix4 WordViewProj, rotMatrix;
  CVector3 move;

  float fAngle = CurrentState->GetCurrentPosition(&move);
  
  
  worldMatrix.SetTranslate(move.x,move.y,move.z);

  rotMatrix.SetRotateZ(fAngle);
  CMatrix4 ScaleMatrix;
  ScaleMatrix.SetScale(1.0f,1.0f,mHeightScale);
  worldMatrix =  ScaleMatrix * rotMatrix * worldMatrix  ;
  worldMatrix *= *pTeam->GetTeamMatrix();

  MatMat4Multiply(WordViewProj, worldMatrix, *pViewProj);

  CMeshManager::Instance()->LinkTexture(this->mFaceOriginal ,this->mFaceTexture);
  CMeshManager::Instance()->LinkTexture(this->ShoeTexture ,pTeam->GetShoeTexture());
  CMeshManager::Instance()->LinkTexture(this->mSkinOriginal ,this->mSkinTexture);
  CMeshManager::Instance()->LinkTexture(this->LinkTexture, this->PersonalTexture);
  if(this->NumerTexture != DEFAULT_TEXTURE)
  {
    CMeshManager::Instance()->LinkTexture(this->LinkNumerTexture, this->NumerTexture);
  }

  if(!this->is_ai)
  {
    CMatrix4 WordViewProj2;
    rotMatrix.SetTranslate(move.x,move.y,move.z + 0.02f);
    rotMatrix *= *pTeam->GetTeamMatrix();
    MatMat4Multiply(WordViewProj2, rotMatrix, *pViewProj);

    if(this->is_blocking)
    {
      CMeshManager::Instance()->LinkTexture(SellectorLink, this->SellectorBlue);
    }
    else
    {
      CVector3 tmp;
      tmp.Set(CBall::Instance()->GetTargetPosition());
      this->pTeam->TeamToWorld(&tmp);

      Vector3Subtract(move.tab, tmp.tab, move.tab);
    
      if(move.LengthSq() < CIRCLE * CIRCLE + 0.01f)
      {
        CMeshManager::Instance()->LinkTexture(SellectorLink, SellectorGreen);
      }
      else
      {
        CMeshManager::Instance()->LinkTexture(SellectorLink, SellectorRed);
      }
    }
    
    {
      float alpha, delta_T = fmodf(NOW, AnimationManager::Instance()->GetDuration(this->mSellector_Animation));
      Frame *first  = AnimationManager::Instance()->GetFrameByTime(this->mSellector_Animation, delta_T);
      Frame *second = AnimationManager::Instance()->GetFollowingFrameByTime(this->mSellector_Animation, delta_T);
      if (!second)
      {
         second = AnimationManager::Instance()->GetFirstFrame(this->mSellector_Animation);
      }
      alpha = (delta_T - first->start_time) / first->duration;
      CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha, &WordViewProj2);
    }
  }

  CMeshManager::Instance()->Render(mState.first->mesh,mState.second->mesh, mState.alpha,
                                                            &WordViewProj); 

  if (CurrentState->GetCurrent() == ZAGRYWKA_HINT_AIMING_LOP && !this->pTeam->IsAi())
    {
      StateLopAiming *temp = (StateLopAiming *)CurrentState;
      
      CVector3 hp(CurrentState->GetStartPosition()->x, 9.0f, 1.5f);
      pTeam->TeamToWorld(&hp);
      float alfa = temp->alfa;
      float gamma = pTeam->AngleTeamToWorld(temp->gamma);
      float scale = 0.5f + (temp->velocity - CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY)/
        (CBall::Instance()->ZAGRYWKA_MAX_LOP_VELOCITY - CBall::Instance()->ZAGRYWKA_MIN_LOP_VELOCITY);
      CArrow::Instance()->SetParameters(&hp,scale,alfa,gamma);
    }
    if (CurrentState->GetCurrent() == ZAGRYWKA_HINT_AIMING_SCINA && !this->pTeam->IsAi())
    {
      StateScinaAiming *temp = (StateScinaAiming *)CurrentState;
      
      CVector3 hp(CurrentState->GetStartPosition()->x, 9.0f, 2.3f);
      pTeam->TeamToWorld(&hp);
      float alfa = temp->alfa;
      float gamma = pTeam->AngleTeamToWorld(temp->gamma);
      float scale = 0.5f + (temp->velocity - CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY)/
        (CBall::Instance()->ZAGRYWKA_MAX_SCINA_VELOCITY - CBall::Instance()->ZAGRYWKA_MIN_SCINA_VELOCITY);
      CArrow::Instance()->SetParameters(&hp,scale,alfa,gamma);
    }

#if 0

/*
  if (mPosition == POS_1 && !this->pTeam->GetTeamNumber())
  {
    //Logger::Instance()->LogToScreen(CurrentState->GetStateStr());
  }
*/

  CVector3 points[200];
  unsigned int count;
  unsigned int i;
  //CurrentState->GetPositionByTime(points,CurrentState->GetStartTime());
  count = CurrentState->GetEndPoints(points);
  
  struct CV
  {
    float x,y,z;
    DWORD Diffuse;
  } vtx[200];

/*
  if (mPosition == POS_1 && !this->pTeam->GetTeamNumber() && count > 2)
  {
    char tbuf[1024];
    tbuf[0] = 0;
    char buffer[128];
    for(int i = 0 ; i < count;i++)
    {
      cat_snprintf(tbuf, 1024, "Point : %i, position {%f, %f, %f}\n",i, points[i].x, points[i].y, points[i].z);
    }
    LogMessage(tbuf);
  }*/
    
  memset(vtx,0, 200 * sizeof( CV));
  for (i = 0; i < count; i++)
  {
    pTeam->TeamToWorld(points+i);
    vtx[i].x = points[i].x;
    vtx[i].y = points[i].y ;
    vtx[i].z = points[i].z + 0.1f;
    vtx[i].Diffuse = (i%3) * 0x7f0000 + i%2 *(0xff00);
  }

  D3DXMATRIX xWordViewProj,id;
  D3DXMatrixIdentity(&id);

 // WordViewProj.Transpose();
  for (i = 0; i < 16; i++)
  {
    xWordViewProj[i] = pViewProj->M[i];
  }
  
  HRESULT res;

  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_WORLD,&xWordViewProj);
  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_VIEW,&id);
  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_PROJECTION,&id);

  res = Renderer::Instance()->GetDevice()->SetVertexShader(NULL);
  res = Renderer::Instance()->GetDevice()->SetPixelShader(NULL);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_LIGHTING, FALSE);
  res = Renderer::Instance()->GetDevice()->SetFVF(D3DFVF_XYZ|D3DFVF_DIFFUSE);
  res = Renderer::Instance()->GetDevice()->DrawPrimitiveUP(D3DPT_LINESTRIP ,count-1,(void *)(vtx),sizeof (CV));

#endif

}

void CPlayer::ProcessEvent(Event *event)
{
  
  unsigned int key;
  if (event->mMask & ET_USER_MASK_SUM )
  {
     key = this->pTeam->TranslateControls(event->mID);

     if(this->is_ai && this->mPosition != POS_ZAGRYWKA) return;
     if (this->pTeam->IsSomeoneReceiving() && !this->odbijam) return;  

     if(this->mPosition != POS_ZAGRYWKA)
     {
       key &= ~(VBK_ACTIONS | VBK_ACTION_HINT);
     }
     else
     {  
        //if ( !this->is_ai )
          //this->MoveCameraInZagrywka();       
     }         

     if(key)
     {
       CurrentState->UpdateControls( key );
     }
  }
  
}

void CPlayer::SetPos(CVector3 *pos, PositionOnField position)
{
  mPosition = position;
  switch(position)
  {
    case POS_0:
      pos->x = 3.0f;
      pos->y = 7.0f;
      pos->z = 0.0f;
    break;
    case POS_1:
      pos->x = 0.0f;
      pos->y = 7.0f;
      pos->z = 0.0f;
    break;
    case POS_2:
      pos->x =-3.0f;
      pos->y = 7.0f;
      pos->z = 0.0f;
    break;
    case POS_3:
      pos->x =-3.0f;
      pos->y = 3.0f;
      pos->z = 0.0f;
    break;
    case POS_4:
      pos->x = 0.0f;
      pos->y = 3.0f;
      pos->z = 0.0f;
    break;
    case POS_5:
      pos->x = 3.0f;
      pos->y = 3.0f;
      pos->z = 0.0f;
    break;
    case POS_ZAGRYWKA:
      pos->x =-3.5f;
      pos->y = 9.5f;
      pos->z = 0.0f;
    break;
    case SUB_0:
      pos->x = 8.5f;
      pos->y = 6.0f;
      pos->z = 0.0f;
    break;
    case SUB_1:
      pos->x = 8.5f;
      pos->y = 7.0f;
      pos->z = 0.0f;
    break;
    case SUB_2:
      pos->x = 8.5f;
      pos->y = 8.0f;
      pos->z = 0.0f;
    break;
    case SUB_3:
      pos->x = 8.5f;
      pos->y = 9.0f;
      pos->z = 0.0f;
    break;
    case SUB_4:
      pos->x = 8.5f;
      pos->y = 10.0f;
      pos->z = 0.0f;
    break;
    case SUB_5:
      pos->x = 8.5f;
      pos->y = 11.0f;
      pos->z = 0.0f;
    break;

   case POS_BLOK_0:
      pos->x = -3.0f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_1:
      pos->x = 0.0f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_2:
      pos->x = 3.0f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_3:
      pos->x = -0.7f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_4:
      pos->x = 0.7f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_5:
      pos->x = -3.5f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_6:
      pos->x = -2.5f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_7:
      pos->x = 2.5f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_BLOK_8:
      pos->x = 3.5f;
      pos->y = 0.5f;
      pos->z = 0.0f;
    break;
    case POS_DEFENDER_0:
      pos->x = 4.0f;
      pos->y = 4.0f;
      pos->z = 0.0f;
    break;
    case POS_DEFENDER_1:
      pos->x = 0.0f;
      pos->y = 8.0f;
      pos->z = 0.0f;
    break;
    case POS_DEFENDER_2:
      pos->x =-4.0f;
      pos->y = 4.0f;
      pos->z = 0.0f;
    break;
    case POS_DEFENDER_3:
      pos->x =-2.5f;
      pos->y = 1.5f;
      pos->z = 0.0f;
    break;
    case POS_DEFENDER_4:
      pos->x = 2.0f;
      pos->y = 1.5f;
      pos->z = 0.0f;
    break;
    default:
      pos->x = 0.0f;
      pos->y = 0.0f;
      pos->z = 0.0f;
    break;
  }
  if (position > POS_5 && position < POS_ZAGRYWKA )
  {
     //tymczasowy hak!
     /*if (pTeam->GetTeamNumber() == TEAM_1)
     {

       pos->y -= 1.0f;
     }*/
     if (pTeam->GetTeamNumber() == CGame::Instance()->GetRotatedTeam())
     {
       pos->x *= -1;
     }
  }
}

PositionOnField CPlayer::GetRealPosition(PositionOnField position)
{
#if 0
   switch(position)
   {
     case POS_BLOK_0:
     case POS_BLOK_3:
     case POS_BLOK_5:  
     case POS_DEFENDER_3:
       return POS_3;
     case POS_BLOK_1:
     case POS_BLOK_6:
     case POS_BLOK_7:
       return POS_4;
     case POS_BLOK_2:
     case POS_BLOK_4:
     case POS_BLOK_8:
     case POS_DEFENDER_4:
       return POS_5;
     case POS_ZAGRYWKA:
     case POS_DEFENDER_2:
       return POS_2;
     case POS_DEFENDER_0:
       return POS_0;     
     case POS_DEFENDER_1:
       return POS_1;
     default:
       return position;
  }
#else
   switch(position)
   {
     case POS_BLOK_0:
     case POS_BLOK_3:
     case POS_BLOK_5:  
     case POS_DEFENDER_3:
     case POS_BLOK_1:
     case POS_BLOK_6:
     case POS_BLOK_7:
     case POS_BLOK_2:
     case POS_BLOK_4:
     case POS_BLOK_8:
     case POS_DEFENDER_4:
     case POS_DEFENDER_2:
     case POS_DEFENDER_0:
     case POS_DEFENDER_1:
       return this->mBlokReturnPosition;
     case POS_ZAGRYWKA:
       return POS_2;
     default:
       return position;
    }
#endif
}

int CPlayer::GetResiveStatesArray(State **ReceiveStates, bool UseScina)
{
  int i, mod = 0;

  if (UseScina && !this->is_libero)
  {
    LogWarning("Team %d : Zawodnik %d : Uzywam sciny !", this->pTeam->GetTeamNumber(), this->mPosition);
    ReceiveStates[0] = new CStatePrzyjencieScina(NULL, this);
    ReceiveStates[1] = new CStatePrzyjencieScinaLow(NULL, this);
    if(!this->pTeam->IsAi())
    {
      return 2;
    }
    mod = 2;
  }


  if(!this->is_main)
  {
  i = mod + myrand(3);
  while(ReceiveStates[i])
  {
    i = mod + myrand(3);
  }
  }
  else
  {
    i = mod + 0;
  }
  ReceiveStates[i] =  new CStatePrzyjencieSkok(NULL,this);
  
  if(!this->is_main)
  {
  while(ReceiveStates[i])
  {
    i = mod + myrand(3);
  }
  }
  else
  {
    i = mod + 1;
  }
  ReceiveStates[i] =  new CStatePrzyjencieGorne(NULL,this);

  if(!this->is_main)
  {
  while(ReceiveStates[i])
  {
    i = mod + myrand(3);
  }
    }

  else
  {
    i = mod + 2;
  }
  ReceiveStates[i] =  new CStatePrzyjencieDolne(NULL,this);

  if(!this->is_main)
  {
  while(ReceiveStates[i])
  {
    i = mod + myrand(3);
  }
  }
  else
  {
    i = mod + 3;
  }
  ReceiveStates[i] =  new CStatePrzyjencieKolana(NULL,this);

  /* zawsze sprawdzaj na koncu */
  i = 0;
  while(ReceiveStates[i])
  {
    i++;
  }
  ReceiveStates[i] = new CStatePrzyjencieStopa(NULL,this);

  return i+1;
}


/*
  funkcja ustawiaj¹ca odbicie zale¿nie od czasu i odleg³osci od punktu odbioru
  do okreœlonego kierunku a animacje odbicia wykonuje przy ANGLE_0.
  Jedna z najwazniejszych funkcji... Zrozumiesz to szalenstwo to zrozumiesz wszechswiat !
*/


bool CPlayer::SelectReceiveState(CVector3 *target_point, bool Attack, bool Deffend)
{
#define MAX_ODBIC 7
  State *LastState;
  State *ReceiveStates[MAX_ODBIC] = {NULL}; 
  int i;
  int ScinaTweak;

  /* wypelni tablice odbic losowa (prawie) kolejnoscia odbic */
  ScinaTweak = GetResiveStatesArray(ReceiveStates, Attack && !Deffend);
  
  CVector3 BallPositions[MAX_ODBIC];
  CVector3 AnimStartPositions[MAX_ODBIC];
  CVector3 PositionDeltas[MAX_ODBIC];
  CVector3 FinishPostion;
  float Times[MAX_ODBIC];
  float Durations[MAX_ODBIC];
  float end_time;

  CVector3 current_pos;

  /* czas i miejsce reakcji uzaleznione od tego kto kieruje playerem */
  if (this->pTeam->IsAi())
  {
    end_time = CBall::Instance()->GetFlightTimeByPercentage(0.3f);
    if (end_time < NOW)
      end_time = NOW;
    LastState = CurrentState->GetStateByTime(end_time);
    if (LastState == NULL)
    {
      LastState = CurrentState->GetLast();
      LastState = StateManager::Instance()->GetState(STATE_IDLE, LastState, this);
    }
  }
  else
  {
    LastState = CurrentState;
    end_time = NOW;
  }

  State* remState = LastState;
  LastState->GetPositionByTime(&current_pos, end_time);
  LastState->SetEndTime(end_time);
  this->SetOdbijam(true);
  
  float z;
  /* sprawdzanie kolejnych odbic */
  for (i = 0; i < ScinaTweak; i++)
  {
     if(!ReceiveStates[i]) continue;

     if(((Attack && this->is_libero) || Deffend) &&
       ( ReceiveStates[i]->GetCurrent() == PRZYJECIE_SKOK ||
         ReceiveStates[i]->GetCurrent() == PRZYJECIE_GORNE )) continue;

     if(this->is_libero && this->pTeam->IsAi() &&
       ( ReceiveStates[i]->GetCurrent() == PRZYJECIE_SKOK ||
         ReceiveStates[i]->GetCurrent() == PRZYJECIE_GORNE )) continue;

     BallPositions[i] = ReceiveStates[i]->GetBallOffset();

     z = BallPositions[i].z * mHeightScale;
     Times[i] = CBall::Instance()->GetPointByZ(z, &BallPositions[i]);

     this->GetTeam()->WorldToTeam(&BallPositions[i]);

     if (BallPositions[i].y < BALL_RADIUS) 
     {
#ifdef DEBUG
       LogWarning("Team %d : Zawodnik %d : Olalem odbicie :%s, bo musialbym przejsc przez siatke",
                   this->pTeam->GetTeamNumber(), this->mPosition, ReceiveStates[i]->StrCurrentState); 
#endif
       continue;
     }

     AnimStartPositions[i] = BallPositions[i] - ReceiveStates[i]->GetBallOffset();

     FinishPostion = AnimStartPositions[i] + ReceiveStates[i]->GetOffset() +
                                *this->GetOffset(ReceiveStates[i]->GetProposedNext());

     if(FinishPostion.y < BALL_RADIUS)
     {
#ifdef DEBUG
       LogWarning("Team %d : Zawodnik %d : Olalem odbicie :%s, bo wracajac musialbym przejsc przez siatke",
                   this->pTeam->GetTeamNumber(), this->mPosition, ReceiveStates[i]->StrCurrentState); 
#endif
       continue;
     }

     Durations[i] = ReceiveStates[i]->GetHitDuration();

     remState->SetNextState(NULL);

     /* generacjai lancuszkow dojscia */
     if (NULL == this->pTeam->GetMoveStates(this, remState,&AnimStartPositions[i]) )
     {
       continue;
     }
     
     /* popranie czasu dotarcia na miejsce */
     LastState = remState->GetLast();
     end_time = LastState->GetEndTime();

     if ((Times[i] - end_time) < Durations[i]) 
     {
#ifdef DEBUG
       LogWarning("Team %d : Zawodnik %d : Olalem odbicie :%s"
               ,this->pTeam->GetTeamNumber(), this->mPosition,ReceiveStates[i]->StrCurrentState);
#endif
       continue;
     }

     {
       /* fix star error */
       CVector3 lastPos;

       LastState->GetPositionByTime(&lastPos,end_time);
       if (lastPos.y < 0.1f)
       {
         continue;
       }
     }

     /* sprawdzwenie czy mamy czas na hinta */
     if( Times[i] - Durations[i] > end_time )
     {
       if(LastState->GetEndDir() != ANGLE_0)
       {
         /* sprawdzwenie czy mamy czas na obrut do Hinta w ANGLE_0 */
         States rot = LastState->GetRotationStateFromDir(ANGLE_0);
         if (Times[i] - Durations[i] > end_time + this->GetDuration(rot))
         {
           LastState = StateManager::Instance()->GetState(rot, LastState, this);
#ifdef DEBUG
           LogError("Team %d : Zawodnik %d : Mam czas na obrot :%s"
               ,this->pTeam->GetTeamNumber(), this->mPosition, LastState->StrCurrentState);
#endif
         }
       }
       /* wygenerowanie hinta w zaleznosci od wybranego odbicia */
       switch(ReceiveStates[i]->GetCurrent())
       {
         case PRZYJECIE_SKOK:
         case PRZYJECIE_GORNE:
           LastState = StateManager::Instance()->GetState(PRZYJECIE_GORNE_HINT, LastState, this);
         break;
         case PRZYJECIE_DOLNE:
         case PRZYJECIE_KOLANA:
         case PRZYJECIE_STOPA:
           LastState = StateManager::Instance()->GetState(PRZYJECIE_DOLNE_HINT, LastState, this);
         break;
         case PRZYJECIE_SCINA:
         case PRZYJECIE_SCINA_LOW:
         default:
           LastState = StateManager::Instance()->GetState(STATE_IDLE, LastState, this);
         break;
       }
#ifdef DEBUG
       LogError("Team %d : Zawodnik %d : Mam czas na Hinta :%s"
               ,this->pTeam->GetTeamNumber(), this->mPosition, LastState->StrCurrentState);
#endif
     }

     /* dodanie wybranego obicia na koncu lancuszka dojscia */
     LastState->SetEndTime(Times[i] - Durations[i]);
     LastState->SetNextState(ReceiveStates[i]);
/*
#ifdef DEBUG
     {
       float len;
       CVector3 lastPos;
       LastState->GetPositionByTime(&lastPos,LastState->GetEndTime());
       lastPos -= AnimStartPositions[i];
       
       len=lastPos.Length();
       if ( len < 0.6f )
        LogError("Possible teleportation : %lf",len);
       //DIE(len < 0.6f);
     }
#endif
*/
     /* to cudenko daje mozliwa teleportacje */
     ReceiveStates[i]->GetStartPosition()->Set(&AnimStartPositions[i]);

#ifdef DEBUG
     LogError("Team %d : Zawodnik %d : Wybralem odbicie :%s"
               ,this->pTeam->GetTeamNumber(), this->mPosition,ReceiveStates[i]->StrCurrentState);
#endif
/*   
    if (Attack)
    {
      CBall::Instance()->UsePrzebicieTarget();
    }
*/
    Attack = (ReceiveStates[i]->GetCurrent() == PRZYJECIE_SCINA || 
                ReceiveStates[i]->GetCurrent() == PRZYJECIE_SCINA_LOW);

    /*
     * wyslanie wiadomosci do pilko "kiedy" i "gdzie" bedzie odbita,
     * to "gdzie" jest wazne tylo dla AI bo user i tak celuje rencznie pilka.
     */
    {
      BallHitStruct *hs = new BallHitStruct();

      hs->isError = (ReceiveStates[i]->GetCurrent() == PRZYJECIE_STOPA ||
                      (Attack && (this->pTeam->GetPhase() == TP_RECEIVE_2)));
      hs->TeamNum = this->pTeam->GetTeamNumber();
      hs->HitPoint = BallPositions[i];
      this->pTeam->TeamToWorld(&hs->HitPoint);     
      hs->TargetPoint.Set(target_point);
      this->pTeam->TeamToWorld(&hs->TargetPoint); 
      hs->HitCount = CBall::Instance()->GetHitCount();
      POST_EVENT3(ET_BALL, BE_GOT_HIT, Times[i], hs);
    }

    if (SetupManager::Instance()->GetSound()->ball)
    {
      unsigned int id;
      CVector3 *pos = new CVector3();
      pos->Set(&BallPositions[i]);
      switch (ReceiveStates[i]->GetCurrent())
      {
        case PRZYJECIE_SCINA:
        case PRZYJECIE_SCINA_LOW:
          id   = WAV_5;
        break;

        case PRZYJECIE_SKOK:
        case PRZYJECIE_GORNE:
          id   = WAV_4;
        break;

        default:
          id   = WAV_3;
        break;
      }
      POST_EVENT3(ET_AUDIO, id, Times[i], pos);
    }

    if(Attack)
    {
      CBall::Instance()->SetScina(true);
      POST_EVENT3((this->pTeam->GetTeamNumber() ? ET_TEAM_1 : ET_TEAM_0 ),
                   TE_MAKE_DECOY,ReceiveStates[i]->GetStartTime(), NULL);

      BlockData *pBlok = new BlockData;
      pBlok->HitPos.Set(&BallPositions[i]);
      this->pTeam->TeamToWorld(&pBlok->HitPos);
      pBlok->HitTime = ReceiveStates[i]->GetStartTime() + ReceiveStates[i]->GetHitDuration();
      POST_EVENT((this->pTeam->GetTeamNumber() ? ET_TEAM_0 : ET_TEAM_1 ),
                   TE_PRZEBICIE , false, pBlok);
    }

    if (this->GetTeam()->IsAi())
    {
      if (Attack)
      {
        CBall::Instance()->SetAIAlpha(GaussRand(0.5f *
            (CBall::Instance()->MIN_SCINA_ALPHA + CBall::Instance()->MAX_SCINA_ALPHA),0.2f,
             CBall::Instance()->MIN_SCINA_ALPHA, CBall::Instance()->MAX_SCINA_ALPHA));
      }
      else
      {
        CBall::Instance()->SetAIAlpha(GaussRand(0.5f *
          (CBall::Instance()->MIN_HIT_ALPHA + CBall::Instance()->MAX_HIT_ALPHA),0.2f,
           CBall::Instance()->MIN_HIT_ALPHA, CBall::Instance()->MAX_HIT_ALPHA));
      }
    }
    
    for (int j = 0; j <ScinaTweak; j++)
    {
      if (j == i) continue;
      if(ReceiveStates[j])
      {
        delete ReceiveStates[j];
      }
    }

    return true;
  }

  this->SetOdbijam(false);

  for (int j = 0; j < ScinaTweak; j++)
  {
     if(ReceiveStates[j])
     {
        delete ReceiveStates[j];
     }
  }

#ifdef DEBUG
  LogError("Team %d : Zawodnik %d : Olalem wszystkie odbicia bo nie mialem czasu", this->pTeam->GetTeamNumber(), this->mPosition); 
#endif

  return false;

  //odegraj szczupaka albo i nie
  CVector3 delta;
  remState->GetPositionByTime(&delta,NOW);
  CVector3 delta2 = delta - *target_point;
  delta2.Normalize();
  delta2 *=2.5;
  if (delta.y + delta2.y < 0.2f) return false;
  if (delta.x + delta2.x > 7.5f) return false;
  if (delta.x + delta2.x < -7.5f) return false;
  
  delta = delta2;
  this->SetOdbijam(true);
  remState = CurrentState->GetLast();
  remState->SetNextState(NULL);
  remState->SetProposedNext(STATE_SZCZUPAK);
  if (remState == CurrentState)
  remState->SetEndTime(NOW);
  remState = remState->GetNext(true);  
  CVector3 north(0.0f,-1.0f,0.0f);
  delta.Normalize();
  float cos_val = delta.Dot(&north);

  float angle = acosf(cos_val);
  if (delta.x < 0.0f)
  {
    angle = 2 * PI  - angle;
  }
  remState = CurrentState->Update();
  remState->SetFreeAngle(angle,false);


#undef MAX_ODBIC
  return false;
}

/* sprawdza czy mojej nowej pozycji nie zajmuje jakis payer o wyzszym priorytecie */
bool CPlayer::CanMoveToNewPosition(CVector3 *pNewPos)
{
  CVector3 pos1;
  CPlayer *curPlayer;

  if(GetPriority() == 0) return true;

  for (int i = 0; i < MAX_PLAYERS_IN_TEAM; i++)
  {    
    curPlayer = pTeam->GetPlayer(i);
    if (curPlayer == this) continue;
    if ( curPlayer->GetPriority() < GetPriority() &&
         curPlayer->GetCurrentState()->IsCurrentIdle())
    {
      //curPlayer->GetCurrentState()->RecalcLastPosition();
      //pos1.Set(curPlayer->GetCurrentState()->GetLastPosition());
      /* jesli IDLE to lastpos == startpos */
      pos1.Set(curPlayer->GetCurrentState()->GetStartPosition());
      pos1 -= *pNewPos;
      float len = pos1.Length();
      if ( len < PLAYER_DIM * 2.0f )
        return false;
    }
  }
  return true;
}

void CPlayer::Update() 
{ 
  State *oldCurState = CurrentState;

    
  State *LastState = CurrentState->GetLast();
  CVector3 distVec;

  bool canMoveThere = this->CanMoveToPosition();
  if (  !this->odbijam && canMoveThere )
  {
    LastState->GetPositionByTime(&distVec, LastState->GetEndTime());


    {
      CVector3 distVec2 = distVec - NewPos;
    /* mamy cosik do przejscia lub cosik koliduje z nami w miejscu w którym stoje */
      canMoveThere = (distVec2.Length() > 0.4f/*EPSILON*/ );
    }

    if( canMoveThere && !this->odbijam && this->is_ai)
    {
      CurrentState->SetEndTime(NOW);
      if(NULL == this->pTeam->GetMoveStates(this, CurrentState, &NewPos))
      {
        NewPos = distVec;
      }
    }
  }
  
  /* To jest duzy hack i mocno podejzany */
  LastState = CurrentState->GetLast();
  if(CurrentState->GetCurrent() == STATE_IDLE && LastState == CurrentState)
  {
    switch(this->mPosition)
    {
      case POS_ZAGRYWKA:
        this->CurrentState->SetProposedNext(ZAGRYWKA_HINT);
        this->CurrentState->SetEndTime(NOW);
        this->GetTeam()->SetUserFromTeam(this);
      break;
      case POS_BLOK_0:
      case POS_BLOK_1:
      case POS_BLOK_2:
      case POS_BLOK_3:
      case POS_BLOK_4:
      case POS_BLOK_5:
      case POS_BLOK_6:
      case POS_BLOK_7:
      case POS_BLOK_8:
        if(this->pTeam->IsAi())

        {
          this->GetCurrentState()->SetEndDir(ANGLE_0);
        }
        this->CurrentState->SetProposedNext(PRZYJECIE_BLOK_HINT);
        this->CurrentState->SetEndTime(NOW);
        this->SetBlocking();
        this->GetTeam()->SetUserFromTeam(this);
      break;
      default:
        break;
    }
  } 
  
  if((this->mPosition == POS_ZAGRYWKA) && !this->is_ai)
  {      
    this->MoveCameraInZagrywka();
  }
  
  /* Update */
  LastState = CurrentState;
  CurrentState = CurrentState->Update(); 

  /* hack ze az milo */
  if(this->is_ai && CurrentState->GetCurrent() == PRZYJECIE_BLOK_HINT)
  {
    this->GetTeam()->SetUserFromTeam(this);
  }

  /* sprawdz kolizje z scianami */
  if ( !this->odbijam && !this->is_ai && this->CurrentState->GetCurrent() == RUN_FAST)
  {
    this->pTeam->FixFieldPositions(this);
  }

  if(CurrentState->IsCurrentIdle())
  {
    this->lastCollisionPlayer = NULL;    
    lastCollisionPlayerTime = 0;
    this->NewPos = this->NewPosFromTactic;
  }

}

void CPlayer::MoveCameraInZagrywka()
{
  CVector3 curPos;
  CVector3 lookAt; 
  CVector3 upVec(0,0,1);
  CVector3 moveAwayVec(0,8,5);

  if ( this->pTeam->GetTeamNumber() == TEAM_0 &&
      SceneManager::Instance()->GetCamera()->GetCurrentCamera()!=0 )
      return;

  if ( this->pTeam->GetTeamNumber() == TEAM_1 &&
      SceneManager::Instance()->GetCamera()->GetCurrentCamera()!=1 )
      return;

  this->CurrentState->GetPositionByTime(&curPos, NOW);
       
  lookAt = curPos;
  lookAt.y = 0;

  curPos += moveAwayVec;
  SceneManager::Instance()->GetCamera()->SaveViewSettings();
  SceneManager::Instance()->GetCamera()->SetViewParams(curPos, lookAt, upVec);
}

float CPlayer::GetDuration(States Current)
{
  return AnimationManager::Instance()->GetAnimation(this->AnimationsHandlers[Current])->GetDuration() ;
}

 CVector3 * CPlayer::GetOffset(States Current)
 {
   return AnimationManager::Instance()->GetAnimation(this->AnimationsHandlers[Current])->GetOffset();

 }

float CPlayer::GetHitDuration(States Current)
{
  return AnimationManager::Instance()->GetAnimation(this->AnimationsHandlers[Current])->GetHitDuration() ;
}

HAnimation CPlayer::GetStateAnimationHandler(States Current, unsigned int stage)
{
  char buffer[64];
  const char *state_name = StateManager::Instance()->GetStateDatFile(Current);

  my_snprintf(buffer, 64, "%s\\%s%d.dat", this->model, state_name, stage);

  this->AnimationsHandlers[Current] = AnimationManager::Instance()->GetAnimationHandlerLoad(buffer);

  return this->AnimationsHandlers[Current];
}

State *CPlayer::ForceUpdate()
{
  this->CurrentState = this->CurrentState->Update();
  return CurrentState;
}


#ifdef DEBUG


char *CPlayer::GetPosStr(char *bufferPlayer, int size)
{
  char *PosStrs[] = 
  {
  "POS_0",
  "POS_1",
  "POS_2",
  "POS_3",
  "POS_4",
  "POS_5",
  
  "SUB_0",
  "SUB_1",
  "SUB_2",
  "SUB_3",
  "SUB_4",
  "SUB_5",

  "POS_ZAGRYWKA",

  "POS_BLOK_0",
  "POS_BLOK_1",
  "POS_BLOK_2",
  "POS_BLOK_3",
  "POS_BLOK_4",
  "POS_BLOK_5",
  "POS_BLOK_6",
  "POS_BLOK_7",
  "POS_BLOK_8",

  "POS_DEFENDER_0"
  "POS_DEFENDER_1"
  "POS_DEFENDER_2"
  "POS_DEFENDER_3"
  "POS_DEFENDER_4"

  };

  cat_snprintf(bufferPlayer, size, "Pos : %s", PosStrs[this->GetPosOnField()]);

  return bufferPlayer;
}

#endif
E:\Project\Kopia (5) VBEngine\Core\zawodnik.h
#ifndef _ZAWODNIK_H
#define _ZAWODNIK_H

/*
class       :
description :

methods     :

*/


class CTeam;
class State;
class Animation;

#define AVERAGE_HEIGHT 1.80f

struct BlockData
{
  CVector3 HitPos;
  float HitTime;
};


class CPlayer :public SceneObject, public EventHandler
{
  unsigned char mIndex;
  State *CurrentState;
  CTeam *pTeam; //team do ktorego nalezy player  
  int Init(char* playerFileName);
  bool IsOnPlane;
  bool is_ai;
  bool mWasReceiving;
  bool odbijam;
  bool is_libero;
  bool is_libero_substitute;
  bool is_blocking;
  bool is_main;
  char model[MAX_FILE_NAME];
  char secondName[MAX_STRING_LENGTH];
  int personNumber;
  
  void SetPos(CVector3 *pos, PositionOnField position);
  PositionOnField mPosition;
  PositionOnField mBlokReturnPosition;
  int Priority;

  
  CVector3 NewPos;
  CVector3 NewPosFromTactic;

  HTexture LinkTexture;
  HTexture LinkNumerTexture;
  HTexture PersonalTexture;
  HTexture NumerTexture;
  HTexture ShoeTexture;
  HTexture SellectorLink;
  HTexture SellectorRed;
  HTexture SellectorGreen;
  HTexture SellectorBlue;

  HAnimation mSellector_Animation;
  HAnimation AnimationsHandlers[LAST_STATE];

  //cechy charakterystyczne
  
  HTexture mFaceTexture;
  HTexture mFaceOriginal;
  HTexture mSkinTexture;
  HTexture mSkinOriginal;
  float mHeight;
  float mHeightScale;
  int GetResiveStatesArray(State **ReceiveStates, bool UseScina);
public: 
  float speed_scale;
  //

  HAnimation GetStateAnimationHandler(States Current, unsigned int stage);

  float GetDuration(States Current);
  float GetHitDuration(States Current);
  CVector3 * GetOffset(States Current);
  bool IsMain(void) {return this->is_main;};
  void SetMain(bool m) {this->is_main = m;};
  bool CanMoveToPosition(void) { return this->CanMoveToNewPosition(&this->NewPos);};
  bool CanMoveToNewPosition(CVector3 *pNew);
  void MoveCameraInZagrywka();
  CPlayer *lastCollisionPlayer;
  float lastCollisionPlayerTime;
  bool CzyOdbijam(void) {return this->odbijam;};
  void SetOdbijam(bool od) {this->odbijam = od;};
  void SetLibero(bool zw) {this->is_libero = zw;};
  bool IsLibero(void) { return this->is_libero; };
  void SetLiberoSubstitute(bool zw) {this->is_libero_substitute = zw;};
  bool IsLiberoSubstitute(void) {return this->is_libero_substitute;};
  void SetGoto(CVector3 *newpos) 
  {
    this->NewPos.Set(newpos); 
  };
  void SetPosFromTactic(CVector3 *newpos) 
  { 
    if (newpos->y < 0.0f)
    {
      int i = 0 ;
    }
    this->NewPosFromTactic.Set(newpos); 
    this->SetGoto(newpos);
  };
  CPlayer(CTeam *team, char* playerFileName, bool libero,bool libero_substitute);
  ~CPlayer();

#ifdef DEBUG  
    char *GetPosStr(char *bufferPlayer, int size);
#endif

  void ProcessEvent(Event *event);
  void Update();
  void Render(CMatrix4 *pViewProj);

  void SetIsOnPlane(bool isOnPlane) { this->IsOnPlane = isOnPlane; }
  bool GetIsOnPlane() { return true;}//this->IsOnPlane; }

  void SetStartPosition(PositionOnField _position)
  {
    this->SetPos(this->CurrentState->GetStartPosition(), _position); 
    this->NewPos.Set(this->CurrentState->GetStartPosition());
    this->NewPosFromTactic.Set(this->CurrentState->GetStartPosition());
  };
  void SetGotoPosition(PositionOnField _position)
  {
    this->SetPos(&this->NewPos, _position);
    this->NewPosFromTactic.Set(&this->NewPos);
  };
  PositionOnField GetRealPosition(PositionOnField position);
  char* GetModel() { return this->model; }
  void SetAI(bool bl) { this->is_ai = bl; };
  bool IsAI(void) { return is_ai; };
  CTeam *GetTeam() {return pTeam;};

  State *GetCurrentState(void) { return this->CurrentState; };
  Direction GetCurrentDir(void) { return this->CurrentState->GetDir(); }
  bool SelectReceiveState(CVector3 *target_point,bool UseScina = false, bool Deffend = false);
  void GetCurrentPosition(CVector3 *out) {CurrentState->GetCurrentPosition(out);};
  bool WasReceiving()      {return mWasReceiving;}
  void SetWasReceiving()   {mWasReceiving = true;}
  void ClearWasReceiving() {mWasReceiving = false;}
  PositionOnField GetPosOnField(void) { return mPosition; }
  PositionOnField GetBlokReturnPosition(void) {return mBlokReturnPosition;};
  void SetBlokReturnPosition(PositionOnField pos) { this->mBlokReturnPosition = pos; }
  void SaveBlokReturnPosition(void) { this->mBlokReturnPosition = mPosition; }
  void SetPosOnField(PositionOnField pos) { this->mPosition = pos; }
  void SetPriority(int pr) { this->Priority = pr; }
  int GetPriority(void) { return this->Priority; }
  void AddUserMask(unsigned int mask) { this->RemoveMask( ET_USER_MASK_SUM ); this->AddMask(mask); }  
  void ClearUserMask() {this->RemoveMask( ET_USER_MASK_SUM );}  
  bool IsUserControlled() { return this->TestMask( ET_USER_MASK_SUM ); }
  bool IsBlocking() {return this->is_blocking;};
  void SetBlocking() {this->is_blocking = true;};
  void ClearBlocking() {this->is_blocking = false;};
  
  
  CVector3 *GetNewPos() { return &this->NewPos; }
  CVector3 *GetNewPosFromTactic() { return &this->NewPosFromTactic; }
  float GetHeightScale() {return this->mHeightScale;}
  void SetNumber(int num) { this->personNumber = num; }
  void AddPersonalTexture(bool genshirt, bool color);
  State *ForceUpdate();

  
  void SetIndex(unsigned char idx) {this->mIndex = idx;}
  unsigned char GetIndex() {return this->mIndex;}
};

#endif 
E:\Project\Kopia (5) VBEngine\FileSystem\BranchNode.cpp
#include "..\config.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "..\utility\defines.h"
#include "..\utility\singleton.h"

#include "FileNode.h"
#include "LeafNode.h"
#include "BranchNode.h"

#include "filesystem.h"

struct DirHeader
{
  unsigned long fourcc;
  unsigned long size;
  unsigned long count;
};

BranchNode::BranchNode(void *data,DirEntry *descriptor) : FileNode (data,descriptor)
{
  DirHeader *header;
  header = (DirHeader*)((char *)data  + descriptor->FileOffset);

  assert(header->fourcc == MAKEFOURCC('D','I','R','_'));

  this->mFileList = new DirEntry[header->count];
//  fread(this->mFileList,sizeof(DirEntry), header->count,datafile);
  this->mFileList = (DirEntry*)((char *)data  + descriptor->FileOffset + sizeof(DirHeader));
  mFileCount = header->count;
  for (unsigned long i = 0 ; i < this->mFileCount; i++)
  {
    mFileList[i].FileOffset += descriptor->FileOffset;
    if (mFileList[i].fourcc == MAKEFOURCC('D','I','R','_'))
    {
      mFileList[i].NodeObject =  new BranchNode(data,mFileList + i);
    }
    else
    {
      mFileList[i].NodeObject =  new LeafNode(data,mFileList + i);
    }
  }


}


BranchNode::BranchNode(FILE *datafile,DirEntry *descriptor) : FileNode (datafile,descriptor)
{
  DirHeader header;
  fseek(datafile,descriptor->FileOffset,SEEK_SET);
  fread(&header,sizeof(DirHeader),1,datafile);

  assert(header.fourcc == MAKEFOURCC('D','I','R','_'));

  this->mFileList = new DirEntry[header.count];
  fread(this->mFileList,sizeof(DirEntry), header.count,datafile);
  mFileCount = header.count;
  for (unsigned long i = 0 ; i < this->mFileCount; i++)
  {
    mFileList[i].FileOffset += descriptor->FileOffset;
    if (mFileList[i].fourcc == MAKEFOURCC('D','I','R','_'))
    {
      mFileList[i].NodeObject =  new BranchNode(datafile,mFileList + i);
    }
    else
    {
      mFileList[i].NodeObject =  new LeafNode(datafile,mFileList + i);
    }
  }
}

BranchNode::~BranchNode()
{
  DirEntry *fileDescriptor = this->mFileList;
  for (unsigned long i = 0 ; i < this->mFileCount; i++)
  {
    delete fileDescriptor->NodeObject;
    fileDescriptor ++;
  }
  delete[] mFileList;
}


bool BranchNode::DoYouHaveIt(char *name)
{
  if (*name == '\\') name++;
  char *slash = strchr(name,'\\');
  if (slash == NULL) return false;
  if (_strnicmp(this->mDescriptor->name,name,slash - name) == 0)
    return true;

  return false;
}

void *BranchNode::Load(char * name,unsigned int *size)
{
  if (*name == '\\') name++;
  name = strchr(name,'\\');

  if (name == NULL) return NULL; // to sie nie powinno zdarzyc

  while(name[0] == '\\') name++;
  if (name[0] == '\0' ) return NULL; // to sie nie powinno zdarzyc

  DirEntry *fileDescriptor = this->mFileList;
  for (unsigned long i = 0 ; i < this->mFileCount; i++)
  {
    if (fileDescriptor->NodeObject->DoYouHaveIt(name))
    {
      return (fileDescriptor->NodeObject->Load(name,size));
    }
    fileDescriptor ++;
  }
  return NULL;
}


void BranchNode::Purge()
{
  DirEntry *fileDescriptor = this->mFileList;
  for (unsigned long i = 0 ; i < this->mFileCount; i++)
  {
    fileDescriptor->NodeObject->Purge();
    fileDescriptor++;
  }
}
E:\Project\Kopia (5) VBEngine\FileSystem\BranchNode.h
#ifndef _BRANCHNODE_H
#define _BRANCHNODE_H

class BranchNode :public FileNode
{
  unsigned long mFileCount;
  DirEntry *mFileList;
public:
  BranchNode(FILE *datafile, DirEntry *descriptor);
  BranchNode(void *data, DirEntry *descriptor);
  ~BranchNode(void);
  virtual bool DoYouHaveIt(char *name);
  virtual void *Load(char *name,unsigned int *size);
  virtual void Purge();
};


#endif
E:\Project\Kopia (5) VBEngine\FileSystem\FileNode.h
#ifndef _FILENODE_H
#define _FILENODE_H


struct DirEntry;


class FileNode
{
protected:
  FILE *mDataFile;
  DirEntry *mDescriptor;
  void *data;
public:
  FileNode(FILE *datafile, DirEntry *descriptor) :mDataFile(datafile) , mDescriptor(descriptor) {}
  FileNode(void *fdata, DirEntry *descriptor) :data(fdata) , mDescriptor(descriptor) {}
  virtual ~FileNode(void) {}
  virtual bool DoYouHaveIt(char *name) = 0;
  virtual void *Load(char *name,unsigned int *size) = 0;
  virtual void Purge() = 0;
};




#endif
E:\Project\Kopia (5) VBEngine\FileSystem\FileSystem.cpp
#include "..\config.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <direct.h>
#include <time.h>

#include <io.h>
#include <stdlib.h>
#include <search.h>
#include "..\utility\defines.h"
#include "..\utility\singleton.h"
#include "..\utility\vbmath.h"

#include "FileNode.h"
#include "LeafNode.h"
#include "BranchNode.h"

#include "filesystem.h"

FileSystem::FileSystem(char *FileName)
{
  this->mDataFileCount = 0;
  this->data = NULL;
  this->mDataFile = fopen(FileName, "rb");
  if (this->mDataFile == NULL) return;
  
  this->RootEntry= new DirEntry;

  RootEntry->FileOffset = 0;
  RootEntry->fourcc = MAKEFOURCC('D','I','R','_');

  RootEntry->name[0] = '.';
  RootEntry->name[1] = '\0';

  this->mRootNode = new BranchNode(mDataFile,RootEntry);
  RootEntry->NodeObject = mRootNode;
}

FileSystem::~FileSystem(void)
{
  if (this->mDataFile != NULL) 
  {
    fclose(this->mDataFile);
    delete this->mRootNode;
    delete this->RootEntry;
  }
  if (this->data != NULL)
  {
    delete[] data;
    data = NULL;
  }
  for (int i = 0 ; i < this->mDataFileCount ; i++)
  {
    fclose(this->mSecondaryDataFiles[i].mFile);
    delete this->mSecondaryDataFiles[i].mRoot;
  }
}

void FileSystem::Flush()
{
  this->mRootNode->Purge();
  for (int i = 0 ; i < this->mDataFileCount ; i++)
  {
    this->mSecondaryDataFiles[i].mRoot->Purge();
  }
}

void *FileSystem::LoadFile(char *name,unsigned int *size)
{
  if (this->mDataFile == NULL) return NULL;

  for (int i = 0 ; i < this->mDataFileCount ; i++)
  {
    void *data = this->mSecondaryDataFiles[i].mRoot->Load(name,size);
    if (data != NULL)
      return data;
  }
  return mRootNode->Load(name,size); 
}

int DataFileSort(const void *_key, const void *_val)
{
  DataFile *key = (DataFile *)_key;
  DataFile *val = (DataFile *)_val;
  return (int)SGN(difftime(val->mLastAccessTime, key->mLastAccessTime));  
}


void FileSystem::FindDataFiles()
{
   _finddata_t curr_desc;
   intptr_t handle;
   handle = _findfirst("*.srt", &curr_desc);
   if (handle != -1) 
   {
     do
     {
       FILE *file = fopen(curr_desc.name,"rb"); 
     
       if (file != NULL)
        {
          this->mSecondaryDataFiles[this->mDataFileCount].mFile = file;
          this->mSecondaryDataFiles[this->mDataFileCount].mRootEntry.FileOffset = 0;
          this->mSecondaryDataFiles[this->mDataFileCount].mRootEntry.fourcc = MAKEFOURCC('D','I','R','_');
          this->mSecondaryDataFiles[this->mDataFileCount].mRoot = new BranchNode(file,
                                  &this->mSecondaryDataFiles[this->mDataFileCount].mRootEntry );
          this->mSecondaryDataFiles[this->mDataFileCount].mRootEntry.NodeObject = this->mSecondaryDataFiles[this->mDataFileCount].mRoot;
          this->mSecondaryDataFiles[this->mDataFileCount].mLastAccessTime = curr_desc.time_write; 
          this->mDataFileCount++;
        }
     
     }
     while(_findnext(handle,&curr_desc) == 0);
     _findclose(handle);
   }
   if (mDataFileCount > 1)
     qsort(this->mSecondaryDataFiles,mDataFileCount,sizeof(DataFile),DataFileSort); 
}
E:\Project\Kopia (5) VBEngine\FileSystem\FileSystem.h
#ifndef _FILESYSTEM_H
#define _FILESYSTEM_H

class BranchNode;
class FileNode;

struct DirEntry
{
  unsigned long fourcc;
  unsigned long FileOffset;
  char name[MAX_FILE_NAME];
  FileNode *NodeObject;
};

#ifndef _TIME_T_DEFINED
#ifdef  _WIN64
typedef __int64   time_t;       /* time value */
#else
typedef _W64 long time_t;       /* time value */
#endif
#define _TIME_T_DEFINED         /* avoid multiple def's of time_t */
#endif


#define MAX_DATAFILES 10

struct DataFile
{
  BranchNode *mRoot;
  FILE *mFile;
  DirEntry mRootEntry;
  time_t mLastAccessTime;
};

class FileSystem :
  public Singleton<FileSystem>
{
  FILE *mDataFile;
  DirEntry *RootEntry;
  BranchNode *mRootNode;
  DataFile mSecondaryDataFiles[MAX_DATAFILES];
  unsigned char mDataFileCount;
  void * data;
public:
  FileSystem(char *FileName);
  ~FileSystem(void);
  void FindDataFiles();
  void *LoadFile(char *name, unsigned int *size = NULL);
  void Flush();
};

#endif
E:\Project\Kopia (5) VBEngine\FileSystem\LeafNode.cpp
#include "..\config.h"

#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "..\utility\defines.h"
#include "..\utility\singleton.h"

#include "FileNode.h"
#include "LeafNode.h"
#include "BranchNode.h"

#include "filesystem.h"
struct DataHeader
{
  unsigned long fourcc;
  unsigned long size;
};

LeafNode::LeafNode(void *data,DirEntry *descriptor) : FileNode (data,descriptor)
{
  mData = ((char*)data + descriptor->FileOffset + 8);
  mSize = ((DataHeader*)((char*)data + descriptor->FileOffset))->size - 8;
}

LeafNode::LeafNode(FILE *datafile,DirEntry *descriptor) : FileNode (datafile,descriptor)
{
  mData = NULL;
  mSize = 0;
}


LeafNode::~LeafNode()
{
 if (mData) delete[] mData;
}


bool LeafNode::DoYouHaveIt(char *name)
{
  if (_strnicmp(name,this->mDescriptor->name,MAX_FILE_NAME) == 0)
    return true;
  return false;
}




void *LeafNode::Load(char *name,unsigned int *size)
{
  if (size != NULL ) *size = mSize;
  if (mData != NULL) return mData;
  DataHeader header;
  fseek(mDataFile,mDescriptor->FileOffset , SEEK_SET);
  fread(&header,sizeof(DataHeader),1, mDataFile);
  
  mData = new char[header.size - 8/*?*/];
  fread(mData,1,header.size-8,mDataFile);
  mSize = header.size - 8;
  if (size != NULL ) *size = mSize;
  return mData;

}


void LeafNode::Purge()
{
  if (mData == NULL) return;
  delete[] mData;
  mData = NULL;
  mSize = 0;
}
E:\Project\Kopia (5) VBEngine\FileSystem\LeafNode.h
#ifndef _LEAFNODE_H
#define _LEAFNODE_H


class LeafNode : public FileNode
{
  void *mData;
  unsigned int mSize;
public:
  LeafNode(FILE *datafile, DirEntry *descriptor);
  LeafNode(void *data, DirEntry *descriptor);
  ~LeafNode(void);
  virtual bool DoYouHaveIt(char *name);
  virtual void *Load(char *name,unsigned int *size);
  virtual void Purge();
};


#endif
E:\Project\Kopia (5) VBEngine\Graphics\animation.cpp
#include "..\config.h"

#include <assert.h>
#include <stdio.h>
#include <d3d9.h>
#include <d3dx9effect.h>

#include "..\utility\defines.h"
#include "..\utility\conf.h"
#include "..\utility\misc.h"
#include "..\Utility\Singleton.h"
#include "..\utility\VBmath.h"
#include "..\utility\ctime.h"
#include "..\utility\Tools.h"

#include "TextureManager.h"
#include "meshmanager.h"
#include "renderer.h"
#include "animation.h"

/* Konstuktor */
Animation::Animation()
{
  this->is_loaded = false;
  this->pFrameTab   = NULL;
  this->mDuration   = 0.0f;
  this->mRotation   = 0.0f;
  this->mBallOffset = CVector3(0.0f,0.0f,0.0f);
  this->mOffset     = CVector3(0.0f,0.0f,0.0f);
}
/* end of : Konstruktor */

/* Dekonstuktor */
Animation::~Animation()
{
  if(this->pFrameTab)
  {
    delete[] this->pFrameTab;
  }
} /* end of : DeKonstruktor */

/*
 * Inicjalizator
 * Skopiowanie nazwy pliku do wlasnego buffora z nazwa (nazwa moze miec max MAX_FILE_NAME znaków)
 */
void Animation::Init(const char *dat_name)
{
  my_snprintf(this->name, MAX_FILE_NAME, "%s", dat_name);
} /* end of : Init */

/*
 * Prorwnaj zadan¹ nazwe z nazw¹ pliku naszej animacji  (funkcja pomocnicza dla animation menagera)
 * zwraza True jesli sa to te same nazwy.
 */
bool Animation::Cmp(const char *mDatName)
{
  return (mDatName && mDatName[0] != '\0' && stricmp(this->name, mDatName) == 0);
} /* end of : Cmp(...) */


/*
 * Przeskaluj czasy twania calej sekwencji (poszczegulnych klatek) 
 */
void Animation::ScaleDelays(float f)
{
  this->mDuration = 0.0f;
  for(int i=0; i<this->mFrameCount; i++)
  {
    this->pFrameTab[i].start_time = this->mDuration;
    this->pFrameTab[i].duration *= f;
    this->mDuration += this->pFrameTab[i].duration;
  }
}; /* end of : ScaleDelays */

/*
 * Przeskaluj przesuniecia calej sekwencji (poszczegulnych klatek) 
 */
void Animation::ScaleOffsets(float f)
{
  this->mOffset.Set(0.0f, 0.0f, 0.0f);
  for(int i=0;i<this->mFrameCount;i++)
  {
    this->pFrameTab[i].total_offset = this->mOffset;
    this->pFrameTab[i].Offset *= f;
    this->mOffset += this->pFrameTab[i].Offset;
  }
}; /* end of : ScaleOffsets */

/*
 * Przeskaluj obroty calej sekwencji (poszczegulnych klatek) 
 */
void Animation::ScaleRotations(float f)
{
  this->mRotation = 0.0f;
  for(int i=0;i<this->mFrameCount;i++)
  {
    this->pFrameTab[i].total_rotation = this->mRotation;
    this->pFrameTab[i].rotation *= f;
    this->mRotation += this->pFrameTab[i].rotation;
  }
};  /* end of : ScaleRotations */

/*
 * Za³adowanie pliku animacji do pamiêci.
 *
 * W przypadku stwierdzenia zaladowania , sprawdzamy czy wciaz mamy zaladowane poszczegulne meshe.
 *
 * Najpierw szukane sa pliki na dysku a nastepnie w DataFile.
 *
 * Funkcjia wyjdze z blendem jesli :
 *  - przechowywana nazwa sekwencji bedzie nazwa bezposrednia.
 *  - plik z danymi sekwencji nie bedzie znaleziony ani na dysku ani w DataFile.
 *  - plik z danymi nie bedzie zawieral ilosci klatek w animacji
 */
bool Animation::Load()
{
  ConfFile anim_list;
  char *str;
  char path[MAX_PATH];
  char buffer[MAX_PATH];
  float fTmp;

  if(this->is_loaded)
  {
    for( int i = 0; i <  this->mFrameCount; i++)
    {
      CMeshManager::Instance()->LoadMeshWithTextures(this->pFrameTab[i].mesh);
    }
    return true;
  }

  str = strrchr(this->name, '\\' );
  if(!str)
  {
    return false;
  }

  *str = '\0';
  my_snprintf(path, MAX_PATH, "Moves\\%s",  this->name);
  *str = '\\';

  my_snprintf(buffer, MAX_PATH, "%sMoves\\%s", MeshDataPath, this->name);
  
    
  if (SUCCEEDED(anim_list.Init(buffer)))
  {

    if(FAILED(anim_list.GET_INT("FRAMES_COUNT", &this->mFrameCount)))
    {
      anim_list.DeInit();
      return false;
    }

    anim_list.GET_VECT("PILKA_OFFSET", &this->mBallOffset.x,
                                       &this->mBallOffset.y,
                                       &this->mBallOffset.z);

    this->pFrameTab = new Frame[this->mFrameCount];

    for(int i = 0; i < this->mFrameCount ; i++)
    {

      my_snprintf(buffer, MAX_PATH, "FRAME_%i",i);
      str = anim_list.GET_STR(buffer);

      my_snprintf(buffer, MAX_PATH, "%s\\%s", path, str);
      free(str);

      this->pFrameTab[i].mesh = CMeshManager::Instance()->GetMeshHandlerLoad(buffer);

      my_snprintf(buffer, MAX_PATH, "FRAME_%i_OFFSET",i);

      this->pFrameTab[i].total_offset = mOffset;

      anim_list.GET_VECT(buffer,&this->pFrameTab[i].Offset.x,
                                &this->pFrameTab[i].Offset.y,
                                &this->pFrameTab[i].Offset.z);

      mOffset += this->pFrameTab[i].Offset;

      my_snprintf(buffer, MAX_PATH, "FRAME_%i_ROTATION", i);
      this->pFrameTab[i].total_rotation = mRotation;

      anim_list.GET_FOLAT(buffer, &this->pFrameTab[i].rotation);

      this->pFrameTab[i].rotation *= PI/180;

      mRotation += this->pFrameTab[i].rotation;

      my_snprintf(buffer, MAX_PATH, "FRAME_%i_DELAY", i);
      this->pFrameTab[i].start_time = mDuration;

      anim_list.GET_FOLAT(buffer, &this->pFrameTab[i].duration);

      mDuration += this->pFrameTab[i].duration;

    }

    if(SUCCEEDED(anim_list.GET_FOLAT("SCALE_FRAMES_DELAYS", &fTmp)))
    {
      this->ScaleDelays(fTmp);
    }

    if(SUCCEEDED(anim_list.GET_FOLAT("SCALE_FRAMES_OFFSETS", &fTmp)))
    {
      this->ScaleOffsets(fTmp);
    }

    if(SUCCEEDED(anim_list.GET_FOLAT("SCALE_FRAMES_ROTATIONS", &fTmp)))
    {
      this->ScaleRotations(fTmp);
    }

    this->is_loaded = true;
    anim_list.DeInit();
    return true;
  }

  return false;
} /* end of : load */

/*
 *  Zwraca pierwsza klatke której czas rozpoczecia jest mniejszy od podanego czasu
 */
Frame * Animation::GetFrameByTime(float time)
{
  for(int i = this->mFrameCount - 1; i >= 0; i--)
  {
    if(this->pFrameTab[i].start_time <= time)
    {
      return &this->pFrameTab[i];
    }
  }
  return NULL;
} /* end of : GetFrameByTime */

/*
 *  Zwraca pierwsza klatke której czas rozpoczecia jest wiekszy od podanego czasu
 */
Frame * Animation::GetFollowingFrameByTime(float time)
{
  for(int i = 0; i < this->mFrameCount; i++)
  {
    if(this->pFrameTab[i].start_time >= time)
    {
      return &this->pFrameTab[i];
    }
  }
  return NULL;
} /* end of : GetFollowingFrameByTime */

/*
 * zwraca pierwsza klatke animacji
 */
Frame *Animation::GetFirstFrame()
{
  return &this->pFrameTab[0];
} /* end of : GetFirstFrame */
E:\Project\Kopia (5) VBEngine\Graphics\animation.h
#ifndef _ANIMATION_H
#define _ANIMATION_H

/*

class       : Animation
description : Klasa Animation obslugjaca podstawowe czynnosci przetwazajace klatki animacji.
              Przechowujemy tutaj wiadomosci o sekwencji animacji zawodnika :
                 tablice klatek, totalnego czasu, totalnego przesuniecia , itp..
methods     :
              Animation()   - konstruktor
              ~Animation()  - destruktor
              Init(...)     - kopiuje nazwe pliku z danymi animacji do wlasnego buffora
              Load()        - Ładuje animacjie z pliku danych (ustawionego przez Init(...))
              Cmp(...)      - porównanie szukaneej nazwy pliku z animacjia z naszym bufforem nazwy.
              IsLoaded()    - zwraca status zaladowania animacji

              GetDuration() - zwraca czas trfania animacji
              GetHitDuration() - zwraca czas trfania animacji do momentu udezenia w pilke (dla odbic)
              GetFrameByTime(...) - zwraca pierwsza klatke której czas rozpoczecia jest mniejszy od podanego czasu
              GetFollowingFrameByTime(...) - zwraca pierwsza klatke której czas rozpoczecia jest wiekszy od podanego czasu
              GetFirstFrame() - zwraca pierwsza klatke animacji
              GetOffset()     - zwraca przesuniecie zawodnik w czasi etej sekwencji animacji
              GetBallOffset() - zwraca pozycjie odbicia pili w tej sekwencji.
              ScaleDelays(...) - skaluj czasy trwania sekwencji;
              ScaleOffsets(...) - skaluj przesuniecia sekwencji;
              ScaleRotations(...) - skaluj obroty sekwencji;
              GetFrameCount() - podaj liczbe klatek w sekwencji.
              GetFrameByIndex(...) - podaj klatke o podanym indexie
*/


/* opis pojedynczej klarki animacji */
struct Frame
{
  HMesh mesh;            /* handler na wyswietlanego mesha */
  float start_time;      /* czas rozpoczecia klatki */
  float duration;        /* czas trwania klatki */
  CVector3 Offset;       /* przesuniecia pomiedzy klatkami */
  CVector3 total_offset; /* przesuniecia danej katki od poczatku sekwencji */
  float rotation;        /* obrot pomiedzy klatkami */
  float total_rotation;  /* obrot danej katki od poczatku sekwencji */
};

class Animation
{
  bool is_loaded;                   /* Stan zaladowania Animacji do pamieci */
  char name[MAX_FILE_NAME];         /* nazwa pliku z danymi o klatkach , Meshe, offsety, rotxje , etc */
  Frame *pFrameTab;
  int   mFrameCount;
  float mDuration;
  float mRotation;
  CVector3 mOffset;

  CVector3 mBallOffset;
public:
  Animation();
  ~Animation();
  void Init(const char *dat_name);
  bool Load();
  bool Cmp(const char *name);
  bool IsLoaded(void) {return this->is_loaded;};
  float GetDuration() {return mDuration;}
  float GetHitDuration() {return this->pFrameTab[mFrameCount-1].start_time;};
  Frame *GetFrameByTime(float time);
  Frame *GetFollowingFrameByTime(float time);
  Frame *GetFirstFrame();
  CVector3 *GetOffset() {return &mOffset;};
  CVector3 GetBallOffset() { return this->pFrameTab[mFrameCount-1].total_offset + mBallOffset;}
  void ScaleDelays(float f);
  void ScaleOffsets(float f);
  void ScaleRotations(float f);
  int GetFrameCount(void) {return this->mFrameCount;};
  Frame *GetFrameByIndex(int index) {return ((this->pFrameTab && (index < this->mFrameCount)) ? &this->pFrameTab[index] : NULL );};
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\AnimationManager.cpp
#include "..\config.h"

#include <assert.h>

#include "..\Utility\Defines.h"
#include "..\utility\singleton.h"
#include "..\utility\VBmath.h"
#include "..\utility\Logger.h"

#include "animation.h"
#include "animationmanager.h"

/* Konstuktor */
AnimationManager::AnimationManager()
{
  this->Max_Animation_Count = 10;
  this->pAnimationsTab = (Animation **)calloc(this->Max_Animation_Count, sizeof(Animation *));
}; /* end of : Konstruktor */

/* Dekonstuktor: czysci pamieæ */
AnimationManager::~AnimationManager()
{
  HAnimation hd = 0;
  while(this->HasAnimation(hd))
  {
    delete this->pAnimationsTab[hd];
    this->pAnimationsTab[hd++] = NULL;
  }
  free(this->pAnimationsTab);
} /* end of : DeKonstruktor */

/*
 * Pobranie (nowego) handlera do Animacji o podanej nazwie
 * 
 * Jesli nie posiadamy jeszcze danej sekwencji to nowy element jest dodawany do tablicy
 * Animacji (ale nie laduje go)
 */
HAnimation AnimationManager::GetAnimationHandler(const char *name)
{
  HAnimation hd = 0;

  /* szuka istniej¹cej animacji w tablicy */
  while(this->HasAnimation(hd))
  {
    if(this->pAnimationsTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  /*
   * Sprawdza czy nie przekroczylismy dopuszczalnej wielkosci tablicy
   * Jesli tak to realocujemy cala tablice po czym czyscimy nowe ellementy.
   */
  if(hd >= this->Max_Animation_Count)
  {
    unsigned int i = this->Max_Animation_Count;
    this->Max_Animation_Count += this->Max_Animation_Count / 2;
    this->pAnimationsTab = (Animation **)realloc(pAnimationsTab,
                                        this->Max_Animation_Count * sizeof(Animation *));
    /* czusci nowe elementy */
    while(i < this->Max_Animation_Count)
    {
      pAnimationsTab[i++] = NULL;
    }
  }

  /* dodanie nowego elementu do tablicy */
  this->pAnimationsTab[hd] = new Animation();
  this->pAnimationsTab[hd]->Init(name);
  return hd;
}/* end of : GetAnimationHandler */

/*
 * Pobranie (nowego) handlera do Animacji o podanej nazwie
 * 
 * Jesli nie posiadamy jeszcze danej sekwencji to nowy element jest dodawany do tablicy
 * Animacji.
 *
 * Nastepnie sprawdzany jest stan zaladowania (autoload)
 */
HAnimation AnimationManager::GetAnimationHandlerLoad(const char *name)
{
  HAnimation hd = GetAnimationHandler(name);
  if ( !this->pAnimationsTab[hd]->Load() )
  {
    LogCritical("Cant load animation dat : %s", name);
  }
  return hd;
} /* end of : GetAnimationHandlerLoad */

/*
 * Zwraca czas trfania animacji
 */
float AnimationManager::GetDuration(HAnimation hd)
{
  return this->pAnimationsTab[hd]->GetDuration();
}

/*
 * Zwraca czas trfania animacji do momentu udezenia w pilke (dla odbic)
 */
float AnimationManager::GetHitDuration(HAnimation hd)
{
  return this->pAnimationsTab[hd]->GetHitDuration();
}

/*
 * Zwraca pierwsza klatke której czas rozpoczecia jest mniejszy od podanego czasu
 */
Frame *AnimationManager::GetFrameByTime(HAnimation hd, float time)
{
  return this->pAnimationsTab[hd]->GetFrameByTime(time);
}

/*
 * Zwraca pierwsza klatke której czas rozpoczecia jest wiekszy od podanego czasu
 */
Frame *AnimationManager::GetFollowingFrameByTime(HAnimation hd, float time)
{
  return this->pAnimationsTab[hd]->GetFollowingFrameByTime(time);
}

/*
 * Zwraca pierwsza klatke animacji
 */
Frame *AnimationManager::GetFirstFrame(HAnimation hd)
{
  return this->pAnimationsTab[hd]->GetFirstFrame();
}

/*
 * Zwraca przesuniecie zawodnika w czasi caletej sekwencji animacji
 */
CVector3 * AnimationManager::GetOffset(HAnimation hd)
{
  return this->pAnimationsTab[hd]->GetOffset();
}

/*
 * Zwraca pozycjie odbicia pili w tej sekwencji.
 */
CVector3 AnimationManager::GetBallOffset(HAnimation hd)
{
  return this->pAnimationsTab[hd]->GetBallOffset();
}
E:\Project\Kopia (5) VBEngine\Graphics\animationmanager.h
#ifndef _ANIMATIONMANAGER_H
#define _ANIMATIONMANAGER_H

/*
class       : AnimationManager
description : Zazadza sekwencjiami animacji poprzez tablice wskazników na classe Animation.
              Twozy tablice wskazników na animacjie i stopniowo zapełnia pola wraz z dodawaniem nowych
              elementów. Jesli ilosc ellemntów przekroczy "Max_Animation_Count" do powiękrzamy
              rozmiar tablicy o 50%.
methods     :
              AnimationManager()      - konstruktor
	            ~AnimationManager(void) - destruktor
              GetAnimationHandler(...) - Szuka wpisu w tablicy i jesli nie znajdzie to
                                       allokuje nowa Animation w tablicy (jesli jest miesce) lub
                                       najpierw powieksza tablice
              GetAnimationHandlerLoad(...) - to samo tylko wymusza zaladowanie sekwencji
              GetAnimation(name)        - pobranie Animation z podanej nazwy (moze zwrucic NULL)
              GetAnimation(hd)        - pobranie Animation z podanego handlera (moze zwrucic NULL)

              GetDuration() - zwraca czas trfania animacji
              GetHitDuration() - zwraca czas trfania animacji do momentu udezenia w pilke (dla odbic)
              GetFrameByTime(...) - zwraca pierwsza klatke której czas rozpoczecia jest mniejszy od podanego czasu
              GetFollowingFrameByTime(...) - zwraca pierwsza klatke której czas rozpoczecia jest wiekszy od podanego czasu
              GetFirstFrame() - zwraca pierwsza klatke animacji
              GetOffset()     - zwraca przesuniecie zawodnik w czasi etej sekwencji animacji
              GetBallOffset() - zwraca pozycjie odbicia pili w tej sekwencji.

*/


class Animation;
struct Frame;

class AnimationManager : public Singleton<AnimationManager>
{
  Animation  **pAnimationsTab;              /* tablica animacji */
  unsigned int  Max_Animation_Count;      /* rozmiar tablicy (wraz z pustymi polami) */
public:
  AnimationManager();
 ~AnimationManager();

 Animation *GetAnimation(const char *dat_name) { return this->GetAnimation(this->GetAnimationHandlerLoad(dat_name)); };
 Animation *GetAnimation(HAnimation hd) {return this->pAnimationsTab[hd];};
 HAnimation GetAnimationHandler(const char *dat_name);
 HAnimation GetAnimationHandlerLoad(const char *name);
 bool HasAnimation(HAnimation hd) {return (hd < Max_Animation_Count && this->pAnimationsTab[hd]);};

 float GetDuration(HAnimation hd);
 Frame *GetFrameByTime(HAnimation hd, float time);
 Frame *GetFollowingFrameByTime(HAnimation hd, float time);
 Frame *GetFirstFrame(HAnimation hd);
 CVector3 *GetOffset(HAnimation hd);
 CVector3 GetBallOffset(HAnimation hd);
 float GetHitDuration(HAnimation hd);
};


#endif
E:\Project\Kopia (5) VBEngine\Graphics\BmpFont.cpp
#include "..\config.h"

#include "..\utility\VBmath.h"

#include <windows.h>
#include <d3d9.h>
#include <d3dx9effect.h>

#include <assert.h>
#include <string.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"

#include "..\Utility\Singleton.h"
#include "..\FileSystem\FileSystem.h"
#include "..\Utility\logger.h"
#include "MeshManager.h"
#include "Texture.h"

#include "bmpfont.h"

CBmpFont::CBmpFont(void)
{		
	g_pVertexBuffer = NULL;
	_bias = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	_material.Diffuse.b = _material.Diffuse.g = 1.0f;
	_material.Ambient.b = _material.Ambient.g = 1.0f;
	_material.Power = 20.0f;
  memset(this->_charinfo, 0, sizeof(this->_charinfo));
  this->mTexture = 0;
}

CBmpFont::~CBmpFont(void)
{	
	if( g_pVertexBuffer != NULL ) 
  {
    g_pVertexBuffer->Release(); 
    g_pVertexBuffer = NULL; 
  }
}

void CBmpFont::Init(LPDIRECT3DDEVICE9 m_device)
{ 
  FontVertex g_quadVertices[4];
  FontVertex *pVertices;
	

	this->_device = m_device;

#if 0	
	g_quadVertices[0].position = D3DXVECTOR3( 0.0, 0.5f, 0.0f );	
	g_quadVertices[0].tu = 0.0f; 
	g_quadVertices[0].tv = 0.0f;

	g_quadVertices[1].position = D3DXVECTOR3( 1.0, 0.5f, 0.0f );	
	g_quadVertices[1].tu = 1.0f; 
	g_quadVertices[1].tv = 0.0f;

	g_quadVertices[2].position = D3DXVECTOR3( 0.0, -0.5f, 0.0f );	
	g_quadVertices[2].tu = 0.0f; 
	g_quadVertices[2].tv = 1.0f;

	g_quadVertices[3].position = D3DXVECTOR3( 1.0, -0.5f, 0.0f );	
	g_quadVertices[3].tu = 1.0f; 
	g_quadVertices[3].tv = 1.0f;
#else
  g_quadVertices[0].position = D3DXVECTOR3( 0.0, 16.0f, 0.0f );	
	g_quadVertices[0].tu = 0.0f; 
	g_quadVertices[0].tv = 0.0f;

	g_quadVertices[1].position = D3DXVECTOR3( 32.0, 16.f, 0.0f );	
	g_quadVertices[1].tu = 1.0f; 
	g_quadVertices[1].tv = 0.0f;

	g_quadVertices[2].position = D3DXVECTOR3( 0.0, -16.0f, 0.0f );	
	g_quadVertices[2].tu = 0.0f; 
	g_quadVertices[2].tv = 1.0f;

	g_quadVertices[3].position = D3DXVECTOR3( 32.0, -16.0f, 0.0f );	
	g_quadVertices[3].tu = 1.0f; 
	g_quadVertices[3].tv = 1.0f;
#endif	
	m_device->CreateVertexBuffer( sizeof(g_quadVertices), 0, D3DFVF_FONTVERTEX, D3DPOOL_MANAGED, &g_pVertexBuffer, NULL );
	
	g_pVertexBuffer->Lock( 0, sizeof(g_quadVertices), (void**)&pVertices, 0 );
    memcpy( pVertices, g_quadVertices, sizeof(g_quadVertices) );
  g_pVertexBuffer->Unlock();
}

void CBmpFont::LoadFont(char *name)
{
//  HRESULT hr;
	char path[256];
  
  my_snprintf(path, 256, "%s.png", name);
	
  mTexture = CMeshManager::Instance()->GetTextureHandlerLoad(path);
  CMeshManager::Instance()->SetTextureClinable(mTexture, false);
  
		
	my_snprintf(path, 256, "%s%s.dat", DataPath, name);

	FILE *plik;
	plik = fopen(path, "rb");
	if (plik)
  {
		fread(_charinfo, 256, sizeof(BYTE), plik);
		fclose(plik);
	}else
  {
    void *data = FileSystem::Instance()->LoadFile(path);
    if (data)
    {
      memcpy(_charinfo, data,256);
    }
  }
}

void CBmpFont::ShowLetter(float x, float y,unsigned char letter)
{
  FontVertex* pVertices;
	int width = ((int)letter)%16;
	int height = (int)(((float)letter)/16.0f);
  float tt = (1.0f/16.0f);

  	
	g_pVertexBuffer->Lock(0, 4 * sizeof(FontVertex),  (void**)&pVertices, 0 );	

	pVertices[0].tu = tt * width;
	pVertices[0].tv = tt * height;

	pVertices[1].tu = tt * (width+1);
	pVertices[1].tv = tt * height;

	pVertices[2].tu = tt * width;
	pVertices[2].tv = tt * (height+1);

	pVertices[3].tu = tt * (width+1);
	pVertices[3].tv = tt * (height+1);
	
	g_pVertexBuffer->Unlock();
		
	D3DXMATRIX world;	
	if (first)
	{
		D3DXMatrixTransformation(&world, NULL, NULL, &_scale, NULL, NULL, &D3DXVECTOR3(_bias.x,_bias.y,_bias.z));
		_bias.x+=(x/2);
	}
	else
	{
		D3DXMatrixTransformation(&world, NULL, NULL, &_scale, NULL, NULL, &D3DXVECTOR3(_bias.x+(x/2),_bias.y,_bias.z));
		_bias.x+=x;
	}

  HRESULT hr;
	hr = _device->SetTransform(D3DTS_WORLD, &world);	
	hr = _device->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	hr = _device->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);
	hr = _device->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_LINEAR );
    //_device->SetSamplerState( 0, D3DSAMP_ADDRESSU,  D3DTADDRESS_CLAMP );
    //_device->SetSamplerState( 0, D3DSAMP_ADDRESSV,  D3DTADDRESS_CLAMP );
	hr = _device->SetRenderState( D3DRS_DITHERENABLE, TRUE );
  CTexture *tex = CMeshManager::Instance()->GetTexture(mTexture);
	hr = _device->SetTexture(0, tex->GetDXTexture());
	hr = _device->SetStreamSource( 0, g_pVertexBuffer, 0, sizeof(FontVertex) );
	hr = _device->SetFVF( D3DFVF_FONTVERTEX );
	hr = _device->DrawPrimitive( D3DPT_TRIANGLESTRIP, 0, 2 );			
}

void CBmpFont::StrSize(char *text, float scale, float *width, float *height)
{
  if (width)
  {
    int length = strlen(text);
    float temp = 0.0f;
    for (int t=0; t<length; t++)
		{
			temp += (((float)(_charinfo[(unsigned char)(text[t])])) * scale);
		}
    *width = temp;
  }
  if (height)
  {
    *height = 32.0f * scale;
  }
}

void CBmpFont::Print(CVector3 *pos, CVector3 *scale, align_type how, char *text)
{	
  D3DXVECTOR3 position(pos->x, pos->y, pos->z);
  float temp = 0.0f;
//  float div = 32.0f/scale;
	//float div = scale;

	this->_bias = position;
	this->_scale.x = scale->x;		
  this->_scale.y = scale->y;		
  this->_scale.z = scale->z;		

	int length = strlen(text);	
  if (how == ALIGN_CENTER || how == ALIGN_RIGHT)
  {
    StrSize(text, scale->x, &temp, NULL);
	if (how == ALIGN_CENTER)
	{
		_bias.x-=(temp/2);
	}
    else
    {  
	if (how == ALIGN_RIGHT)
	{
        _bias.x-=temp;
      }
		}
	}
  _device->SetRenderState(D3DRS_LIGHTING, FALSE);
  _device->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
  _device->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
  _device->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
  _device->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
  _device->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

	first = true;
	for (int t=0; t<length; t++)
	{		
		//float tt = ((float)(_charinfo[(unsigned char)(text[t])])) / div;
    float tt = ((float)(_charinfo[(unsigned char)(text[t])])) * scale->x;
		ShowLetter(tt, 0, (unsigned char)text[t]);
		first = false;
	}
		
	this->_bias = D3DXVECTOR3(0.0f, 0.0f, 0.0f);
	//_device->SetRenderState( D3DRS_ALPHATESTENABLE, FALSE );
}
E:\Project\Kopia (5) VBEngine\Graphics\BmpFont.h
#ifndef CBMPFONT_H
#define CBMPFONT_H



struct FontVertex
{
  D3DXVECTOR3 position;	
	FLOAT tu, tv;	
};

#define D3DFVF_FONTVERTEX (D3DFVF_XYZ | D3DFVF_TEX1)


class CBmpFont
{
	bool first;
  HTexture mTexture;
	LPDIRECT3DDEVICE9 _device;
  LPDIRECT3DVERTEXBUFFER9 g_pVertexBuffer;

	BYTE _charinfo[256];
		
	D3DXVECTOR3 _bias;
	D3DXVECTOR3 _scale;
	D3DMATERIAL9 _material;
	
  
public:
	CBmpFont(void);
	void Init(LPDIRECT3DDEVICE9 m_device);
	~CBmpFont(void);
	void LoadFont(char *name);
  void StrSize(char *text, float scale, float *width, float *height);
  void Print(CVector3 *pos, CVector3 *scale, align_type how, char *text);	
	void ShowLetter(float x, float y, unsigned char letter);
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\Camera.cpp
#include "..\utility\vbmath.h"
#include "..\config.h"
#include <crtdbg.h>
#include <assert.h>
#include <d3d9.h>
#include <dinput.h>

#include "..\utility\Misc.h"
#include "..\utility\Profile.h"
#include "..\utility\Singleton.h"
#include "..\graphics\renderer.h"

#include "Camera.h"
//#include "d3dSingl.h"
//#include "Object3d.h"

CCamera::CCamera()
{
	//POINT asp=sD3D::Instance().GetClipSize();
   
	this->m_fAspect=(float)Renderer::Instance()->GetScreenWidth()/(float)Renderer::Instance()->GetScreenHeight();
	this->m_StoredValues = false;
	CVector3 vEyePt(0, 16.2f, 6.0f);//10.0f, -10.0f, -10.0f);
  CVector3 vLookatPt(0.0f,0.0f,0.0f);
  CVector3 vUpVec(0.0f,1.0f,0.0f);
  SetViewParams( vEyePt, vLookatPt, vUpVec );

  SetProjParams( PI/4, this->m_fAspect, 100.0f, 500.0f );
	MoveSpeed=1.0f;
	StrafeSpeedRL=1.0f;
	StrafeSpeedUD=1.0f;

	Nach=PI;
	Przech=0.0f;
	Odch=0.0f;
	//NachRev=0.0f;
	//PrzechRev=0.0f;

	RotateNachSpeed=0.01f;
	RotatePrzechSpeed=0.01f;
	RotateOdchSpeed=0.01f;
	zoom = 1.065f;
	bylazmiana = true;
  currentCamera = 0;
}

void CCamera::Reset()
{
 	//POINT asp=sD3D::Instance().GetClipSize();

  this->m_fAspect=(float)Renderer::Instance()->GetScreenWidth()/(float)Renderer::Instance()->GetScreenHeight();

  
  //CVector3 vEyePt(0.0f, 3.0f, -5.0f);
  CVector3 vEyePt(0, 16.2f, 6.0f);//10.0f, -10.0f, 15.0f);
  CVector3 vLookatPt(0.0f, 0.0f, 0.0f);
  CVector3 vUpVec(0.0f, 0.0f, 1.0f);
  SetViewParams( vEyePt, vLookatPt, vUpVec );
  SetProjParams( PI/4, this->m_fAspect, 0.1f, 1000.0f );

/*
    CVector3 vEyePt(0.0f, 3.0f, -5.0f);
    CVector3 vLookatPt(0.0f, 0.0f, 0.0f);
    CVector3 vUpVec(0.0f, 0.0f, 1.0f);
    SetViewParams( vEyePt, vLookatPt, vUpVec );
    SetProjParams( PI/4, this->m_fAspect, 0.1f, 100.0f );
*/

	Nach=PI;
	Przech=0.0f;
	Odch=0.0f;
	zoom = 1.098f;
//	NachRev=0.0f;
//	PrzechRev=0.0f;
  this->m_matViewProj = this->m_matView * this->m_matProj;
	this->bylazmiana=true;
};

void CCamera::SetViewParams( CVector3 &vEyePt, CVector3& vLookatPt,
                                CVector3& vUpVec )
{
/*
D3DXVECTOR3 vEyePt( 0.0f, 3.0f,-5.0f );
  D3DXVECTOR3 vLookatPt( 0.0f, 0.0f, 0.0f );
  D3DXVECTOR3 vUpVec( 0.0f, 0.0f, 1.0f );
  D3DXMatrixLookAtRH( &matView, &vEyePt, &vLookatPt, &vUpVec );

*/


    m_vEyePt    = vEyePt;
    m_vLookatPt = vLookatPt;
    m_vUpVec    = vUpVec;
	  this->m_realEyePt = vEyePt;

    CVector3 vDir = m_vLookatPt - m_vEyePt;
    Vector3Normalize(m_vView, vDir );
    Vector3Cross( m_vCross, m_vView, m_vUpVec );

    /*  TODO:
    CMatrix4LookAtRH( &m_matView, &m_vEyePt, &m_vLookatPt, &m_vUpVec );
    */
    m_matView.SetCameraLookAtRH(&m_vEyePt, &m_vLookatPt, &m_vUpVec);
    Matrix4Invert( m_matBillboard, m_matView );
        
    m_matBillboard._41 = 0.0f;
    m_matBillboard._42 = 0.0f;
    m_matBillboard._43 = 0.0f;
    this->bylazmiana = true;
}

void CCamera::SetProjParams( float fFOV, float fAspect, float fNearPlane,
                                float fFarPlane )
{
    m_fFOV        = fFOV;
    m_fAspect     = fAspect;
    m_fNearPlane  = fNearPlane;
    m_fFarPlane   = fFarPlane;	

    /* TODO:
    CMatrix4PerspectiveFovRH( &m_matProj, fFOV, fAspect, fNearPlane, fFarPlane );
    */
     m_matProj.SetPerspectiveFovRH(fFOV, fAspect, fNearPlane, fFarPlane);
}

void CCamera::SetLinearSpeeds(float m,float srl,float sud)
{
	this->MoveSpeed=m;
	this->StrafeSpeedRL=srl;
	this->StrafeSpeedUD=sud;
};

void CCamera::SetRotateSpeeds(float n,float p,float o)
{
	this->RotateNachSpeed=n;
	this->RotatePrzechSpeed=p;
	this->RotateOdchSpeed=o;
};

int CCamera::Init()
{	
	this->Reset();
	return 1;
};

int CCamera::DeInit()
{
	return 1;
};

void CCamera::policzxy()
{
	CVector3 kierunek;
	CVector3 oz(0.0f,0.0f,1.0f);
	float s;
	this->kierunek2dy = this->m_vUpVec;
	kierunek=this->m_vEyePt-this->m_vLookatPt;
	
  Vector3Cross(this->kierunek2dx,this->m_vUpVec,kierunek);
  	
  s=this->kierunek2dx.Length();
	this->kierunek2dx/=s;
	this->kierunekx=this->kierunek2dx;
	this->kierunekx.z=0.0f;
	s=this->kierunekx.Length();
	this->kierunekx/=s;
	Vector3Cross(this->kieruneky,oz,this->kierunekx);
	
};

void CCamera::Update()
{
  PROFILE(Camera_Update);
	if(this->bylazmiana)
	{
		this->policzxy();
		this->SetViewParams(this->m_vEyePt,this->m_vLookatPt,this->m_vUpVec);
		this->SetProjParams(this->m_fFOV,this->m_fAspect,this->m_fNearPlane,this->m_fFarPlane);

		//dev->SetTransform(D3DTS_PROJECTION,(D3DXMATRIX*)&this->m_matProj);
		//dev->SetTransform(D3DTS_VIEW,(D3DXMATRIX*)&this->m_matView);
/*
		CVector3 kierunek = this->GetLookatPt() - this->GetEyePt();
		CVector3 up = this->GetUpVec();
		CVector3 pos = this->GetEyePt();
		D3DXVec3Normalize(&kierunek, &kierunek);		
		Object3D::smp->SetListenOrientation(kierunek.x, kierunek.y, kierunek.z, up.x, up.y, up.z);
		Object3D::smp->SetListenPosition(pos.x, pos.y, pos.z);		
*/
    this->m_matViewProj = this->m_matView * this->m_matProj;
		this->bylazmiana=false;
	}
};

void CCamera::Move(float jak)// 1,-1
{
	CVector3 kierunek;
	kierunek=this->m_vEyePt-this->m_vLookatPt;
  kierunek.Normalize();	
	this->m_vEyePt+=(jak*kierunek*this->MoveSpeed);
	this->m_vLookatPt+=(jak*kierunek*this->MoveSpeed);
	bylazmiana=true;
};

void CCamera::StrafeRL(float jak)// 1,-1
{
	CVector3 kierunek, kierunek_copy;
	kierunek=this->m_vEyePt-this->m_vLookatPt;

  Vector3Cross( kierunek_copy, kierunek, this->m_vUpVec );
	kierunek_copy.Normalize();
	this->m_vEyePt+=(jak*kierunek_copy*this->StrafeSpeedUD);
	this->m_vLookatPt+=(jak*kierunek_copy*this->StrafeSpeedUD);
	bylazmiana=true;
};

void CCamera::StrafeUD(float jak)// 1,-1
{
	CVector3 kierunek;
	
  Vector3Normalize(kierunek,this->m_vUpVec);
	this->m_vEyePt+=(jak*kierunek*this->StrafeSpeedUD);
	this->m_vLookatPt+=(jak*kierunek*this->StrafeSpeedUD);
	bylazmiana=true;
};

void CCamera::Policz()
{
	CVector3 kierunek;
	kierunek=this->m_vEyePt-this->m_vLookatPt;
	float dl;
	dl=kierunek.Length();

	float cosY,cosP,cosR;
	float sinY,sinP,sinR;

	cosY=cosf(Nach); 
	cosP=cosf(Przech);
	cosR=cosf(Odch);
	sinY=sinf(Nach);
	sinP=sinf(Przech);
	sinR=sinf(Odch);

	CVector3 at(sinY*cosP,sinP,cosP*-cosY);
	at*=dl;
	this->m_vLookatPt=this->m_vEyePt-at;
	CVector3 norm(-cosY*sinR-sinY*sinP*cosR,cosP*cosR,-sinY*sinR-sinP*cosR*-cosY);
	this->m_vUpVec=norm;
};   

void CCamera::PoliczRev()
{
	CVector3 kierunek,pom;
	kierunek=this->m_vEyePt-this->m_vLookatPt;
	float dl;
	dl=kierunek.Length();

	float cosY,cosP,cosR;
	float sinY,sinP,sinR;

	cosY=cosf(Nach); 
	cosP=cosf(Przech);
	cosR=cosf(Odch);
	sinY=sinf(Nach);
	sinP=sinf(Przech);
	sinR=sinf(Odch);

	CVector3 at(sinY*cosP,sinP,cosP*-cosY);
	at*=dl;
	pom=at-kierunek;
	this->m_vEyePt+=pom;
	CVector3 norm(-cosY*sinR-sinY*sinP*cosR,cosP*cosR,-sinY*sinR-sinP*cosR*-cosY);
	this->m_vUpVec=norm;
};   

void CCamera::RotateNach(float jak)// 1,-1 
{
	this->Nach+=this->RotateNachSpeed*jak;
	this->Policz();
	this->bylazmiana=true;
};

void CCamera::RotatePrzech(float jak)// 1,-1
{
	this->Przech+=this->RotatePrzechSpeed*jak;
	this->Policz();
	this->bylazmiana=true;
};

void CCamera::RotateOdch(float jak)// 1,-1
{
	this->Odch+=this->RotateOdchSpeed*jak;
	this->Policz();
	this->bylazmiana=true;
};

void CCamera::RotateNachRev(float jak)// 1,-1 
{
	this->Nach-=this->RotateNachSpeed*jak;
	this->PoliczRev();
	this->bylazmiana=true;
};

void CCamera::RotatePrzechRev(float jak)// 1,-1
{
	this->Przech-=this->RotatePrzechSpeed*jak;
	this->PoliczRev();
	this->bylazmiana=true;
};

void CCamera::ChangeCamera(int num)
{
  currentCamera = num;
  switch(num)
  {
    case 0:	  
      this->m_vEyePt = CVector3(0, 17.2f, 8.0f);
      this->m_vLookatPt = CVector3(0.0f,0.0f,0.0f);
      this->zoom = 1.065f;
	  break;
    case 1:
      this->m_vEyePt = CVector3(0, -17.2f, 8.0f);
      this->m_vLookatPt = CVector3(0.0f,0.0f,0.0f);
      this->zoom = 1.065f;
    break;
    case 2:
      this->m_vEyePt = CVector3(17.2f, 0, 8.0f);
      this->m_vLookatPt = CVector3(0.0f,0.0f,0.0f);
      this->zoom = 1.065f;
    break;
    case 3:
      this->m_vEyePt = CVector3(-17.2f, 0, 8.0f);
      this->m_vLookatPt = CVector3(0.0f,0.0f,0.0f);
      this->zoom = 1.065f;
    break;
    default:
    break;
  }
	bylazmiana = true;
}

void CCamera::AxisRotation(CVector3 axis, CVector3 point, float angle)
{
	CMatrix4 matrix;
	Quaternion q;
	CVector3 eye, lookat, upvec, temp;

  if (angle != 0.0f)
  {
    q.RotationAxis(&axis, angle);
    q.ConvertToRotationMatrix(&matrix);
  }
  else
  {
    matrix.SetIdentity();
  }

	//eye = m_vEyePt - point;
	eye = this->m_realEyePt - point;
	lookat = m_vLookatPt - point;		
	
	float a = 17.2f*zoom;
	float b = 17.2f*zoom;
	float c = 22.0f*zoom;

  matrix.TransformVector3(&upvec, &m_vUpVec);
  //Vector3TransformCoord(upvec, matrix, m_vUpVec);

	if (upvec.z > 0.09f)
	{		
		//m_vUpVec = upvec;
		//D3DXVec3Normalize(&m_vUpVec, &m_vUpVec);
		CVector3 last = eye;

    matrix.TransformVector3(&eye);
    				
		float xx = (eye.x * eye.x)/(a * a);
		float yy = (eye.y * eye.y)/(b * b);
		float zz = ((eye.z - c) * (eye.z - c))/(c * c);
		

    matrix.TransformVector3(&m_vLookatPt, &lookat);
		
		if (eye.z<6.0f*zoom) eye.z = 6.0f*zoom;		
		if (eye.z>19.0f*zoom) eye.z = 19.0f*zoom;
		this->m_realEyePt = eye;
					
		temp = eye;
    temp.Normalize();
		
		float aa = a * a;
		float bb = b * b;
		float cc = c * c;
		float v1 = (temp.x * temp.x)/aa;
		float v2 = (temp.y * temp.y)/bb;
		float v3 = (temp.z * temp.z)/cc;
		float t = sqrtf(1 / (v1+v2+v3));
		CVector3 v_1 = CVector3(temp.x*t, temp.y*t, temp.z*t);
		CVector3 v_2 = CVector3(-temp.x*t, -temp.y*t, -temp.z*t);						
		CVector3 v1e = v_1 - eye;
		CVector3 v2e = v_2 - eye;
		float t1 = v1e.Length();
		float t2 = v2e.Length();
		if (t1<t2)
		{
			m_vEyePt = CVector3(v_1.x, v_1.y, v_1.z);
		} else {
			m_vEyePt = CVector3(v_2.x, v_2.y, v_2.z);
		}	
	}	
	
	m_vEyePt += point;	
	m_vLookatPt = CVector3(0,0,0);
	this->policzxy();

	bylazmiana=true;
}

void CCamera::AxisRotation(CVector3 axis, float angle)
{
	CMatrix4 matrix;		
  Quaternion q;  
  q.RotationAxis(&axis,angle);
	//D3DXMatrixRotationQuaternion(&matrix, &q);  
  q.ConvertToRotationMatrix(&matrix);

  matrix.TransformVector3(&m_vEyePt);
  matrix.TransformVector3(&m_vLookatPt);
  matrix.TransformVector3(&m_vUpVec);

	bylazmiana=true;
}

  
    
 
void CCamera::SaveViewSettings()
{
 if (this->m_StoredValues) return;
 this->m_StoredEyePoint = this->m_vEyePt;
 this->m_StoredLookAtPoint = this->m_vLookatPt;
 this->m_StoredUpVector = this->m_vUpVec;
 this->m_StoredValues = true;
}



void CCamera::RestoreViewSettings()
{
 if (!this->m_StoredValues) return;
 this->SetViewParams(this->m_StoredEyePoint,this->m_StoredLookAtPoint, this->m_StoredUpVector);   
 this->m_StoredValues = false;
}
E:\Project\Kopia (5) VBEngine\Graphics\Camera.h
#ifndef CCamera_H
#define CCamera_H


//#include "d3dSingl.h"
//#include "Object3d.h"



class CCamera
{
public:
  	CCamera();

  int currentCamera;
	float zoom;
	  CVector3 m_realEyePt;
    CVector3 m_vEyePt;    // eye
    CVector3 m_vLookatPt;	// lookpoint
    CVector3 m_vUpVec;		// normal

    //wartosci zachowywane przy move camera in zagrywka
    CVector3 m_StoredEyePoint;
    CVector3 m_StoredLookAtPoint;
    CVector3 m_StoredUpVector;
    bool m_StoredValues;

    CVector3 m_vView;		
    CVector3 m_vCross;

    CMatrix4  m_matView;
    CMatrix4  m_matBillboard; // Special matrix for billboarding effects

    float       m_fFOV;         // Attributes for projection matrix
    float       m_fAspect;
    float       m_fNearPlane;
    float       m_fFarPlane;
    CMatrix4  m_matProj;

  CMatrix4  m_matViewProj;
	float MoveSpeed;
	float StrafeSpeedRL;
	float StrafeSpeedUD;
	
	float Nach;
	float Przech;
	float Odch;
	float RotateNachSpeed;
	float RotatePrzechSpeed;
	float RotateOdchSpeed;

	void policzxy();
	bool bylazmiana; // must be guard by semaphore because it is used in render to refresch view from matrix 
					 // and in gamepaly to set matrix from input messages, its like semaphore to variables of this class
	CVector3 kieruneky,kierunekx,kierunek2dx,kierunek2dy;
    // Access functions
    CVector3 GetEyePt()           { return m_vEyePt; }
    CVector3 GetLookatPt()        { return m_vLookatPt; }
    CVector3 GetUpVec()           { return m_vUpVec; }
    CVector3 GetViewDir()         { return m_vView; }
    CVector3 GetCross()           { return m_vCross; }
	float GetMoveSpeed()			 { return MoveSpeed;}
	float GetStrafeSpeedRL()		 { return StrafeSpeedRL;}
	float GetStrafeSpeedUD()		 { return StrafeSpeedUD;}
	float GetNach()					 { return Nach;}
	float GetPrzech()				 { return Przech;}
	float GetOdch()					 { return Odch;}
	float GetRotateNachSpeed()		 { return RotateNachSpeed;}
	float GetRotatePrzechSpeed()	 { return RotatePrzechSpeed;}
	float GetRotateOdchSpeed()		 { return RotateOdchSpeed;}

	// "-//-"="1,-1 move 'left' or 'right' .... if not 1,-1 to set speed of move, 
	// do not fals with calibrate it is in 'speeds' variables in this class", call in gamepay
	void Move(float); // -//- cam foreward backword
	void StrafeRL(float); // -//- strafe right and left
	void StrafeUD(float); // -//- strafe up and down
	void RotateNach(float);// -//- yaw or pich i dont now which it is rotate over eyepoint
	void RotatePrzech(float);// -//- yaw or pich i dont now which it is rotate over eyepoint
	void RotateOdch(float);// -//- roll
	void RotateNachRev(float);// -//- yaw or pich i dont now which it is rotate over lookpoint
	void RotatePrzechRev(float);//// -//- yaw or pich i dont now which it is rotate over lookpoint


    float       GetFOV()             { return m_fFOV; }
    float       GetAspect()          { return m_fAspect; }
    float       GetNearPlane()       { return m_fNearPlane; }
    float       GetFarPlane()        { return m_fFarPlane; }

    CMatrix4  *GetViewMatrix()      { return &m_matView; }
    CMatrix4  GetBillboardMatrix()  { return m_matBillboard; }
    CMatrix4  *GetProjMatrix()      { return &m_matProj; }
   
    CMatrix4  *GetViewProjMatrix()  { return &m_matViewProj;}
	int Init();
	int DeInit();
	void Update();

    void SetViewParams( CVector3 &vEyePt, CVector3& vLookatPt,CVector3& vUpVec ); // sets view call in render
    void SetProjParams( float fFOV, float fAspect, float fNearPlane,float fFarPlane ); // sets projection call in render
	void SetLinearSpeeds(float m,float srl,float sud); // sets speeds gues witch :P
	void SetRotateSpeeds(float n,float p,float o); // sets speeds gues witch :P

	// here are used sin and cos i think we must table of sin create to speed, whatever.
	void Policz();	// used by rotate eye function 
	void PoliczRev(); // used by rotate look function    
	void Reset(); // simpe to reset Camera to defined views


	void AxisRotation(CVector3 axis, float angle);
  
  // uncomment fo VBEngine
	//void AxisRotation(CVector3 axis, CVector3 point, float angle); 
  void AxisRotation(CVector3 axis, CVector3 point, float angle);

	void ChangeCamera(int num);
  int GetCurrentCamera() { return this->currentCamera; }
  void SaveViewSettings();
  void RestoreViewSettings();
	
};




#endif 
E:\Project\Kopia (5) VBEngine\Graphics\Debuging\d3dfont.cpp
//-----------------------------------------------------------------------------
// File: D3DFont.cpp
//
// Desc: Texture-based font class
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <stdio.h>
#include <tchar.h>
#include <D3DX9.h>
#include "D3DFont.h"
//#include "D3DUtil.h"
//#include "DXUtil.h"
//#include "..\\AutoLog\\SafeOps.h"


#define safe_release(x) if(x) {x->Release(); x = NULL;}

//-----------------------------------------------------------------------------
// Custom vertex types for rendering text
//-----------------------------------------------------------------------------
#define MAX_NUM_VERTICES 50*6

struct FONT2DVERTEX { D3DXVECTOR4 p;   DWORD color;     FLOAT tu, tv; };
struct FONT3DVERTEX { D3DXVECTOR3 p;   D3DXVECTOR3 n;   FLOAT tu, tv; };

#define D3DFVF_FONT2DVERTEX (D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1)
#define D3DFVF_FONT3DVERTEX (D3DFVF_XYZ|D3DFVF_NORMAL|D3DFVF_TEX1)

inline FONT2DVERTEX InitFont2DVertex( const D3DXVECTOR4& p, D3DCOLOR color,
                                      FLOAT tu, FLOAT tv )
{
    FONT2DVERTEX v;   v.p = p;   v.color = color;   v.tu = tu;   v.tv = tv;
    return v;
}

inline FONT3DVERTEX InitFont3DVertex( const D3DXVECTOR3& p, const D3DXVECTOR3& n,
                                      FLOAT tu, FLOAT tv )
{
    FONT3DVERTEX v;   v.p = p;   v.n = n;   v.tu = tu;   v.tv = tv;
    return v;
}




//-----------------------------------------------------------------------------
// Name: CD3DFont()
// Desc: Font class constructor
//-----------------------------------------------------------------------------
CD3DFont::CD3DFont( const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags )
{
    _tcsncpy( m_strFontName, strFontName, sizeof(m_strFontName) / sizeof(TCHAR) );
    m_strFontName[sizeof(m_strFontName) / sizeof(TCHAR) - 1] = _T('\0');
    m_dwFontHeight         = dwHeight;
    m_dwFontFlags          = dwFlags;
    m_dwSpacing            = 0;

    m_pd3dDevice           = NULL;
    m_pTexture             = NULL;
    m_pVB                  = NULL;

    m_pStateBlockSaved     = 0;
    m_pStateBlockDrawText  = NULL;
}




//-----------------------------------------------------------------------------
// Name: ~CD3DFont()
// Desc: Font class destructor
//-----------------------------------------------------------------------------
CD3DFont::~CD3DFont()
{
    InvalidateDeviceObjects();
    DeleteDeviceObjects();
}




//-----------------------------------------------------------------------------
// Name: CreateGDIFont
// Desc: Create a font based on the current state of related member variables
//       and return the handle (or null on error)
//-----------------------------------------------------------------------------
HRESULT CD3DFont::CreateGDIFont( HDC hDC, HFONT* pFont )
{
    // Create a font.  By specifying ANTIALIASED_QUALITY, we might get an
    // antialiased font, but this is not guaranteed.
    INT nHeight    = -MulDiv( m_dwFontHeight, 
                              (INT)(GetDeviceCaps(hDC, LOGPIXELSY) * m_fTextScale), 
                              72 );
    DWORD dwBold   = (m_dwFontFlags & D3DFONT_BOLD)   ? FW_BOLD : FW_NORMAL;
    DWORD dwItalic = (m_dwFontFlags & D3DFONT_ITALIC) ? TRUE    : FALSE;
    *pFont         = CreateFont( nHeight, 0, 0, 0, dwBold, dwItalic,
                                 FALSE, FALSE, DEFAULT_CHARSET, OUT_DEFAULT_PRECIS,
                                 CLIP_DEFAULT_PRECIS, ANTIALIASED_QUALITY,
                                 VARIABLE_PITCH, m_strFontName );

    if( *pFont == NULL )
        return E_FAIL;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: PaintAlphabet
// Desc: Paint the printable characters for the given GDI font onto the
//       provided device context. If the bMeasureOnly flag is set, no drawing 
//       will occur.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::PaintAlphabet( HDC hDC, BOOL bMeasureOnly )
{
    SIZE size;
    TCHAR str[2] = _T("x"); // One-character, null-terminated string
    
    // Calculate the spacing between characters based on line height
    if( 0 == GetTextExtentPoint32( hDC, str, 1, &size ) )
        return E_FAIL;
    m_dwSpacing = (DWORD) ceil(size.cy * 0.3f);

    // Set the starting point for the drawing
    DWORD x = m_dwSpacing;
    DWORD y = 0;
    
    // For each character, draw text on the DC and advance the current position
    for( char c = 32; c < 127; c++ )
    {
        str[0] = c;
        if( 0 == GetTextExtentPoint32( hDC, str, 1, &size ) )
            return E_FAIL;

        if( (DWORD)(x + size.cx + m_dwSpacing) > m_dwTexWidth )
        {
            x  = m_dwSpacing;
            y += size.cy + 1;
        }

        // Check to see if there's room to write the character here
        if( y + size.cy > m_dwTexHeight )
            return D3DERR_MOREDATA;
           
        if( !bMeasureOnly )
        {
            // Perform the actual drawing
            if( 0 == ExtTextOut( hDC, x+0, y+0, ETO_OPAQUE, NULL, str, 1, NULL ) )
                return E_FAIL;

            m_fTexCoords[c-32][0] = ((FLOAT)(x + 0       - m_dwSpacing))/m_dwTexWidth;
            m_fTexCoords[c-32][1] = ((FLOAT)(y + 0       + 0          ))/m_dwTexHeight;
            m_fTexCoords[c-32][2] = ((FLOAT)(x + size.cx + m_dwSpacing))/m_dwTexWidth;
            m_fTexCoords[c-32][3] = ((FLOAT)(y + size.cy + 0          ))/m_dwTexHeight;
        }

        x += size.cx + (2 * m_dwSpacing);
    }

    return S_OK;
}





//-----------------------------------------------------------------------------
// Name: InitDeviceObjects()
// Desc: Initializes device-dependent objects, including the vertex buffer used
//       for rendering text and the texture map which stores the font image.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InitDeviceObjects( CComPtr<IDirect3DDevice9> pd3dDevice )
{
    HRESULT hr = S_OK;
    HFONT hFont = NULL;
    HFONT hFontOld = NULL;
    HDC hDC = NULL;
    HBITMAP hbmBitmap = NULL;
    HGDIOBJ hbmOld = NULL;

    // Keep a local copy of the device
    m_pd3dDevice = pd3dDevice;

    // Assume we will draw fonts into texture without scaling unless the
    // required texture size is found to be larger than the device max
    m_fTextScale  = 1.0f; 

    hDC = CreateCompatibleDC( NULL );
    SetMapMode( hDC, MM_TEXT );

    hr = CreateGDIFont( hDC, &hFont );
    if( FAILED(hr) )
        goto LCleanReturn;

    hFontOld = (HFONT) SelectObject( hDC, hFont );

    // Calculate the dimensions for the smallest power-of-two texture which
    // can hold all the printable characters
    m_dwTexWidth = m_dwTexHeight = 128;
    while( D3DERR_MOREDATA == ( hr = PaintAlphabet( hDC, true ) ) )
    {
        m_dwTexWidth *= 2;
        m_dwTexHeight *= 2;
    }

    if( FAILED(hr) )
        goto LCleanReturn;
    
    // If requested texture is too big, use a smaller texture and smaller font,
    // and scale up when rendering.
    D3DCAPS9 d3dCaps;
    m_pd3dDevice->GetDeviceCaps( &d3dCaps );

    if( m_dwTexWidth > d3dCaps.MaxTextureWidth )
    {
        m_fTextScale = (FLOAT)d3dCaps.MaxTextureWidth / (FLOAT)m_dwTexWidth;
        m_dwTexWidth = m_dwTexHeight = d3dCaps.MaxTextureWidth;
   
        bool bFirstRun = true; // Flag clear after first run

        do
        {
            // If we've already tried fitting the new text, the scale is still 
            // too large. Reduce and try again.
            if( !bFirstRun)
                m_fTextScale *= 0.9f;

            // The font has to be scaled to fit on the maximum texture size; our
            // current font is too big and needs to be recreated to scale.
            DeleteObject( SelectObject( hDC, hFontOld ) );

            hr = CreateGDIFont( hDC, &hFont );
            if( FAILED(hr) )
                goto LCleanReturn;

            hFontOld = (HFONT) SelectObject( hDC, hFont );

            bFirstRun = false;
        } 
        while( D3DERR_MOREDATA == ( hr = PaintAlphabet( hDC, true ) ) );
    }

    
    // Create a new texture for the font
    hr = m_pd3dDevice->CreateTexture( m_dwTexWidth, m_dwTexHeight, 1,
                                      0, D3DFMT_A4R4G4B4,
                                      D3DPOOL_MANAGED, &m_pTexture, NULL );
    if( FAILED(hr) )
        goto LCleanReturn;

    // Prepare to create a bitmap
    DWORD*      pBitmapBits;
    BITMAPINFO bmi;
    ZeroMemory( &bmi.bmiHeader, sizeof(BITMAPINFOHEADER) );
    bmi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       =  (int)m_dwTexWidth;
    bmi.bmiHeader.biHeight      = -(int)m_dwTexHeight;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biBitCount    = 32;

    // Create a bitmap for the font
    hbmBitmap = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS,
                                  (void**)&pBitmapBits, NULL, 0 );

    hbmOld = SelectObject( hDC, hbmBitmap );
    
    // Set text properties
    SetTextColor( hDC, RGB(255,255,255) );
    SetBkColor(   hDC, 0x00000000 );
    SetTextAlign( hDC, TA_TOP );

    // Paint the alphabet onto the selected bitmap
    hr = PaintAlphabet( hDC, false );
    if( FAILED(hr) )
        goto LCleanReturn;

    // Lock the surface and write the alpha values for the set pixels
    D3DLOCKED_RECT d3dlr;
    m_pTexture->LockRect( 0, &d3dlr, 0, 0 );
    BYTE* pDstRow;
    pDstRow = (BYTE*)d3dlr.pBits;
    WORD* pDst16;
    BYTE bAlpha; // 4-bit measure of pixel intensity
    DWORD x, y;

    for( y=0; y < m_dwTexHeight; y++ )
    {
        pDst16 = (WORD*)pDstRow;
        for( x=0; x < m_dwTexWidth; x++ )
        {
            bAlpha = (BYTE)((pBitmapBits[m_dwTexWidth*y + x] & 0xff) >> 4);
            if (bAlpha > 0)
            {
                *pDst16++ = (WORD) ((bAlpha << 12) | 0x0fff);
            }
            else
            {
                *pDst16++ = 0x0000;
            }
        }
        pDstRow += d3dlr.Pitch;
    }

    hr = S_OK;

    // Done updating texture, so clean up used objects
LCleanReturn:
    if( m_pTexture )
        m_pTexture->UnlockRect(0);

    SelectObject( hDC, hbmOld );
    SelectObject( hDC, hFontOld );
    DeleteObject( hbmBitmap );
    DeleteObject( hFont );
    DeleteDC( hDC );

    return hr;
}




//-----------------------------------------------------------------------------
// Name: RestoreDeviceObjects()
// Desc:
//-----------------------------------------------------------------------------
HRESULT CD3DFont::RestoreDeviceObjects()
{
    HRESULT hr;

    // Create vertex buffer for the letters
    int vertexSize = max( sizeof(FONT2DVERTEX), sizeof(FONT3DVERTEX ) );
    if( FAILED( hr = m_pd3dDevice->CreateVertexBuffer( MAX_NUM_VERTICES * vertexSize,
                                                       D3DUSAGE_WRITEONLY | D3DUSAGE_DYNAMIC, 0,
                                                       D3DPOOL_DEFAULT, &m_pVB, NULL ) ) )
    {
        return hr;
    }

    bool bSupportsAlphaBlend = true;
    LPDIRECT3D9 pd3d9 = NULL;
    if( SUCCEEDED( m_pd3dDevice->GetDirect3D( &pd3d9 ) ) )
    {
        D3DCAPS9 Caps;
        D3DDISPLAYMODE Mode;
        LPDIRECT3DSURFACE9 pSurf = NULL;
        D3DSURFACE_DESC Desc;
        m_pd3dDevice->GetDeviceCaps( &Caps );
        m_pd3dDevice->GetDisplayMode( 0, &Mode );
        if( SUCCEEDED( m_pd3dDevice->GetRenderTarget( 0, &pSurf ) ) )
        {
            pSurf->GetDesc( &Desc );
            if( FAILED( pd3d9->CheckDeviceFormat( Caps.AdapterOrdinal, Caps.DeviceType, Mode.Format,
                D3DUSAGE_RENDERTARGET | D3DUSAGE_QUERY_POSTPIXELSHADER_BLENDING, D3DRTYPE_SURFACE, 
                Desc.Format ) ) )
            {
                bSupportsAlphaBlend = false;
            }
            safe_release( pSurf );
        }
        safe_release( pd3d9 );
    }

    // Create the state blocks for rendering text
    for( UINT which=0; which<2; which++ )
    {
        m_pd3dDevice->BeginStateBlock();
        m_pd3dDevice->SetTexture( 0, m_pTexture );

        if ( D3DFONT_ZENABLE & m_dwFontFlags )
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, TRUE );
        else
            m_pd3dDevice->SetRenderState( D3DRS_ZENABLE, FALSE );

        if( bSupportsAlphaBlend )
        {
            m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
            m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,   D3DBLEND_SRCALPHA );
            m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND,  D3DBLEND_INVSRCALPHA );
        }
        else
        {
            m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, FALSE );
        }
        m_pd3dDevice->SetRenderState( D3DRS_ALPHATESTENABLE,  TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAREF,         0x08 );
        m_pd3dDevice->SetRenderState( D3DRS_ALPHAFUNC,  D3DCMP_GREATEREQUAL );
        m_pd3dDevice->SetRenderState( D3DRS_FILLMODE,   D3DFILL_SOLID );
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE,   D3DCULL_CCW );
        m_pd3dDevice->SetRenderState( D3DRS_STENCILENABLE,    FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPING,         TRUE );
        m_pd3dDevice->SetRenderState( D3DRS_CLIPPLANEENABLE,  FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_VERTEXBLEND,      D3DVBF_DISABLE );
        m_pd3dDevice->SetRenderState( D3DRS_INDEXEDVERTEXBLENDENABLE, FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_FOGENABLE,        FALSE );
        m_pd3dDevice->SetRenderState( D3DRS_COLORWRITEENABLE,
            D3DCOLORWRITEENABLE_RED  | D3DCOLORWRITEENABLE_GREEN |
            D3DCOLORWRITEENABLE_BLUE | D3DCOLORWRITEENABLE_ALPHA );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAOP,   D3DTOP_MODULATE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXCOORDINDEX, 0 );
        m_pd3dDevice->SetTextureStageState( 0, D3DTSS_TEXTURETRANSFORMFLAGS, D3DTTFF_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP,   D3DTOP_DISABLE );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_POINT );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MIPFILTER, D3DTEXF_NONE );

        if( which==0 )
            m_pd3dDevice->EndStateBlock( &m_pStateBlockSaved );
        else
            m_pd3dDevice->EndStateBlock( &m_pStateBlockDrawText );
    }

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: InvalidateDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::InvalidateDeviceObjects()
{
	m_pVB.Release();
	m_pStateBlockSaved.Release();
	m_pStateBlockDrawText.Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DeleteDeviceObjects()
// Desc: Destroys all device-dependent objects
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DeleteDeviceObjects()
{
    m_pTexture.Release();
    m_pd3dDevice.Release();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: GetTextExtent()
// Desc: Get the dimensions of a text string
//-----------------------------------------------------------------------------
HRESULT CD3DFont::GetTextExtent( const TCHAR* strText, SIZE* pSize )
{
    if( NULL==strText || NULL==pSize )
        return E_FAIL;

    FLOAT fRowWidth  = 0.0f;
    FLOAT fRowHeight = (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
    FLOAT fWidth     = 0.0f;
    FLOAT fHeight    = fRowHeight;

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            fRowWidth = 0.0f;
            fHeight  += fRowHeight;
        }

        if( (c-32) < 0 || (c-32) >= 128-32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT tx2 = m_fTexCoords[c-32][2];

        fRowWidth += (tx2-tx1)*m_dwTexWidth - 2*m_dwSpacing;

        if( fRowWidth > fWidth )
            fWidth = fRowWidth;
    }

    pSize->cx = (int)fWidth;
    pSize->cy = (int)fHeight;

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawTextScaled()
// Desc: Draws scaled 2D text.  Note that x and y are in viewport coordinates
//       (ranging from -1 to +1).  fXScale and fYScale are the size fraction 
//       relative to the entire viewport.  For example, a fXScale of 0.25 is
//       1/8th of the screen width.  This allows you to output text at a fixed
//       fraction of the viewport, even if the screen or window size changes.
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawTextScaled( FLOAT x, FLOAT y, FLOAT z,
                                  FLOAT fXScale, FLOAT fYScale, DWORD dwColor,
                                  const TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Set up renderstate
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawText->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }

    D3DVIEWPORT9 vp;
    m_pd3dDevice->GetViewport( &vp );
    FLOAT fLineHeight = ( m_fTexCoords[0][3] - m_fTexCoords[0][1] ) * m_dwTexHeight;

    // Center the text block in the viewport
    if( dwFlags & D3DFONT_CENTERED_X )
    {
        const TCHAR* strTextTmp = strText;
        float xFinal = 0.0f;

        while( *strTextTmp )
        {
            TCHAR c = *strTextTmp++;
    
            if( c == _T('\n') )
                break;  // Isn't supported.  
            if( (c-32) < 0 || (c-32) >= 128-32 )
                continue;

            FLOAT tx1 = m_fTexCoords[c-32][0];
            FLOAT tx2 = m_fTexCoords[c-32][2];

            FLOAT w = (tx2-tx1)*m_dwTexWidth;

            w *= (fXScale*vp.Height)/fLineHeight;

            xFinal += w - (2 * m_dwSpacing) * (fXScale*vp.Height)/fLineHeight;
        }

        x = -xFinal/vp.Width;
    }
    if( dwFlags & D3DFONT_CENTERED_Y )
    {
        y = -fLineHeight/vp.Height;
    }

    FLOAT sx  = (x+1.0f)*vp.Width/2;
    FLOAT sy  = (y+1.0f)*vp.Height/2;
    FLOAT sz  = z;
    FLOAT rhw = 1.0f;

    // Adjust for character spacing
    sx -= m_dwSpacing * (fXScale*vp.Height)/fLineHeight;
    FLOAT fStartX = sx;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx  = fStartX;
            sy += fYScale*vp.Height;
        }

        if( (c-32) < 0 || (c-32) >= 128-32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1)*m_dwTexWidth;
        FLOAT h = (ty2-ty1)*m_dwTexHeight;

        w *= (fXScale*vp.Height)/fLineHeight;
        h *= (fYScale*vp.Height)/fLineHeight;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,sz,rhw), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,sz,rhw), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w - (2 * m_dwSpacing) * (fXScale*vp.Height)/fLineHeight;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pStateBlockSaved->Apply();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: DrawText()
// Desc: Draws 2D text. Note that sx and sy are in pixels
//-----------------------------------------------------------------------------
HRESULT CD3DFont::DrawText( FLOAT sx, FLOAT sy, DWORD dwColor,
                            const TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawText->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT2DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT2DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );

        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }

    // Center the text block in the viewport
    if( dwFlags & D3DFONT_CENTERED_X )
    {
        D3DVIEWPORT9 vp;
        m_pd3dDevice->GetViewport( &vp );
        const TCHAR* strTextTmp = strText;
        float xFinal = 0.0f;

        while( *strTextTmp )
        {
            TCHAR c = *strTextTmp++;
    
            if( c == _T('\n') )
                break;  // Isn't supported.  
            if( (c-32) < 0 || (c-32) >= 128-32 )
                continue;

            FLOAT tx1 = m_fTexCoords[c-32][0];
            FLOAT tx2 = m_fTexCoords[c-32][2];
    
            FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
    
            xFinal += w - (2 * m_dwSpacing);
        }

        sx = (vp.Width-xFinal)/2.0f;
    }
    if( dwFlags & D3DFONT_CENTERED_Y )
    {
        D3DVIEWPORT9 vp;
        m_pd3dDevice->GetViewport( &vp );
        float fLineHeight = ((m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight);
        sy = (vp.Height-fLineHeight)/2;
    }

    // Adjust for character spacing
    sx -= m_dwSpacing;
    FLOAT fStartX = sx;

    // Fill vertex buffer
    FONT2DVERTEX* pVertices = NULL;
    DWORD         dwNumTriangles = 0;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );

    while( *strText )
    {
        TCHAR c = *strText++;

        if( c == _T('\n') )
        {
            sx = fStartX;
            sy += (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight;
        }

        if( (c-32) < 0 || (c-32) >= 128-32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) *  m_dwTexWidth / m_fTextScale;
        FLOAT h = (ty2-ty1) * m_dwTexHeight / m_fTextScale;

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx1, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx2, ty1 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+w-0.5f,sy+h-0.5f,0.9f,1.0f), dwColor, tx2, ty2 );
            *pVertices++ = InitFont2DVertex( D3DXVECTOR4(sx+0-0.5f,sy+0-0.5f,0.9f,1.0f), dwColor, tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                pVertices = NULL;
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        sx += w - (2 * m_dwSpacing);
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pStateBlockSaved->Apply();

    return S_OK;
}




//-----------------------------------------------------------------------------
// Name: Render3DText()
// Desc: Renders 3D text
//-----------------------------------------------------------------------------
HRESULT CD3DFont::Render3DText( const TCHAR* strText, DWORD dwFlags )
{
    if( m_pd3dDevice == NULL )
        return E_FAIL;

    // Setup renderstate
    m_pStateBlockSaved->Capture();
    m_pStateBlockDrawText->Apply();
    m_pd3dDevice->SetFVF( D3DFVF_FONT3DVERTEX );
    m_pd3dDevice->SetPixelShader( NULL );
    m_pd3dDevice->SetStreamSource( 0, m_pVB, 0, sizeof(FONT3DVERTEX) );

    // Set filter states
    if( dwFlags & D3DFONT_FILTERED )
    {
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR );
        m_pd3dDevice->SetSamplerState( 0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR );
    }

    // Position for each text element
    FLOAT x = 0.0f;
    FLOAT y = 0.0f;

    // Center the text block at the origin (not the viewport)
    if( dwFlags & D3DFONT_CENTERED_X )
    {
        SIZE sz;
        GetTextExtent( strText, &sz );
        x = -(((FLOAT)sz.cx)/10.0f)/2.0f;
    }
    if( dwFlags & D3DFONT_CENTERED_Y )
    {
        SIZE sz;
        GetTextExtent( strText, &sz );
        y = -(((FLOAT)sz.cy)/10.0f)/2.0f;
    }

    // Turn off culling for two-sided text
    if( dwFlags & D3DFONT_TWOSIDED )
        m_pd3dDevice->SetRenderState( D3DRS_CULLMODE, D3DCULL_NONE );

    // Adjust for character spacing
    x -= m_dwSpacing / 10.0f;
    FLOAT fStartX = x;
    TCHAR c;

    // Fill vertex buffer
    FONT3DVERTEX* pVertices;
    DWORD         dwNumTriangles = 0L;
    m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );

    while( (c = *strText++) != 0 )
    {
        if( c == '\n' )
        {
            x = fStartX;
            y -= (m_fTexCoords[0][3]-m_fTexCoords[0][1])*m_dwTexHeight/10.0f;
        }

        if( (c-32) < 0 || (c-32) >= 128-32 )
            continue;

        FLOAT tx1 = m_fTexCoords[c-32][0];
        FLOAT ty1 = m_fTexCoords[c-32][1];
        FLOAT tx2 = m_fTexCoords[c-32][2];
        FLOAT ty2 = m_fTexCoords[c-32][3];

        FLOAT w = (tx2-tx1) * m_dwTexWidth  / ( 10.0f * m_fTextScale );
        FLOAT h = (ty2-ty1) * m_dwTexHeight / ( 10.0f * m_fTextScale );

        if( c != _T(' ') )
        {
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+0,0), D3DXVECTOR3(0,0,-1), tx1, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+h,0), D3DXVECTOR3(0,0,-1), tx2, ty1 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+w,y+0,0), D3DXVECTOR3(0,0,-1), tx2, ty2 );
            *pVertices++ = InitFont3DVertex( D3DXVECTOR3(x+0,y+h,0), D3DXVECTOR3(0,0,-1), tx1, ty1 );
            dwNumTriangles += 2;

            if( dwNumTriangles*3 > (MAX_NUM_VERTICES-6) )
            {
                // Unlock, render, and relock the vertex buffer
                m_pVB->Unlock();
                m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );
                m_pVB->Lock( 0, 0, (void**)&pVertices, D3DLOCK_DISCARD );
                dwNumTriangles = 0L;
            }
        }

        x += w - (2 * m_dwSpacing) / 10.0f;
    }

    // Unlock and render the vertex buffer
    m_pVB->Unlock();
    if( dwNumTriangles > 0 )
        m_pd3dDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, dwNumTriangles );

    // Restore the modified renderstates
    m_pStateBlockSaved->Apply();

    return S_OK;
}




E:\Project\Kopia (5) VBEngine\Graphics\Debuging\d3dfont.h
//-----------------------------------------------------------------------------
// File: D3DFont.h
//
// Desc: Texture-based font class
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#ifndef D3DFONT_H
#define D3DFONT_H
#include <tchar.h>
#include <D3D9.h>
#include <atlbase.h>


// Font creation flags
#define D3DFONT_BOLD        0x0001
#define D3DFONT_ITALIC      0x0002
#define D3DFONT_ZENABLE     0x0004

// Font rendering flags
#define D3DFONT_CENTERED_X  0x0001
#define D3DFONT_CENTERED_Y  0x0002
#define D3DFONT_TWOSIDED    0x0004
#define D3DFONT_FILTERED    0x0008




//-----------------------------------------------------------------------------
// Name: class CD3DFont
// Desc: Texture-based font class for doing text in a 3D scene.
//-----------------------------------------------------------------------------
class CD3DFont
{
    TCHAR   m_strFontName[80];            // Font properties
    DWORD   m_dwFontHeight;
    DWORD   m_dwFontFlags;

    CComPtr<IDirect3DDevice9>  m_pd3dDevice; // A D3DDevice used for rendering
    CComPtr<IDirect3DTexture9>  m_pTexture;   // The d3d texture for this font
    CComPtr<IDirect3DVertexBuffer9> m_pVB;        // VertexBuffer for rendering text
    DWORD   m_dwTexWidth;                 // Texture dimensions
    DWORD   m_dwTexHeight;
    FLOAT   m_fTextScale;
    FLOAT   m_fTexCoords[128-32][4];
    DWORD   m_dwSpacing;                  // Character pixel spacing per side

    // Stateblocks for setting and restoring render states
    CComPtr<IDirect3DStateBlock9> m_pStateBlockSaved;
    CComPtr<IDirect3DStateBlock9> m_pStateBlockDrawText;

    HRESULT   CreateGDIFont( HDC hDC, HFONT* pFont );
    HRESULT   PaintAlphabet( HDC hDC, BOOL bMeasureOnly=FALSE );

public:
    // 2D and 3D text drawing functions
    HRESULT DrawText( FLOAT x, FLOAT y, DWORD dwColor, 
                      const TCHAR* strText, DWORD dwFlags=0L );
    HRESULT DrawTextScaled( FLOAT x, FLOAT y, FLOAT z, 
                            FLOAT fXScale, FLOAT fYScale, DWORD dwColor, 
                            const TCHAR* strText, DWORD dwFlags=0L );
    HRESULT Render3DText( const TCHAR* strText, DWORD dwFlags=0L );
    
    // Function to get extent of text
    HRESULT GetTextExtent( const TCHAR* strText, SIZE* pSize );

    // Initializing and destroying device-dependent objects
    HRESULT InitDeviceObjects( CComPtr<IDirect3DDevice9> pd3dDevice );
    HRESULT RestoreDeviceObjects();
    HRESULT InvalidateDeviceObjects();
    HRESULT DeleteDeviceObjects();

    // Constructor / destructor
    CD3DFont( const TCHAR* strFontName, DWORD dwHeight, DWORD dwFlags=0L );
    ~CD3DFont();
};




#endif


E:\Project\Kopia (5) VBEngine\Graphics\GUI\GuiBackgroundObject.cpp
#include "..\..\config.h"

#include <crtdbg.h>
#include <assert.h>
#include <d3dx9.h>
#include <dinput.h>


#include "..\..\utility\Misc.h"
#include "..\..\utility\Profile.h"
#include "..\..\utility\Singleton.h"

#include "..\..\utility\ctime.h"
#include "..\..\utility\vbmath.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include "..\renderer.h"
#include "..\camera.h"
#include "..\sceneobject.h"
#include "..\scenemanager.h"
#include "..\meshManager.h"

#include "..\..\input\mapper.h"
#include "..\..\input\input.h"


#include "GUIItems.h"


//obiekt t³a do GUI - jedyne co robi to wyœwietla obracaj¹cy sie mesh - pozycja i wszystko inne jest
// na sztywno


GUIBackgroundObject::GUIBackgroundObject(char *name):GUIObject(0,0,1,1,0,true)
{
    this->mQuad = CMeshManager::Instance()->GetMeshHandlerLoad(name);
    CMeshManager::Instance()->SetMeshClinable(this->mQuad, false);
}

void GUIBackgroundObject::Update()
{  // obrót o 360 stopni co piêæ sekund 
  this->worldMatrix.SetRotateZ((fmodf(NOW,5.0f)/5.0f) * 2.0f * PI);
}

GUIBackgroundObject::~GUIBackgroundObject()
{
}

void GUIBackgroundObject::Render(CMatrix4 *pViewProj)
{
  CMatrix4 WordViewProj;
  CMatrix4 View;
  CMatrix4 Proj;
  CMatrix4 Tweak;
  CVector3 vEyePt(0, 0.3f, 0.0f);//10.0f, -10.0f, -10.0f);
  CVector3 vLookatPt(0.0f,0.0f,0.0f);
  CVector3 vUpVec(0.0f,0.0f,1.0f);
  View.SetCameraLookAtRH(&vEyePt, &vLookatPt, &vUpVec );
  Proj.SetPerspectiveFovRH(PI/4, 1024.0f/768.0f, 0.10f, 50.0f );
  Tweak.SetTranslate(0.62f,-0.04f,0.0f); // przesuniêcie ju¿ w p³aszczyŸnie ekranu
  WordViewProj = this->worldMatrix * View * Proj * Tweak;
  CMeshManager::Instance()->Render(this->mQuad, &WordViewProj);
}

void GUIBackgroundObject::Reload()
{
  CMeshManager::Instance()->LoadMeshWithTextures(this->mQuad);
}

int GUIBackgroundObject::GetReloadCount()
{
  return CMeshManager::Instance()->GetReloadCount(this->mQuad);
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GuiBackgroundObject.h
#ifndef _GUIBACKGROUNDOBJECT_H
#define _GUIBACKGROUNDOBJECT_H



class GUIBackgroundObject :public GUIObject
{
  
public:
  GUIBackgroundObject(char *name);
  ~GUIBackgroundObject();
  void Render(CMatrix4 *pViewProj);
  void Update();
  void Reload();
  int GetReloadCount();
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIButton.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"
#include "..\..\utility\Ctime.h"

#include <dinput.h>
#include "..\..\input\mapper.h"
#include "..\..\input\input.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"

#include "GUIItems.h"

// przycisk - mo¿e mieæ 4 stany
// normal - stan normalny - myszka poza obrysem
// hover - myszka nad przyciskiem
// pressed - wciœniêty przycisk
// disabled - wy³¹czony


GUIButton::GUIButton(float x, float y,float w, float h) :GUIObject(x,y,w,h)
{// wyczyœæ tablice klatek
  memset(this->mFrames,0 ,sizeof(this->mFrames));
  this->mEventTarget = 0;
  this->mCurrentState = BS_NORMAL; // domyœlnie stan jest NORMAL
  this->mCurrentFrame = 0;
}

GUIButton::~GUIButton()
{
 for (int i = 0 ; i < BS_COUNT;i++)
 {
   if (this->mFrames[i])
    delete[] this->mFrames[i];
 }
}
// ustawianie tekstur przycisków dla okreœlonego stanu
// tekstury musz¹ byæ nazwane "baseName_[numer klatki].png"


void GUIButton::SetTexture(eButtonStates state, char* baseName, int frameCount, float timeDelta)
{
  char Buffer[MAX_PATH];
  if (this->mFrames[state])
    delete[] this->mFrames[state];
  this->mFrameCount[state] = frameCount;
  this->mTimeDeltas[state] = timeDelta;
  this->mFrames[state] = new HTexture[frameCount];
  for(int i = 0; i < frameCount; i++)
  {
    my_snprintf(Buffer,MAX_PATH,"%s_%i.png",baseName,i);
    this->mFrames[state][i] = CMeshManager::Instance()->GetTextureHandlerLoad(Buffer);
  }
}

// funkcja wysy³aj¹ca eventa - wywo³ywana po naciœniêciu przycisku

void GUIButton::NotifyListener()
{
  if(this->mEventTarget )
  {
    POST_EVENT2(mEventTarget,mEventID,mEventID2,mEventIsUrgent,NULL);
  }
}

// funkcja ustawiaj¹ca parametry eventa wychodzacego z tego przycisku
void GUIButton::SetClickEvent(unsigned long eventTarget,unsigned long eventID, unsigned long eventID2, bool urgent)
{
  this->mEventTarget = eventTarget;
  this->mEventID = eventID;
  this->mEventID2 = eventID2;
  this->mEventIsUrgent = urgent;
}

// update - funkcja zajmuj¹ca sie ustawianiem stanów i sprawdzaniem pozycji myszki wzglêdem przycisku
void GUIButton::Update()
{
  float current_time = NOW;
  float mouse_x = Input::Instance()->total_mouse_x;
  float mouse_y = Input::Instance()->total_mouse_y;
  if ( mCurrentState != BS_DISABLED) // przycisk nie jest wy³¹czony
  { // myszka jest na obszarze przycisku
    if( (mouse_x > mx) && (mouse_x < (mx+mw)) && (mouse_y > my) && (mouse_y < (my+mh)))
    {
      if (mCurrentState == BS_PRESSED) // jeœli jest naciœniêty
      {
        if (!Input::Instance()->wlaczonyl) // puszczono przycisk myszki
        {
          NotifyListener(); // wyœli ewenta
          mCurrentState = BS_HOVER; // prze³¹cz sie na hover
          mLastChangeTime = current_time; 
          mCurrentFrame = 0;
          POST_EVENT(ET_AUDIO, WAV_7, false, NULL); // puœæ dŸwiêk klikniêcia
        }
      } else
      {
        if (Input::Instance()->wlaczonyl) // nie by³ naciœniêty ale teraz jest
        {
          mCurrentState = BS_PRESSED; // przejdŸ do stanu wciœniêcia
          mLastChangeTime = current_time;
          mCurrentFrame = 0; 
        }
        else
        {
          if (mCurrentState != BS_HOVER) // dopiero wszed³ na obszar przycisku
          {
            mCurrentState = BS_HOVER; // niech bêdzie hover
            mLastChangeTime = current_time;
            mCurrentFrame = 0;
          }
        }
      }
    }
    else
    {
      if (mCurrentState != BS_NORMAL) // by³ w innym stanie, ale kursor opuœci³ obszar przycisku
        {
          mCurrentState = BS_NORMAL; // przejdŸ do stanu normalnego
          mLastChangeTime = current_time;
          mCurrentFrame = 0;
        }
    }
  }
  if (mFrameCount[mCurrentState] != 1) // je¿eli jest wiêcej klatek jedna
  {
    while (mLastChangeTime + mTimeDeltas[mCurrentState] < current_time) // je¿eli czas ju¿ zmieniæ klatke

    {
      mLastChangeTime += mTimeDeltas[mCurrentState]; // zmieñ klatke i przesuñ czas do przodu
      mCurrentFrame++;
      if (mCurrentFrame == mFrameCount[mCurrentState])
        mCurrentFrame = 0;
    }
  }
 
  this->mCurrentTexture = mFrames[mCurrentState][mCurrentFrame]; // ustaw aktualn¹ bitmape do renderingu
}

// w³aæz przycisk
void GUIButton::Enable()
{
  if (mCurrentState == BS_DISABLED) // w³¹czaj tylko jak by³ wczeœniej wy³¹czony
  {
    mCurrentState = BS_NORMAL;
    mLastChangeTime = NOW;
  }
}
// wy³¹cz przycisk
void GUIButton::Disable()
{
  if (mCurrentState != BS_DISABLED) // ale tylko jak nie by³ jeszcze wy³¹czony
  {
    mCurrentState = BS_DISABLED;
    mLastChangeTime = NOW;
  }
}

int GUIButton::GetReloadCount()
{
  int count = 0;
  for (int i = 0 ; i < 4 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    for (int k = 0 ; k < this->mFrameCount[i]; k ++)
    {
      if(!CMeshManager::Instance()->GetTexture(this->mFrames[i][k])->IsLoaded())
      {
        count++;
      }
    }
  }
  return count;
}

// prze³aduj wszystkie bitmapy
void GUIButton::Reload()
{
  for (int i = 0 ; i < 4 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    for (int k = 0 ; k < this->mFrameCount[i]; k ++)
    {
      CMeshManager::Instance()->GetTexture(this->mFrames[i][k])->Load(Renderer::Instance()->GetDevice());
    }
  }
}


// ustaw mo¿liwoœæ wyczyszczenia bitmapom przycisku 
void GUIButton::SetClinable(bool cl)
{
 for (int i = 0 ; i < 4 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    for (int k = 0 ; k < this->mFrameCount[i]; k ++)
    {
      CMeshManager::Instance()->SetTextureClinable(this->mFrames[i][k],cl);
    }
  }
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIButton.h
#ifndef _GUIBUTTON_H
#define _GUIBUTTON_H


enum eButtonStates
{
  BS_NORMAL,
  BS_PRESSED,
  BS_HOVER,
  BS_DISABLED,
  BS_COUNT
};

class GUIButton :public GUIObject
{
  unsigned long mEventTarget;
  unsigned long mEventID,mEventID2;
  bool mEventIsUrgent;

protected:
  eButtonStates mCurrentState;
  float mLastChangeTime;
  unsigned char mFrameCount[BS_COUNT];
  unsigned char mCurrentFrame;
  HTexture *mFrames[BS_COUNT];
  float mTimeDeltas[BS_COUNT];
  void NotifyListener();
public:
  GUIButton(float x, float y,float w, float h);
  ~GUIButton();
  void SetClickEvent(unsigned long eventTarget,unsigned long eventID, unsigned long eventID2,bool urgent);
  void SetTexture(eButtonStates state,char *baseName, int frameCount, float timeDelta);
  virtual void Update();
  virtual void Enable();
  virtual void Disable();
  void Reload();
  void SetClinable(bool cl);
  int GetReloadCount();
};
#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUICheckbox.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"
#include "..\..\utility\Ctime.h"

#include <dinput.h>
#include "..\..\input\mapper.h"
#include "..\..\input\input.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"

#include "GUIItems.h"

char *CheckBoxExt[] = 
{
  "normal",
  "presed",
  "presed",
  "normal",
  "normal",
};

// checkbox - kod podobny do GUIButton
// z niewielkimi modyfikacjami kalka tamtego
// target - pointer do boola który odpowiada stanowi tego checkboxa
GUICheckBox::GUICheckBox(float x, float y,float w, float h,char *name, bool *target) :GUIObject(x,y,w,h),mTarget(target)
{
  memset(this->mFrames,0 ,sizeof(this->mFrames));
  this->mCurrentState = CBS_NORMAL;
  this->mCurrentFrame = 0;
  char buffer[256];
  for (int i = 0 ; i < CBS_COUNT ; i++)
  {
    my_snprintf(buffer,256,"%s_%s",name,CheckBoxExt[i]);
    this->SetTexture((eCheckBoxStates)i,buffer,1,10);
  }
  if (*mTarget)
  {
    mCurrentState = CBS_CHECKED;
  }
}

GUICheckBox::~GUICheckBox()
{

 for (int i = 0 ; i < CBS_COUNT;i++)
 {
   if (this->mFrames[i])
    delete[] this->mFrames[i];
 }
}


void GUICheckBox::SetTexture(eCheckBoxStates state, char* baseName, int frameCount, float timeDelta)
{
  char Buffer[MAX_PATH];
  if (this->mFrames[state])
    delete[] this->mFrames[state];
  this->mFrameCount[state] = frameCount;
  this->mTimeDeltas[state] = timeDelta;
  this->mFrames[state] = new HTexture[frameCount];
  for(int i = 0; i < frameCount; i++)
  {
    my_snprintf(Buffer,MAX_PATH,"%s_%i.png",baseName,i);
    this->mFrames[state][i] = CMeshManager::Instance()->GetTextureHandlerLoad(Buffer);
  }
}



void GUICheckBox::Update()
{
  float current_time = NOW;
  float mouse_x = Input::Instance()->total_mouse_x;
  float mouse_y = Input::Instance()->total_mouse_y;
  if ( mCurrentState != CBS_DISABLED) // jest w³¹czony?
  {
    if( (mouse_x > mx) && (mouse_x < (mx+mw)) && (mouse_y > my) && (mouse_y < (my+mh)))
    { // myszka nad checkboxem? 
      if (Input::Instance()->wlaczonyl ) // przycisk myszki wciœniêty?
      {
        if (mCurrentState == CBS_NORMAL) //wczeœniej by³ normalny
        {
          mCurrentState = CBS_NORMAL2CHECKED; // przejdŸ do stanu przejœciowego miêdzy normalnym a wciœniêtym
          mLastChangeTime = current_time;
          mCurrentFrame = 0;
        }
        else if (mCurrentState == CBS_CHECKED) // wczeœniej by³ wciœniêty
        {
          mCurrentState = CBS_CHECKED2NORMAL; // przejdŸ do stanu przejœciowego miêdzy wciœniêtym a normalnym
          mLastChangeTime = current_time;
          mCurrentFrame = 0;
        }
      }
      else // przycisk myszki nie wciœniêty
      {
        if (mCurrentState == CBS_NORMAL2CHECKED) // by³ w stanie przejœciowym?
        {
          mCurrentState = CBS_CHECKED; // przejdŸ do docelowego
          *mTarget = true; // zmieñ boola
          CVector3 *pos = new CVector3(0.0f,0.0f,0.0f);
          POST_EVENT(ET_AUDIO, WAV_7, false, pos);
          mLastChangeTime = current_time;
          mCurrentFrame = 0;
        }
        else if (mCurrentState == CBS_CHECKED2NORMAL) // jak powy¿ej tylko odwrotnie ;)
        {
          mCurrentState = CBS_NORMAL;
          *mTarget = false; // zmieñ boola
          CVector3 *pos = new CVector3(0.0f,0.0f,0.0f);
          POST_EVENT(ET_AUDIO, WAV_7, false, pos);
          mLastChangeTime = current_time;
          mCurrentFrame = 0;
        }
      }

    }
    else // myszka poza obszarem
    {
      if (mCurrentState == CBS_NORMAL2CHECKED)  // byl w przejœciowym
      {
        mCurrentState = CBS_NORMAL; // wróæ do podstawowego
        mLastChangeTime = current_time;
        mCurrentFrame = 0;
      }
      else if (mCurrentState == CBS_CHECKED2NORMAL)
      {
        mCurrentState = CBS_CHECKED;
        mLastChangeTime = current_time;
        mCurrentFrame = 0;
      }
    }
  }
  
  if (mFrameCount[mCurrentState] != 1) // je¿eli klatek wiêcej ni¿ jedna 
  {
    while (mLastChangeTime + mTimeDeltas[mCurrentState] < current_time) // zupdate'uj klatki
    {
      mLastChangeTime += mTimeDeltas[mCurrentState];
      mCurrentFrame++;
      if (mCurrentFrame == mFrameCount[mCurrentState])
        mCurrentFrame = 0;
    }
  }
 
  this->mCurrentTexture = mFrames[mCurrentState][mCurrentFrame]; // ustaw aktualn¹ klatke
}


void GUICheckBox::Enable()
{
  if (mCurrentState == CBS_DISABLED)
  {
    mCurrentState = CBS_NORMAL;
    mLastChangeTime = NOW;
  }
}

void GUICheckBox::Disable()
{
  if (mCurrentState != CBS_DISABLED)
  {
    mCurrentState = CBS_DISABLED;
    mLastChangeTime = NOW;
  }
}

// zmieñ stan przycisku
void GUICheckBox::Toggle()
{
  if (mCurrentState == CBS_NORMAL)
  {
    mCurrentState = CBS_CHECKED;
    *this->mTarget= true;
    mLastChangeTime = NOW;
    mCurrentFrame = 0;
  }
  else 
  {
    mCurrentState = CBS_NORMAL;
    *this->mTarget= false;
    mLastChangeTime = NOW;
    mCurrentFrame = 0;
  }
}
// poka¿ checkbox
void GUICheckBox::Show()
{
 if (*this->mTarget == true) mCurrentState = CBS_CHECKED; // ustaw mu stan w zale¿noœci od boola
 else mCurrentState = CBS_NORMAL;
 GUIObject::Show();
}


int GUICheckBox::GetReloadCount()
{
  int count = 0;
  for (int i = 0 ; i < 5 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    for (int k = 0 ; k < this->mFrameCount[i]; k ++)
    {
      if(!CMeshManager::Instance()->GetTexture(this->mFrames[i][k])->IsLoaded())
      {
        count++;
      }
    }
  }
  return count;
}

void GUICheckBox::Reload()
{
  for (int i = 0 ; i < 5 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    for (int k = 0 ; k < this->mFrameCount[i]; k ++)
    {
      CMeshManager::Instance()->GetTexture(this->mFrames[i][k])->Load(Renderer::Instance()->GetDevice());
    }
  }
}

void GUICheckBox::SetClinable(bool cl)
{
 for (int i = 0 ; i < 5 ;i ++)
  {
    if(!this->mFrames[i]) continue;
    if (this->mFrameCount[i] > 0 )
    {
      for (int k = 0 ; k < this->mFrameCount[i]; k ++)
      {
        CMeshManager::Instance()->SetTextureClinable(this->mFrames[i][k],cl);
      }
    }
  }

}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUICheckbox.h
#ifndef _GUICHECKBOX_H
#define _GUICHECKBOX_H


enum eCheckBoxStates
{
  CBS_NORMAL,
  CBS_NORMAL2CHECKED,
  CBS_CHECKED,
  CBS_CHECKED2NORMAL,
  CBS_DISABLED,
  CBS_COUNT
};

class GUICheckBox :public GUIObject
{
  eCheckBoxStates mCurrentState;
  float mLastChangeTime;
  unsigned char mFrameCount[CBS_COUNT];
  unsigned char mCurrentFrame;
  HTexture *mFrames[CBS_COUNT];
  float mTimeDeltas[CBS_COUNT];
  bool *mTarget;
public:
  GUICheckBox(float x, float y,float w, float h,char * name, bool *target);
  ~GUICheckBox();
  void SetTexture(eCheckBoxStates state,char *baseName, int frameCount, float timeDelta);
  virtual void Update();
  void Enable();
  void Disable();
  void Toggle();
  void Show();
  void Reload();
  void SetClinable(bool cl);
  int GetReloadCount();
};
#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUICursor.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"
#include "..\..\utility\Ctime.h"

#include <dinput.h>
#include "..\..\input\mapper.h"
#include "..\..\input\input.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"

#include "GUIItems.h"
#include "GUICursor.h"

// kursor myszki - ikona œledz¹ca parametry myszki

GUICursor::GUICursor():GUIObject(0.0f,0.0f,32.0f,32.0f,-35,false)
{
  mx = Input::Instance()->total_mouse_x;
  my = Input::Instance()->total_mouse_y;
  this->RebuildMatrix();
  mCurrentTexture =  CMeshManager::Instance()->GetTextureHandlerLoad("GUI\\kursor.png" );
  CMeshManager::Instance()->SetTextureClinable(mCurrentTexture, false);
}



void GUICursor::Update()
{
  mx = Input::Instance()->total_mouse_x;
  my = Input::Instance()->total_mouse_y;
  this->RebuildMatrix();
}

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUICursor.h
#ifndef _GUICURSOR_H
#define _GUICURSOR_H


class GUICursor : public GUIObject
{
protected:
  bool mVisible;
public:
  GUICursor();
  virtual ~GUICursor() {};
  void Update();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIDef.h
#ifndef _GUIDEF_H
#define _GUIDEF_H




#define D3DFVF_COLOR (D3DFVF_XYZ | D3DFVF_DIFFUSE)
#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIForceSlider.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"


#include "..\..\Core\Ball.h"

#include "GUIDef.h"
#include "GUIItems.h"


// pasek si³y - zwiêkszany podczas odbirou

GUIForceSlider::GUIForceSlider(float x,float y,float w, float h) :GUIObject(x,y,w,h)
{
 this->mBackground = new GUIIcon(x,y,w,h,"black.png");
 this->mPowerBar   = new GUIIcon(x,y,0.0001f,h,"gradient.png");
 this->mOverlay    = new GUIIcon(x,y,w,h,"oknosily.png");
}

GUIForceSlider::~GUIForceSlider()
{
  delete this->mBackground;
  delete this->mOverlay;
  delete this->mPowerBar; 
}

// ustaw wartoœæ paska si³y
void GUIForceSlider::Update()
{
  float force = GUI::Instance()->mBallForce; 
  if (force < EPSILON) force = (float)EPSILON;
  this->mPowerBar->SetDimensions(mx,my,mw * force,mh);
}


// poka¿ i ukryj elementy sk³adowe
void GUIForceSlider::Show()
{
  this->mVisible = true;
  this->mBackground->Show();
  this->mPowerBar->Show();
  this->mOverlay->Show();
}

void GUIForceSlider::Hide()
{
  this->mVisible = false;
  this->mBackground->Hide();
  this->mPowerBar->Hide();
  this->mOverlay->Hide();
}

void GUIForceSlider::Reload()
{
  this->mBackground->Reload();
  this->mPowerBar->Reload();
  this->mOverlay->Reload();
}

int GUIForceSlider::GetReloadCount()
{
  int count = this->mBackground->GetReloadCount();
  count += this->mPowerBar->GetReloadCount();
  count += this->mOverlay->GetReloadCount();
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIForceSlider.h
#ifndef _GUIFORCESLIDER_H
#define _GUIFORCESLIDER_H


class GUIForceSlider :public GUIObject
{
  GUIIcon *mOverlay;
  GUIIcon *mBackground;
  GUIIcon *mPowerBar;
public: 
  GUIForceSlider(float x, float y,float w, float h);
  ~GUIForceSlider();
  void Show();
  void Hide();
  void Update();
  void Render(CMatrix4 *) {}
  void Reload();
  int GetReloadCount();
};


#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIIcon.cpp
#include "..\..\config.h"

#include <assert.h>

#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"

#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"
#include "GUIDef.h"
#include "GUIObject.h"
#include "GUIIcon.h"


//klasa pomocnicza - zwyk³y GUIObject z ustawian¹ z automatu tekstur¹
GUIIcon::GUIIcon(float x, float y,float w, float h, char *texture_file)
                 :GUIObject(x,y,w,h,15)
{
  this->mCurrentTexture = CMeshManager::Instance()->GetTextureHandlerLoad(texture_file);   
}

GUIIcon::~GUIIcon()
{
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIIcon.h
#ifndef _GUIICON_H
#define _GUIICON_H


class GUIIcon : public GUIObject
{
 
public:
  GUIIcon(float x, float y, float w, float h, char *texture_file);
  ~GUIIcon();
  void SetTexture(HTexture new_texture) {this->mCurrentTexture = new_texture;}
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIItems.h
#ifndef _GUIITEMS_H
#define _GUIITEMS_H



#include "GUIDef.h"
#include "GUIObject.h"
#include "GUICursor.h"
#include "..\GUI.h"
#include "GUIIcon.h"
#include "GUIPanel.h"
#include "GUIButton.h"
#include "GUIMovingButton.h"
#include "GUINumbers.h"
#include "GUIForceSlider.h"
#include "..\DShowBase\streams.h"
#include "GuiVideoQuad.h"
#include "GuiTextField.h"
#include "GuiNumbers.h"
#include "GuiCheckBox.h"
#include "GuiSlider.h"
#include "GuiBackgroundObject.h"
#include "GUIMovingIcon.h"
#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIMovingButton.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"
#include "..\..\utility\Ctime.h"

#include <dinput.h>
#include "..\..\input\mapper.h"
#include "..\..\input\input.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"

#include "GUIItems.h"


// przycisk poruszaj¹cy sie
// mPositions[0] -> pozycja wy³¹czona
// mPositions[1] -> pozycja w³¹czona


GUIMovingButton::GUIMovingButton(float x, float y,float w, float h) :GUIButton(x,y,w,h) 
{
  mPositions[0].Set(x,y,0.0f);
  this->mCurrentState = BS_DISABLED;
  mAlpha = 0.0f;
  this->mSpeed = 1.0f;
  this->mMoveDirection = 0;
  
}
GUIMovingButton::~GUIMovingButton(){}


// update - je¿eli MoveDirection jest ustawione ( +1 disable->enable -1 enable->disable)
// morphuje pozycje przycisku od mPositions[0] do mPositions[1] (b¹dŸ odwrotnie)
void GUIMovingButton::Update()
{
  if (this->mMoveDirection != 0)
  {
    float current_time = REALNOW;
    if (this->mMoveDirection == 1)
      mAlpha =        (current_time - mMoveStartTime)/mSpeed;
    else
      mAlpha = 1.0f - (current_time - mMoveStartTime)/mSpeed;
    
      
    if (mAlpha > 1.0f) // alpha wiêksza od maks - zatrzymaj sie ju¿
    {
      mAlpha = 1.0f;
      mMoveDirection = 0;
    } 
    if (mAlpha <0.0f) // aplha < 0 ju¿ trzeba sie wy³¹czyæ
    {
      this->mCurrentState = BS_DISABLED;
      this->mLastChangeTime = REALNOW;
      mAlpha = 0.0f;
      mMoveDirection = 0;
    }

    mx = mAlpha * (this->mPositions[1].x - mPositions[0].x) + mPositions[0].x; // ustaw pozycje
    my = mAlpha * (this->mPositions[1].y - mPositions[0].y) + mPositions[0].y;
    this->RebuildMatrix(); // przebuduj macie¿
  }
  GUIButton::Update(); // sprawdŸ co na to wszystko zwyk³y przycisk
}


// uaktywnij przycisk - zacznij ruch 
void GUIMovingButton::Enable()
{
  if (this->mCurrentState  != BS_DISABLED &&
      this->mMoveDirection != -1) return;
  GUIButton::Enable();
  if ( this->mMoveDirection == 0)
  {
    this->mMoveStartTime = REALNOW;
    this->mMoveDirection = 1;
  }
  if ( this->mMoveDirection == -1) // cofa³ sie akurat - zawróc go
  {
    this->mMoveStartTime = REALNOW - mSpeed*(mAlpha);
    this->mMoveDirection = 1;
  }
}
// zdeaktywuj przycisk - zacznij rucj
void GUIMovingButton::Disable()
{
  if (this->mCurrentState == BS_DISABLED) return;
  if ( this->mMoveDirection == 0)
  {
    this->mMoveStartTime = REALNOW;
    this->mMoveDirection = -1;
  }
  if ( this->mMoveDirection == 1)
  {
    this->mMoveStartTime =REALNOW - mSpeed*(1-mAlpha);
    this->mMoveDirection = -1;
  }
}

// ustaw pozycje docelow¹
void GUIMovingButton::SetPosition(CVector3 *position)
{
  this->mPositions[1].Set(position);
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIMovingButton.h
#ifndef _GUIMOVINGBUTTON_H
#define _GUIMOVINGBUTTON_H



 class GUIMovingButton :public GUIButton
{
  CVector3 mPositions[2];
  float mSpeed;
  char mMoveDirection;
  float mMoveStartTime;
  float mAlpha;
public:
  GUIMovingButton(float x, float y,float w, float h);
  ~GUIMovingButton();
  void Update();
  void SetPosition( CVector3 *position);
  void Enable();
  void Disable();
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIMovingIcon.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"
#include "..\..\Utility\CTime.h"
#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"
#include "GUIDef.h"
#include "GUIObject.h"
#include "GUIIcon.h"
#include "GUIMovingIcon.h"

// poruszaj¹ca sie ikona 
// na meshu quad2.gif - pod niego pod³¹czony jest shader GUITiled.fx

GUIMovingIcon::GUIMovingIcon(float x, float y,float w, float h, char *texture_file)
                 :GUIObject(x,y,w,h,0,true)
{
  this->mQuad = CMeshManager::Instance()->GetMeshHandlerLoad("Quad2.x");
  this->mOriginalTexture = CMeshManager::Instance()->GetTextureHandler("quad2.gif"); 
  this->mCurrentTexture = CMeshManager::Instance()->GetTextureHandlerLoad(texture_file);   
  this->mMoveStartTime = NOW;
  this->mTime = 1e6;
}

GUIMovingIcon::~GUIMovingIcon()
{
}

// przesuwa ikone po ekranie zgodnie z czasem przesuwu

void GUIMovingIcon::Update()
{
  float current_time = NOW;
  while (current_time - mMoveStartTime > mTime)
  {
    mMoveStartTime += mTime;
  }
  float alpha = (current_time - mMoveStartTime)/ mTime;
  this->SetDimensions(mStartX + mDeltaX * alpha,
                      mStartY + mDeltaY * alpha,
                      mw,mh);
}

// ustawia parametry poruszania sie przycisku
// deltax, deltay - jakie odleg³oœci w danych osiach ma przejechaæ 
// startx, starty - pocz¹tkowe pozycje
// time - czas przelotu
void GUIMovingIcon::SetMoveParameters(float startx, float starty, float Deltax,float Deltay,float time)
{
  this->mMoveStartTime = NOW;
  this->mStartX = startx;
  this->mStartY = starty;
  this->mDeltaX = Deltax;
  this->mDeltaY = Deltay;
  this->mTime = time;
  this->SetDimensions(startx,starty,mw,mh); 
}

void GUIMovingIcon::Render(CMatrix4 *pViewProj)
{
  if (!mVisible) return;
  CMeshManager::Instance()->LinkTexture(this->mOriginalTexture,this->mCurrentTexture); 
  CMeshManager::Instance()->Render(mQuad,&this->worldMatrix);
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIMovingIcon.h
#ifndef _GUIMOVINGICON_H
#define _GUIMOVINGICON_H


class GUIMovingIcon :public GUIObject
{
 float mStartX,mStartY,mDeltaX,mDeltaY,mTime;
 float mMoveStartTime;
public:
  GUIMovingIcon(float x, float y, float w, float h, char *texture_file);
  ~GUIMovingIcon();
  void SetMoveParameters(float startx, float starty, float deltax, float deltay, float time);
  void Update();
  void Render(CMatrix4 *pViewProj);
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUINumbers.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"

#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\MeshManager.h"
#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\Renderer.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIOverlay.h"


// numerki - klasa wyœwietlaj¹ca wyniki - oparte na serii tekstur z numerami
// num - iloœæ cyfr wyœwietlanych

GUINumbers::GUINumbers(float x , float y, float w, float h, char *basename, int num)
                      :GUIObject(x,y,w,h)
{
  this->mNumberCount = num;
  this->mNumberQuads = new GUIIcon*[num];
  int i;
  for (i = 0 ; i < num; i++)
    this->mNumberQuads[i] = new GUIIcon(x + w * (float) i,y,w,h,"quad.gif");
  char buffer[256];
  for (i = 0 ; i < 10; i++)
  {
    my_snprintf(buffer,256,"%s%i.png",basename,i);
    this->mNumbers[i] = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
    CMeshManager::Instance()->SetTextureClinable(this->mNumbers[i], false);
  }
  this->mNumber = 0xffffffff;
}

GUINumbers::~GUINumbers()
{
  for (int i = 0; i < mNumberCount; i++)
    delete this->mNumberQuads[i];
  delete [] mNumberQuads;
}


void GUINumbers::Show()
{
  this ->mVisible = true;
  for (int i = 0; i < mNumberCount; i++)
  {
    this->mNumberQuads[i]->SetLevel(-31);
    this->mNumberQuads[i]->Show();
  }
}


void GUINumbers::Hide()
{
  this ->mVisible = false;
  for (int i = 0; i < mNumberCount; i++)
    this->mNumberQuads[i]->Hide();
}

// ustawianie wyœwietlanego numeru - dla szybkoœci sprawdza najpierw czy nie ma tego samego numeru ju¿
// ustawionego, jeœli nie to ustawia dla ka¿dej z ikon teksture odpowiadaj¹c¹ cyfrze na danej pozycji
void GUINumbers::SetNumber(unsigned int number)
{
  if (mNumber == number) return;
  else
    mNumber = number;

 for (int i = 0 ; i < mNumberCount; i++)
 {
   this->mNumberQuads[mNumberCount-i-1]->SetTexture(this->mNumbers[number %10]);
   number /= 10;
 }
}

int GUINumbers::GetReloadCount()
{
 int count = 0;
 for (int i = 0 ; i < 10; i++)
 {
   if(!CMeshManager::Instance()->GetTexture(this->mNumbers[i])->IsLoaded())
   {
     count++;
   }
 }
 return count;
}

void GUINumbers::Reload()
{
 for (int i = 0 ; i < 10; i++)
 {
   CMeshManager::Instance()->GetTexture(this->mNumbers[i])->Load(Renderer::Instance()->GetDevice());
 }
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUINumbers.h
#ifndef _GUINUMBERS_H
#define _GUINUMBERS_H




class GUINumbers :public GUIObject
{
  GUIIcon **mNumberQuads;
  HTexture mNumbers[10]; 
  unsigned char mNumberCount;
  unsigned int mNumber;
public:
  GUINumbers(float x , float y, float w, float h, char *basename, int num);
   ~GUINumbers();
  void Show();
  void Hide();
  void SetNumber(unsigned int number);
  void Render(CMatrix4 *pViewProj) {}
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIObject.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"

#include "..\SceneManager.h"
#include "GUIDef.h"
#include "GUIScore.h"

#include "GUIObject.h"

// podstawowa klasa GUI - zajmuje sie renderowaniem wiêkszoœci obiektów
// wczytuje handler na podstawowy mesh i teksture, podlinkowuje aktualn¹ i renderuje przez mesh managera
GUIObject::GUIObject(float x,float y, float w, float h,int render_level, bool customMesh)
                    :mx(x),my(y),mw(w),mh(h)
{
  level  = -30 + render_level;
  this->mCustomMesh = customMesh;
  this->mVisible = false;
  if (!mCustomMesh)
  {
    this->mQuad = CMeshManager::Instance()->GetMeshHandlerLoad("Quad.x"); 
    CMeshManager::Instance()->SetMeshClinable(this->mQuad, false);
    this->mOriginalTexture = CMeshManager::Instance()->GetTextureHandler("quad.gif"); 
    this->RebuildMatrix();
  }
  
  
}

void GUIObject::Render(CMatrix4 *pViewProj)
{
  if (!mVisible) return;
  CMeshManager::Instance()->LinkTexture(this->mOriginalTexture,this->mCurrentTexture); 
  CMeshManager::Instance()->Render(mQuad,&this->worldMatrix);
}
// SHow - dodaje obiekt do sceny
void GUIObject::Show()
{
  this->mVisible = true;
  SceneManager::Instance()->AddObject(this);
}
// hide - usuwa obiekt ze sceny
void GUIObject::Hide()
{
  this->mVisible = false;
  SceneManager::Instance()->RemoveObject(this);
}
// przebudowuje macie¿ obiketu tworz¹c j¹ z parametrów mx,my,mw i mh
void GUIObject::RebuildMatrix()
{
    this->worldMatrix.SetScale(mw,mh,1.0f);
    CMatrix4 temp1,temp2;
    temp1.SetTranslate(512-mx ,my -384 ,0.0f); 
    temp2.SetOrtho(1024,768,0.0f,1.0f);
    this->worldMatrix *= temp1*temp2;
}

// ustawia parametry obiektów na zadane wartoœci
void GUIObject::SetDimensions(float x, float y, float w, float h)
{
  this->mx = x;
  this->my = y;
  this->mw = w;
  this->mh = h;
  RebuildMatrix();
}

int GUIObject::GetReloadCount()
{
  return 
      (CMeshManager::Instance()->GetTexture(this->mCurrentTexture)->IsLoaded() ? 0 : 1);
}

void GUIObject::Reload()
{
  CMeshManager::Instance()->GetTexture(this->mCurrentTexture)->Load(Renderer::Instance()->GetDevice());
}


void GUIObject::SetClinable(bool cl)
{
  if(!this->mCustomMesh)
    CMeshManager::Instance()->SetTextureClinable(this->mCurrentTexture,cl);
}

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIObject.h
#ifndef _GUIOBJECT_H
#define _GUIOBJECT_H

class GUIObject :public SceneObject
{
protected:
  float mx,my,mw,mh;
  HMesh mQuad;
  bool mVisible;
  bool mCustomMesh;
  HTexture mOriginalTexture;
  HTexture mCurrentTexture;
public:
  GUIObject(float x, float y, float w, float h,int level = 0, bool customMesh = false);
  ~GUIObject() { if (this->mVisible) Hide();};
  virtual void Render(CMatrix4 *pViewProj);
  bool IsVisible(){return mVisible;}
  virtual void Show();
  virtual void Hide();
  virtual void Update() {};
  void RebuildMatrix();
  void SetDimensions(float x, float y , float w, float h);
  virtual int GetReloadCount();
  virtual void Reload(); 
  virtual void SetClinable(bool cl);
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIOverlay.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIOverlay.h"


// overlay - panel najbardziej zewnêtrzny - zajmuje sie t³em menu, poruszaj¹cymi sie przyciskami back i next

GUIPanelOverlay::GUIPanelOverlay()
{
  // najdalsze t³o - nieruchoma ikona
  this->mBackground = new GUIIcon(0,0,1024,768,"gui\\menu_tlo\\poziom0.png");
  this->mBackground->SetLevel(20);
  // pi³ka krêc¹ca sie w tle
  this->mBObject = new GUIBackgroundObject("pilkagra.x");
  this->mBObject->SetLevel(5);
  // poruszaj¹ce sie pionowo paski
  this->mForeGround[0] = new GUIMovingIcon(-1024,-768,2048, 1536,"gui\\menu_tlo\\poziom1.png");
  this->mForeGround[0]->SetLevel(4);
  this->mForeGround[0]->SetMoveParameters(-1024,-768,0,768,20); 
  this->mForeGround[1] = new GUIMovingIcon(0,0,2048, 1536,"gui\\menu_tlo\\poziom2.png");
  this->mForeGround[1]->SetMoveParameters(0,0,0,-768,16);
  this->mForeGround[1]->SetLevel(3);

  // losowo ruszaj¹ce sie pi³ki
  for (int i = 0; i < 3 ; i++)
  {
    this->mBallsY[i] = (float) (myrand(700)+68);
    this->mBallTimes[i] = (float) myrand(5) + 5;
    this->mBallSizes[i] = (float)(myrand(97) + 45);
    this->mBallStartTimes[i] = NOW + ((float) myrand(7) -3); 
    this->mBalls[i] = new GUIIcon(-mBallSizes[i],mBallsY[i],mBallSizes[i],mBallSizes[i],"gui\\menu_tlo\\pilka.png");
    this->mBallDirs[i] = myrand(1) == 1;
    this->mBalls[i]->SetLevel(2); 
  }
  // poruszaj¹ca sie siatka
  this->mSiatka  = new GUIMovingIcon(-1024,-768,2048, 1536,"gui\\menu_tlo\\siata.png");
  this->mSiatka->SetLevel(1);
  this->mSiatka ->SetMoveParameters(-1024,-768,1024,0,30); 
// najbardziej zewnêtrzne t³o (to w kratke)
  this->mOverlay = new GUIIcon(0,0,1024,768,"gui\\menu_tlo\\poziom3.png");
  this->mOverlay->SetLevel(0);
  // dolny pasek 
  this->mStatic = new GUIIcon(0,598,1024,170,"GUI\\menu_glowne\\dol.png"); 
  this->mStatic->SetLevel(-5); 
  // przucisk back
  this->mButtons[0] = new GUIMovingButton(-140,598,230,70);
  this->mButtons[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\gobackward_normal",1,10);
  this->mButtons[0]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\gobackward_normal",1,10);
  this->mButtons[0]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\gobackward_presed",1,10);
  this->mButtons[0]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\gobackward_rollon",1,10);
  this->mButtons[0]->SetLevel(-4); 
  this->mButtons[0]->SetClickEvent(ET_GUI,GUIE_PREV_PRESSED,0,true);
  CVector3 pos(0.0f,598,0.0f);
  this->mButtons[0]->SetPosition(&pos);
  //przycisk next
  this->mButtons[1] = new GUIMovingButton(936,598,230,70);
  this->mButtons[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\goforward_normal",1,10);
  this->mButtons[1]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\goforward_normal",1,10);
  this->mButtons[1]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\goforward_presed",1,10);
  this->mButtons[1]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\goforward_rollon",1,10);
  this->mButtons[1]->SetLevel(-4);
  pos.x = 796;
  this->mButtons[1]->SetPosition(&pos);
  this->mButtons[1]->SetClickEvent(ET_GUI,GUIE_NEXT_PRESSED,0,true);
  this->mButtons[0]->SetClinable(false);
  this->mButtons[1]->SetClinable(false);
  this->mStatic->SetClinable(false);
}


GUIPanelOverlay::~GUIPanelOverlay()
{
  delete this->mStatic;
  for (int i = 0 ; i < 2; i++)
  {
    delete this->mButtons[i];
  }
  delete this->mBackground;
  delete this->mBObject;
  delete this->mSiatka;
  delete this->mForeGround[0];
  delete this->mForeGround[1];
  for (int i = 0 ; i < 3; i++)
  {
    delete this->mBalls[i];
  }
}


void GUIPanelOverlay::Show()
{
  this->mVisible = true;
  if(!CGame::Instance()) // pokazuj t³o tylko jak gra nie istnieje (menu sound i video podczas gry)
  {
    this->mBackground->Show();
    this->mBObject->Show();
    this->mForeGround[0]->Show();
    this->mForeGround[1]->Show();
    for (int i = 0; i < 3 ; i++)
       this->mBalls[i]->Show(); 
    this->mSiatka->Show(); 
    this->mOverlay->Show();
  }

  for (int i = 0 ; i < 2; i++)
  {
    this->mButtons[i]->Show();
  }
  this->mStatic->Show();
}


void GUIPanelOverlay::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  for (int i = 0 ; i < 2; i++)
  {
    this->mButtons[i]->Hide();
  }
  if (this->mBackground->IsVisible())
  {
    this->mBackground->Hide();
    this->mBObject->Hide();
    this->mForeGround[0]->Hide();
    this->mForeGround[1]->Hide();
    for (int i = 0; i < 3 ; i++)
       this->mBalls[i]->Hide();
    this->mSiatka->Hide();
    this->mOverlay->Hide();
  }
}



void GUIPanelOverlay::Update()
{
  float current_time = NOW;
  for (int i = 0; i < 3 ; i++)
  { // losowanie nowych pi³ek jak sie schowaj¹ za koniec ekranu
    if (this->mBallStartTimes[i] + mBallTimes[i] < current_time)
    {
      this->mBallStartTimes[i] = current_time;
      this->mBallsY[i] = (float) (myrand(700)+68); // wspó³rzêdna ykowa
      this->mBallTimes[i] = (float) myrand(5) + 5; // czas przelotu
      this->mBallSizes[i] = (float)(myrand(97) + 45); // rozmiar pi³ek
      this->mBallDirs[i] = myrand(1) == 1;  // kierunek przelotu
    }
    float alpha = (current_time - this->mBallStartTimes[i])/ mBallTimes[i];
    if (mBallDirs) // lec¹ do przodu
    {
      this->mBalls[i]->SetDimensions(-mBallSizes[i] + alpha * (1024 + 2 * mBallSizes[i]),mBallsY[i],mBallSizes[i],mBallSizes[i]); 
    }
    else // lec¹ do ty³u
    {
      this->mBalls[i]->SetDimensions(1024+mBallSizes[i] - alpha * (1024 + 2 * mBallSizes[i]),mBallsY[i],mBallSizes[i],mBallSizes[i]); 
    }
  }
  this->mForeGround[0]->Update();
  this->mForeGround[1]->Update();
  this->mSiatka ->Update();
  for (int i = 0 ; i < 2; i++)
  {
    this->mButtons[i]->Update();
  }
  this->mBObject->Update();
}


// w³¹cza i wy³¹cza przyciski next i back
void GUIPanelOverlay::SetButtons(unsigned long button_states)
{
  if ((button_states & OBS_BUTTON_B )!= 0) 
  {
    mButtons[0]->Enable();
  }
  else
  {
    mButtons[0]->Disable();
  }
  if ((button_states & OBS_BUTTON_F) != 0)
  {
    mButtons[1]->Enable();
  }
  else
  {
    mButtons[1]->Disable();
  }
}
int GUIPanelOverlay::GetReloadCount()
{
  int i, count = this->mBackground->GetReloadCount();
  count += this->mBObject->GetReloadCount();
  for (i = 0; i < 3 ; i++)
  {
    count += this->mBalls[i]->GetReloadCount();
  }
  for (i = 0; i < 2 ; i++)
  {
    count += this->mForeGround[i]->GetReloadCount();
    count += this->mButtons[i]->GetReloadCount();
  }
  count += this->mOverlay->GetReloadCount();
  count += this->mSiatka->GetReloadCount();
  count += this->mStatic->GetReloadCount();
  return count;
}

void GUIPanelOverlay::Reload()
{
  int i;
  this->mBackground->Reload();
  this->mBObject->Reload();
  for (i = 0; i < 3 ; i++)
  {
    this->mBalls[i]->Reload();
  }
  for (i = 0; i < 2 ; i++)
  {
    this->mForeGround[i]->Reload();
    this->mButtons[i]->Reload();
  }
  this->mOverlay->Reload();
  this->mSiatka->Reload();
  this->mStatic->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIOverlay.h
#ifndef _GUIPANELOVERLAY_H
#define _GUIPANELOVERLAY_H




class GUIPanelOverlay :public GUIPanel
{
  GUIIcon *mBackground;
  GUIBackgroundObject *mBObject;
  GUIIcon *mStatic;
  GUIMovingButton *mButtons[2];
  GUIIcon *mBalls[3];
  unsigned char mBallCount;
  float mBallsY[3];
  float mBallTimes[3];
  float mBallSizes[3];
  float mBallStartTimes[3];
  bool mBallDirs[3];
  GUIMovingIcon *mForeGround[2];
  GUIIcon *mOverlay;
  GUIMovingIcon *mSiatka;
public:
  GUIPanelOverlay();
  virtual ~GUIPanelOverlay();
  void Update();
  void Show();
  void Hide();
  void SetButtons(unsigned long button_states);
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanel.cpp

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanel.h
#ifndef _GUIPANEL_H
#define _GUIPANEL_H


class GUIPanel : public GUIObject
{

public:
  GUIPanel() :GUIObject(0.0f,0.f,1.0f,1.0f,30,true) {};
  virtual ~GUIPanel() {};
  virtual void Update() = 0;
  void Render(CMatrix4 *pViewProj) {}
  virtual void ForwardPressed() {}
  virtual void BackwardPressed() {}
  virtual void GetPassedData(void * data) {}
  virtual void Reload() = 0;
  virtual int GetReloadCount() {return 0;};
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelControls.cpp


#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"

#include "..\..\core\Team.h"

#include "..\..\core\Game.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelControls.h"


// panel ustawiania sterownia

GUIPanelControls::GUIPanelControls() :EventHandler(ET_GUI_CONTROLS)
{
  this->mListenMode = false;
  // t³o
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_controls\\sriodek_controls.png");
  // górna ikona
  this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_controls\\gora_controls.png");
  // napisy
  this->mStatic2 = new GUIIcon(155,10,700,768,"GUI\\menu_controls\\przyciski_controls.png");
  this->mStatic->SetLevel(-15);
  this->mStatic2->SetLevel(-16);
// user1/ user2
  this->mHeading[0] = new GUIIcon(430,192,139,43, "GUI\\menu_controls\\user1_controls.png");
  this->mHeading[1] = new GUIIcon(430,192,139,43, "GUI\\menu_controls\\user2_controls.png");

  // przyciski odpowiadaj¹ce klawiszom 
  // i pola tekstowe z nazwami klawiszy
  int i;
  for (i = 0 ; i < 4 ; i ++)
  {

    this->mButtons[i] = new GUIButton(324,235+ 40 * (float) i,367,40);
    this->mButtons[i]->SetTexture(BS_DISABLED,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[i]->SetTexture(BS_NORMAL,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[i]->SetTexture(BS_PRESSED,"GUI\\menu_controls\\polekey_presed",1,10);
    this->mButtons[i]->SetTexture(BS_HOVER,"GUI\\menu_controls\\polekey_rollon",1,10);
    this->mButtons[i]->SetClickEvent(ET_GUI_CONTROLS,1,i,false);
    this->mKeyFields[i] = new GUITextField(584 ,256+ 40 * (float) i , 120 , 30);
    this->mKeyFields[i]->SetText("test");
  }
  
  for (i = 4; i <6 ; i ++)
  {
    this->mButtons[i] = new GUIButton(324,395+ 80 * (float)(i-4),367,80);
    this->mButtons[i]->SetTexture(BS_DISABLED,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[i]->SetTexture(BS_NORMAL,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[i]->SetTexture(BS_PRESSED,"GUI\\menu_controls\\polekey_presed",1,10);
    this->mButtons[i]->SetTexture(BS_HOVER,"GUI\\menu_controls\\polekey_rollon",1,10);
    this->mButtons[i]->SetClickEvent(ET_GUI_CONTROLS,1,i,false);
    this->mKeyFields[i] = new GUITextField(584 ,436+ 80 * (float)(i-4) , 120 , 30);
    this->mKeyFields[i]->SetText("test");

  }

   this->mButtons[6] = new GUIButton(324,555 ,367,40);
    this->mButtons[6]->SetTexture(BS_DISABLED,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[6]->SetTexture(BS_NORMAL,"GUI\\menu_controls\\polekey_normal",1,10);
    this->mButtons[6]->SetTexture(BS_PRESSED,"GUI\\menu_controls\\polekey_presed",1,10);
    this->mButtons[6]->SetTexture(BS_HOVER,"GUI\\menu_controls\\polekey_rollon",1,10);
    this->mButtons[6]->SetClickEvent(ET_GUI_CONTROLS,1,6,false);
    this->mKeyFields[6] = new GUITextField(584 ,576 , 120 , 30);
    this->mKeyFields[6]->SetText("test");

  this->mButtons[7] = new GUIButton(277,599,115,110);
  this->mButtons[7]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mButtons[7]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\backward_normal",1,10);
  this->mButtons[7]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\backward_presed",1,10);
  this->mButtons[7]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\backward_rollon",1,10);
  this->mButtons[7]->SetClickEvent(ET_GUI_CONTROLS,2,0,false);
  this->mButtons[7]->Disable();

  this->mButtons[8] = new GUIButton(635,599,115,110);
  this->mButtons[8]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mButtons[8]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\forward_normal",1,10);
  this->mButtons[8]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\forward_presed",1,10);
  this->mButtons[8]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\forward_rollon",1,10);
  this->mButtons[8]->SetClickEvent(ET_GUI_CONTROLS,2,1,false);

  this->mCurrentUserIndex = 0;
  this->mCurrentUser = UserManager::Instance()->GetUser(0);
   

}

GUIPanelControls::~GUIPanelControls()
{
  delete this->mStatic;
  delete this->mStatic2;
  delete this->mTop;
  for (int i = 0 ; i < 9; i++)
  {
    delete this->mButtons[i];
    if (i < 7)
    delete this->mKeyFields[i];
  }
  delete this->mHeading[0];
  delete this->mHeading[1];
}


void GUIPanelControls::Show()
{
  mCurrentUserIndex = 0;
  this->mCurrentUser = UserManager::Instance()->GetUser(mCurrentUserIndex);
  this->FillTextFields();
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  this->mHeading[mCurrentUserIndex]->Show();
  for (int i = 0 ; i < 7; i++)
  {
    this->mButtons[i]->Show();
    this->mKeyFields[i]->Show();
  }
  this->mStatic2->Show();
  this->mButtons[7]->Show();
  this->mButtons[8]->Show();
}


void GUIPanelControls::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mHeading[mCurrentUserIndex]->Hide();
  for (int i = 0 ; i < 7; i++)
  {
    this->mButtons[i]->Hide();
    
    this->mKeyFields[i]->Hide();
  }
  this->mStatic2->Hide();
  this->mButtons[7]->Hide();
  this->mButtons[8]->Hide();
}



void GUIPanelControls::Update()
{
  if (this->mListenMode) // tryb s³uchania - sprawdza czy jakiœ klawisz zosta³ naciœniêty i go ustawia
  {
    int key = UserManager::Instance()->GetKeypressRaw();
    if (key == -1) return;
    UserManager::Instance()->ClearKeyInUsers(key); // je¿eli ju¿ taki klawisz istnieje wyczyœæ u innych
    mCurrentUser->SetRealKey((KeyMaps)this->mListenIndex,key); // ustaw klawisz
    this->FillTextFields(); // ponownie wype³nij pola
    this->mListenMode = false; // nie wchodŸ tu wiêcej
  }
  else
  {
    for (int i = 0 ; i < 9; i++)
    {
      this->mButtons[i]->Update(); // sprawdŸ czy zostalliœmy naciœniêci
    }
  }
}


void GUIPanelControls::ProcessEvent(Event *event)
{
  if (event->mID == 1) // wejdŸ do trybu s³uchania
  {
    this->mListenMode = true;
    this->mListenIndex = event->mID2;  // dla przycisku mID2
    this->mKeyFields[this->mListenIndex]->SetText(NULL); // wyczyœæ dla niego tekst
  }
  else // zmiana usera 1/2
  {
    this->mHeading[mCurrentUserIndex]->Hide(); 
    if (event->mID2) // przycisk do przodu
    {
      this->mCurrentUserIndex = 1;
      this->mButtons[8]->Disable(); // dalej do przodu sie nie da
      this->mButtons[7]->Enable(); // ale wróciæ mo¿na
    }
    else //przycisk do ty³u
    {
      this->mCurrentUserIndex = 0;
      this->mButtons[7]->Disable(); // w ty³ nie idziemy
      this->mButtons[8]->Enable(); // jedynie na przód
    }
    this->mCurrentUser = UserManager::Instance()->GetUser(mCurrentUserIndex); // pobierz usera
    this->FillTextFields(); // wype³nij dla niego pola
    this->mHeading[mCurrentUserIndex]->Show();
  }
}


void GUIPanelControls::BackwardPressed()
{
  UserManager::Instance()->SaveInputState(); // wychodzimy wiêc zapisz input do pliku
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_OPTIONS,false,NULL);
}

// wype³nij pola tekstowe nazwami klawiszy z user managera
void GUIPanelControls::FillTextFields()
{
  for (int i = 0 ;i < 7; i++)
  {
    char *keyname;
    unsigned int key =  mCurrentUser->GetRealKey(i);
    keyname = GetNiceStringByKeybind(key);
    this->mKeyFields[i]->SetText(keyname);
  }
}


void GUIPanelControls::Reload()
{
  for (int i = 0 ; i < 9; i++)
  {
    this->mButtons[i]->Reload();
  }
  this->mTop->Reload();
  this->mStatic->Reload();
  this->mStatic2->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelControls.h
#ifndef _GUIPANELCONTROLS_H
#define _GUIPANELCONTROLS_H


class User;
class Event;

class GUIPanelControls : public GUIPanel, EventHandler
{
  GUIButton *mButtons[11];
  GUIIcon *mStatic;
  GUIIcon *mStatic2;
  GUIIcon *mTop;
  GUIIcon *mHeading[2];
  GUITextField *mKeyFields[9];
  
  unsigned char mCurrentUserIndex;
  User *mCurrentUser;
  bool mListenMode;
  unsigned char mListenIndex;

public:
  GUIPanelControls();
  virtual ~GUIPanelControls();
  void BackwardPressed();
  void Update();
  void Hide();
  void Show();
  void ProcessEvent(Event *event);
  void FillTextFields();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLadder.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\EuroLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelEuroLadder.h"


//drabinka dla euroligi 

GUIPanelEuroLadder::GUIPanelEuroLadder()
{
  int i, k;
  char buffer[256];
  // t³o
  this->mStatic = new GUIIcon(322,0,390,620,"GUI\\menu_round\\sriodek_round2.png");
  for (i = 0; i < 6; i ++)
  {
    // boczne paski z tekstem "weekend"
    my_snprintf(buffer,256,"GUI\\menu_round\\weekend%i.png",i+1);
    this->mWeekends[i] = new GUIIcon(160,120 + (float) i * 80,160,90,buffer);
    my_snprintf(buffer,256,"GUI\\menu_round\\weekend%ia.png",i+1);
    this->mWeekendsA[i] = new GUIIcon(715,120 + (float) i * 80,160,90,buffer);
  }
  memset(this->mTextbuf,0, sizeof(mTextbuf));
  memset(this->mScoreTextbuf,0, sizeof(mScoreTextbuf));
  unsigned int offs[2] =
  {
    0 , 33
  };
  int offs2[2] = 
  {
    -30,30
  };

  for(i = 0 ; i < 2; i++)
   for (int j = 0 ; j < 6; j++)
   {
     for (k = 0; k < 2 ; k++)
     { // "BRA v GRE" itp.
       this->mMatchDesc[i][j][k] = new GUITextField(412 + (float)i * 190, 132 + (float)j * 82 + offs[k],160,17);
       this->mMatchDesc[i][j][k]->SetText(this->mTextbuf[i][j][k]);
     }
     for (k = 0; k < 4 ; k++)
     {// wyniki meczy które sie odby³y
       this->mMatchScores[i][j][k] =  new GUITextField(412 + (float)i * 190 + offs2[k/2], 147 + (float)j * 82 + offs[k%2],160,17);
       this->mMatchScores[i][j][k]->SetText(this->mScoreTextbuf[i][j][k]);
     }
   }
   // przycisk pokazywania statystyk
   this->mShowStats = new GUIButton(452,668,120,50);
   this->mShowStats->SetTexture(BS_DISABLED,"GUI\\menu_round\\statistics_normal",1,10);
   this->mShowStats->SetTexture(BS_NORMAL,"GUI\\menu_round\\statistics_normal",1,10);
   this->mShowStats->SetTexture(BS_HOVER,"GUI\\menu_round\\statistics_rollon",1,10);
   this->mShowStats->SetTexture(BS_PRESSED,"GUI\\menu_round\\statistics_presed",1,10);
   this->mShowStats->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_EUROLEAGUEMATCHOVER,false);

}

GUIPanelEuroLadder::~GUIPanelEuroLadder()
{
  int i,k;
  delete this->mStatic;
  for (i = 0 ; i < 6; i++)
  {
    delete this->mWeekends[i];
    delete this->mWeekendsA[i];
  }
   for(i = 0 ; i < 2; i++)
    for (int j = 0 ; j < 6; j++)
    {
      for (k = 0; k < 2 ; k++)
      {
        delete this->mMatchDesc[i][j][k];
      }
      for (k = 0; k < 4 ; k++)
      {
        delete this->mMatchScores[i][j][k];
      }
    }

}




void GUIPanelEuroLadder::Show()
{
  if (EuroLeague::Instance()->WasMatchPlayed()) // jeœli by³  ju¿ mecz
  {
    GUI::Instance()->ResetOverlay(OBS_BUTTON_F); // wy³¹cz przycisk back
    this->mShowStats->Show(); // ale za to poka¿ statsy
  }else
  {
    memset(this->mTextbuf,0, sizeof(mTextbuf)); // wyczyœæ wszystko 
    memset(this->mScoreTextbuf,0, sizeof(mScoreTextbuf)); 
  }
  EuroLeague::Instance()->GetNextMatch();
  this->mCurrentWeekend =  EuroLeague::Instance()->GetCurrentWeekend();  

  
  this->mVisible = true;
  for(int i = 0 ; i < 2; i++)
    for (int j = 0 ; j < 6; j++)
      for (int k = 0; k < 4 ; k++)
      {
        match *temp = EuroLeague::Instance()->GetMatchByParams(i , j , k);
        if (k < 2)
        {// wype³nij pola tekstowe skrótami zespo³ów
          my_snprintf (this->mTextbuf[i][j][k],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
          this->mMatchDesc[i][j][k]->Show(); 
          char t1 = temp->sets_won[0],
               t2 = temp->sets_won[1];
          if (j < mCurrentWeekend)
          { // i wynikami (je¿eli by³ ju¿ taki mecz
            my_snprintf (this->mScoreTextbuf[i][j][k],6,"%i - %i",t1,t2);
            this->mMatchScores[i][j][k]->Show();
          }

        }else // dla dwóch "niewidzialnych" meczy - rewan¿y
        {
          char t1 = temp->sets_won[1],
               t2 = temp->sets_won[0];
          if (j < mCurrentWeekend)
          {// znowu wyœwietl jedynie jak ju¿ ten mecz by³
            my_snprintf (this->mScoreTextbuf[i][j][k],6,"%i - %i",t1,t2);
            this->mMatchScores[i][j][k]->Show();
          }
        }
      }
  
  this->mWeekends[mCurrentWeekend]->Show();  
  this->mWeekendsA[mCurrentWeekend]->Show();  
  
  this->mStatic->Show();
}


void GUIPanelEuroLadder::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mWeekends[mCurrentWeekend]->Hide();  
  this->mWeekendsA[mCurrentWeekend]->Hide();  
  for(int i = 0 ; i < 2; i++)
    for (int j = 0 ; j < 6; j++)
      for (int k = 0; k < 4 ; k++)
      {
        if (k < 2)
          this->mMatchDesc[i][j][k]->Hide();
        this->mMatchScores[i][j][k]->Hide();
      }
  if (this->mShowStats->IsVisible())
  {
    this->mShowStats->Hide();
  }
}


void GUIPanelEuroLadder::ForwardPressed()
{
  POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,0,false,NULL);
}

void GUIPanelEuroLadder::BackwardPressed()
{
  if (!EuroLeague::Instance()->WasMatchPlayed()) // je¿eli jeszcze nie by³o meczu
  {
    delete EuroLeague::Instance(); // kasujemy eurolige i wracamy do wyboru gry
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false,NULL);
  }
}


void GUIPanelEuroLadder::Update()
{
  if (this->mShowStats->IsVisible())
  {
    this->mShowStats->Update();
  }
}


void GUIPanelEuroLadder::Reload()
{
  for (int i = 0 ; i < 6 ;i ++)
  {
    this->mWeekends[i]->Reload();
    this->mWeekendsA[i]->Reload();
  }
  this->mStatic->Reload();
  this->mShowStats->Reload();
}

int GUIPanelEuroLadder::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  for (int i = 0 ; i < 6 ;i ++)
  {
    count += this->mWeekends[i]->GetReloadCount();
    count += this->mWeekendsA[i]->GetReloadCount();
  }
  count += this->mShowStats->GetReloadCount();
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLadder.h
#ifndef _GUIPANELEUROLADDER_H
#define _GUIPANELEUROLADDER_H


class GUIPanelEuroLadder : public GUIPanel
{
  GUIIcon *mStatic;
  GUIIcon  *mWeekends[6];
  GUIIcon  *mWeekendsA[6];
  unsigned char mCurrentWeekend;
  char mTextbuf[2][6][2][10];
  char mScoreTextbuf[2][6][4][6];
  GUITextField *mMatchDesc[2][6][2];
  GUITextField *mMatchScores[2][6][4];
  GUIButton    *mShowStats;
public:
  GUIPanelEuroLadder(); 
  ~GUIPanelEuroLadder();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLeague.cpp


#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"

#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"
#include "..\..\core\EuroLeague.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\Renderer.h"
#include "..\MeshManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelEuroLeague.h"


// panel wyboru reprezentacji do euroligi
GUIPanelEuroLeague::GUIPanelEuroLeague() :EventHandler(ET_GUI_EUROLEAGUE)
{
  // t³o
 this->mStatic = new GUIIcon(150,10,700,768,"GUI\\menu_reprezentation\\sriodek_reprezentation.png");
 this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_reprezentation\\gora_reprezentation.png");
 this->mCurrentFlag = 0;
 char buffer[256];

 // flagi jako odddzielne ikony
 for(int i = 0 ; i < 8; i++)
 {
   my_snprintf(buffer,256,"GUI\\menu_reprezentation\\%s2.png", team3let[i+12]);  
   this->mFlags[i] = new GUIIcon(380,443,240,130,buffer);
 }
 this->mTeamDesc = new GUITextField(500,380,300,40);
 // przyciski wyboru flag
 this->mSwitches[0] = new GUIButton(262,606,115,110);
 this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
 this->mSwitches[0]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\backward_normal",1,10);
 this->mSwitches[0]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\backward_presed",1,10);
 this->mSwitches[0]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\backward_rollon",1,10);
 this->mSwitches[0]->SetClickEvent(ET_GUI_EUROLEAGUE,2,0,false);
 
 this->mSwitches[1] = new GUIButton(622,606,115,110);
 this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
 this->mSwitches[1]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\forward_normal",1,10);
 this->mSwitches[1]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\forward_presed",1,10);
 this->mSwitches[1]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\forward_rollon",1,10);
 this->mSwitches[1]->SetClickEvent(ET_GUI_EUROLEAGUE,2,1,false); 
 
}


GUIPanelEuroLeague::~GUIPanelEuroLeague()
{
 int i;
 delete this->mStatic;
 delete this->mTop; 
 for(i = 0 ; i < 8 ; i++)
 {
   delete this->mFlags[i];
 }
 
 for(i = 0 ; i < 2 ; i++)
 {
   delete this->mSwitches[i];
 }
 delete this->mTeamDesc;
}


void GUIPanelEuroLeague::Show()
{
  
  this->mStatic->Show();
  this->mTop->Show();
  this->mFlags[mCurrentFlag]->Show();
  this->mSwitches[0]->Show();
  this->mSwitches[1]->Show();
  this->mTeamDesc->Show();
}



void GUIPanelEuroLeague::Hide()
{
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mFlags[mCurrentFlag]->Hide();
  this->mSwitches[0]->Hide();
  this->mSwitches[1]->Hide();
  this->mTeamDesc->Hide();
}


void GUIPanelEuroLeague::Update()
{
  this->mSwitches[0]->Update();
  this->mSwitches[1]->Update();
  this->mTeamDesc->SetText(teamNames[this->mCurrentFlag+12]);
}
void GUIPanelEuroLeague::ProcessEvent(Event *event)
{
  if (event->mID == 2) // jeœli przycisk przesuniêcia flagi
  {
    this->mFlags[mCurrentFlag]->Hide(); // aktualn¹ ukryj
    if (event->mID2 == 1) // je¿eli do przodu
    {
      mCurrentFlag++; // zwiêksz
      if (mCurrentFlag == 8) mCurrentFlag = 0;// i jeœli trzeba zawiñ
    }
    else // jeœli do ty³u
    {
      if (mCurrentFlag == 0) mCurrentFlag = 7;// jeœli zero to zawiñ 
      else // jeœli nie to zmniejsz
        mCurrentFlag--;
    }
    this->mFlags[mCurrentFlag]->Show(); // poka¿ t¹ która jest
  }
}


void GUIPanelEuroLeague::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false,NULL);
}


void GUIPanelEuroLeague::ForwardPressed()
{
  new EuroLeague((eTeams) (mCurrentFlag+12));
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_EUROLEAGUEMAIN,false,NULL);
}


void GUIPanelEuroLeague::Reload()
{
  this->mStatic->Reload();
  this->mSwitches[0]->Reload();
  this->mSwitches[1]->Reload();
  this->mTop->Reload();
  for (int i = 0 ; i < 8 ; i++)
  {
    this->mFlags[i]->Reload();
  }
}

int GUIPanelEuroLeague::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  count += this->mSwitches[0]->GetReloadCount();
  count += this->mSwitches[1]->GetReloadCount();
  count += this->mTop->GetReloadCount();
  for (int i = 0 ; i < 8 ; i++)
  {
    count += this->mFlags[i]->GetReloadCount();
  }
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLeague.h
#ifndef _GUIPANELEUROLEAGUE_H
#define _GUIPANELEUROLEAGUE_H



class GUIPanelEuroLeague :public GUIPanel, public EventHandler
{
 GUIIcon *mStatic;
 GUIIcon *mTop;
 GUIIcon *mFlags[8];
 GUIButton *mSwitches[2];
 unsigned char mCurrentFlag;
 GUITextField *mTeamDesc; 
public:
  void ProcessEvent(Event *event);
  GUIPanelEuroLeague();
  virtual ~GUIPanelEuroLeague();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};





#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLeagueStats.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\EuroLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelEuroLeagueStats.h"


GUIPanelEuroLeagueStats::GUIPanelEuroLeagueStats()
{
//  char buffer[256];
  this->mStatic = new GUIIcon(77,-15,869,586,"GUI\\menu_statistics\\statistics2.png");

  memset(this->mTextbuf,0, sizeof(mTextbuf));
  for(int i = 0 ; i < 8; i++)
  {
    // skróty zespo³ów w rankingach
    this->mFields[i][0] = new GUITextField(151,205 + (float)i *29,100,23);
    this->mFields[i][1] = new GUITextField(865,205 + (float)i *29,100,23);
    for (int j = 0 ; j < 6; j++)
    {// wartoœci 
      this->mStats[i][j] = new GUITextField(265 + (float)j * 95, 205 + (float)i * 29 ,80, 23);
      this->mStats[i][j]->SetText(this->mTextbuf[i][j]);
    }
  }
}

GUIPanelEuroLeagueStats::~GUIPanelEuroLeagueStats()
{
  delete this->mStatic;
  for(int i = 0 ; i < 8; i++)
  {
    delete this->mFields[i][0];
    delete this->mFields[i][1];
    for (int j = 0 ; j < 6; j++)
      {
        delete this->mStats[i][j];
      }
  }
}





void GUIPanelEuroLeagueStats::Show()
{
  EuroLeague::Instance()->GetNextMatch();
  this->mVisible = true;
  this->mStatic->Show();
  for(int i = 0 ; i < 8; i++)
  {
    ranking *temp = EuroLeague::Instance()->GetTeamByRanking(i /4 , i % 4);
    // w ka¿de z pól wydrukuj odpowiedni parametr
    my_snprintf(this->mTextbuf[i][0], 5, "%i",temp->matches_won);  
    my_snprintf(this->mTextbuf[i][1], 5, "%i",temp->matches_lost);
    my_snprintf(this->mTextbuf[i][2], 5, "%i",temp->sets_won);
    my_snprintf(this->mTextbuf[i][3], 5, "%i",temp->sets_lost);
    my_snprintf(this->mTextbuf[i][4], 5, "%i",temp->points_won);
    my_snprintf(this->mTextbuf[i][5], 5, "%i",temp->points_lost);
    this->mFields[i][0]->SetText(team3let[temp->team]); 
    this->mFields[i][1]->SetText(team3let[temp->team]);
    this->mFields[i][0]->Show();
    this->mFields[i][1]->Show();
    for (int j = 0 ; j < 6; j++)
      this->mStats[i][j]->Show(); 
  }
}


void GUIPanelEuroLeagueStats::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  for(int i = 0 ; i < 8; i++)
  {
    this->mFields[i][0]->Hide();
    this->mFields[i][1]->Hide();
    for (int j = 0 ; j < 6; j++)
    {
      this->mStats[i][j]->Hide();
    }
  }
}

void GUIPanelEuroLeagueStats::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_EUROLEAGUEMAIN,false,NULL);
}

void GUIPanelEuroLeagueStats::Reload()
{ 
  this->mStatic->Reload();
}

int GUIPanelEuroLeagueStats::GetReloadCount()
{ 
  return this->mStatic->GetReloadCount();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelEuroLeagueStats.h
#ifndef _GUIPANELEUROLEAGUESTATS_H
#define _GUIPANELEUROLEAGUESTATS_H


class GUIPanelEuroLeagueStats : public GUIPanel
{
  GUIIcon *mStatic;
  char mTextbuf[8][6][5];
  GUITextField *mStats[8][6];
  GUITextField *mFields[8][2];
public:
  GUIPanelEuroLeagueStats(); 
  ~GUIPanelEuroLeagueStats();
  void Show();
  void Hide();
  void Update(){};
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelFriendly.cpp


#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"

#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelFriendly.h"


/*char *flagFiles[] =
{
  "GUI\\menu_friendly\\bra.png",
  "GUI\\menu_friendly\\gre.png",
  "GUI\\menu_friendly\\esp.png",
  "GUI\\menu_friendly\\por.png",
  "GUI\\menu_friendly\\fra.png",
  "GUI\\menu_friendly\\bul.png",
  "GUI\\menu_friendly\\jpn.png",
  "GUI\\menu_friendly\\pol.png",
  "GUI\\menu_friendly\\ita.png",
  "GUI\\menu_friendly\\chn.png",
  "GUI\\menu_friendly\\scg.png",
  "GUI\\menu_friendly\\cub.png",
  "GUI\\menu_friendly\\rus.png",
  "GUI\\menu_friendly\\cze.png",
  "GUI\\menu_friendly\\cro.png",
  "GUI\\menu_friendly\\tur.png",
  "GUI\\menu_friendly\\ger.png",
  "GUI\\menu_friendly\\ned.png",
  "GUI\\menu_friendly\\fin.png",
  "GUI\\menu_friendly\\svk.png"
};*/
GUIPanelFriendly::GUIPanelFriendly() :EventHandler(ET_GUI_FRIENDLY)
{
 this->mStatic = new GUIIcon(150,10,700,768,"GUI\\menu_friendly\\sriodek_friendly.png");
 this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_friendly\\gora_friendly.png");
 this->mCurrentFlags[0] = 0;
 this->mCurrentFlags[1] = 1;
 this->mAiState =1;
 char buffer[256];
 for(int i = 0 ; i < 20 ; i++)
 {
   my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",team3let[i]);
   this->mFlags[0][i] = new GUIIcon(332,472,122,64,buffer);
   this->mFlags[1][i] = new GUIIcon(550,472,122,64,buffer);
 }
 this->mTeamDesc[0] = new GUITextField(393,432,80,30);
 this->mTeamDesc[1] = new GUITextField(611,432,80,30);

 this->mFlagSelectors[0] = new GUIButton(327,467,132,74);
 this->mFlagSelectors[1] = new GUIButton(545,467,132,74);
 this->mFlagSelectors[0]->SetLevel(-10); 
 this->mFlagSelectors[1]->SetLevel(-10);
 this->mFlagSelectors[0]->SetTexture(BS_DISABLED,"GUI\\menu_friendly\\flaga_normal",1,10);
 this->mFlagSelectors[0]->SetTexture(BS_NORMAL  ,"GUI\\menu_friendly\\flaga_presed",1,10);
 this->mFlagSelectors[0]->SetTexture(BS_HOVER   ,"GUI\\menu_friendly\\flaga_rollon",1,10);
 this->mFlagSelectors[0]->SetTexture(BS_PRESSED ,"GUI\\menu_friendly\\flaga_normal",1,10);
 this->mFlagSelectors[0]->SetClickEvent(ET_GUI_FRIENDLY,1,0,false);
 this->mFlagSelectors[1]->SetTexture(BS_DISABLED,"GUI\\menu_friendly\\flaga_normal",1,10);
 this->mFlagSelectors[1]->SetTexture(BS_NORMAL  ,"GUI\\menu_friendly\\flaga_normal",1,10);
 this->mFlagSelectors[1]->SetTexture(BS_HOVER   ,"GUI\\menu_friendly\\flaga_rollon",1,10);
 this->mFlagSelectors[1]->SetTexture(BS_PRESSED ,"GUI\\menu_friendly\\flaga_normal",1,10);
 this->mFlagSelectors[1]->SetClickEvent(ET_GUI_FRIENDLY,1,1,false);
 
 this->mSwitches[0] = new GUIButton(262,606,115,110);
 this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
 this->mSwitches[0]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\backward_normal",1,10);
 this->mSwitches[0]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\backward_presed",1,10);
 this->mSwitches[0]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\backward_rollon",1,10);
 this->mSwitches[0]->SetClickEvent(ET_GUI_FRIENDLY,2,0,false);
 this->mSwitches[0]->Disable();
 this->mSwitches[1] = new GUIButton(622,606,115,110);
 this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
 this->mSwitches[1]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\forward_normal",1,10);
 this->mSwitches[1]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\forward_presed",1,10);
 this->mSwitches[1]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\forward_rollon",1,10);
 this->mSwitches[1]->SetClickEvent(ET_GUI_FRIENDLY,2,1,false); 
 this->mSwitches[1]->Disable();

 this->mAiButtons[0] = new GUIButton(432,310,150,40);
 this->mAiButtons[1] = new GUIButton(432,310,150,40);
 this->mAiButtons[0]->SetTexture(BS_DISABLED,"GUI\\menu_friendly\\ludvslud_normal",1,10);
 this->mAiButtons[0]->SetTexture(BS_NORMAL,"GUI\\menu_friendly\\ludvslud_normal",1,10);
 this->mAiButtons[0]->SetTexture(BS_PRESSED,"GUI\\menu_friendly\\ludvslud_presed",1,10);
 this->mAiButtons[0]->SetTexture(BS_HOVER,"GUI\\menu_friendly\\ludvslud_rollon",1,10);
 this->mAiButtons[0]->SetClickEvent(ET_GUI_FRIENDLY,3,1,false);
 this->mAiButtons[0]->Disable();
 this->mAiButtons[1]->SetTexture(BS_DISABLED,"GUI\\menu_friendly\\ludvskomp_normal",1,10);
 this->mAiButtons[1]->SetTexture(BS_NORMAL,"GUI\\menu_friendly\\ludvskomp_normal",1,10);
 this->mAiButtons[1]->SetTexture(BS_PRESSED,"GUI\\menu_friendly\\ludvskomp_presed",1,10);
 this->mAiButtons[1]->SetTexture(BS_HOVER,"GUI\\menu_friendly\\ludvskomp_rollon",1,10);
 this->mAiButtons[1]->SetClickEvent(ET_GUI_FRIENDLY,3,0,false);
 this->mAiButtons[1]->Disable();

}


GUIPanelFriendly::~GUIPanelFriendly()
{
  delete this->mStatic;
 int i; 
 for(i = 0 ; i < 20 ; i++)
 {
   delete this->mFlags[0][i];
   delete this->mFlags[1][i];
 }
 delete this->mTop;
 for(i = 0 ; i < 2 ; i++)
 {
   delete this->mFlagSelectors[i];
   delete this->mSwitches[i];
   delete this->mAiButtons[i];
   delete this->mTeamDesc[i];
 }
}


void GUIPanelFriendly::Show()
{
  this->mSelected = -1;
  this->mStatic->Show();
  this->mTop->Show();
  this->mFlagSelectors[0]->Enable(); 
  this->mFlagSelectors[1]->Enable();
  this->mFlagSelectors[0]->Show();
  this->mFlagSelectors[1]->Show();
  this->mFlags[0][mCurrentFlags[0]]->Show();
  this->mFlags[1][mCurrentFlags[1]]->Show();
  this->mSwitches[0]->Disable();
  this->mSwitches[1]->Disable();
  this->mSwitches[0]->Show();
  this->mSwitches[1]->Show();
  this->mTeamDesc[0]->Show();
  this->mTeamDesc[1]->Show();
  this->mAiButtons[mAiState]->Show();
  this->mAiButtons[mAiState]->Enable();
}



void GUIPanelFriendly::Hide()
{
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mFlagSelectors[0]->Hide();
  this->mFlagSelectors[1]->Hide();
  this->mFlags[0][mCurrentFlags[0]]->Hide();
  this->mFlags[1][mCurrentFlags[1]]->Hide();
  this->mSwitches[0]->Hide();
  this->mSwitches[1]->Hide();
  this->mTeamDesc[0]->Hide();
  this->mTeamDesc[1]->Hide();
  this->mAiButtons[mAiState]->Hide();
  this->mAiButtons[mAiState]->Disable();
}


void GUIPanelFriendly::Update()
{
  this->mFlagSelectors[0]->Update();
  this->mFlagSelectors[1]->Update();
  this->mSwitches[0]->Update();
  this->mSwitches[1]->Update();
  this->mAiButtons[0]->Update();
  this->mAiButtons[1]->Update();
  this->mTeamDesc[0]->SetText(team3let[this->mCurrentFlags[0]]);
  this->mTeamDesc[1]->SetText(team3let[this->mCurrentFlags[1]]);
}
void GUIPanelFriendly::ProcessEvent(Event *event)
{
  if (event->mID == 1)
  {
    if (this->mSelected >= 0)
    {
      this->mFlagSelectors[mSelected]->Enable();
    }
    this->mSelected = event->mID2;
    this->mFlagSelectors[mSelected]->Disable();
    this->mSwitches[0]->Enable();
    this->mSwitches[1]->Enable();
  }
  else
    if (event->mID == 2)
    {
      int other = mSelected ? 0 : 1;
      if (this->mSelected < 0) return;
      this->mFlags[mSelected][mCurrentFlags[mSelected]]->Hide();
      if (event->mID2 == 1)
      {
       mCurrentFlags[mSelected]++;
       if (mCurrentFlags[mSelected] == mCurrentFlags[other]) mCurrentFlags[mSelected]++;
       mCurrentFlags[mSelected] = mCurrentFlags[mSelected] %20;
       if (mCurrentFlags[mSelected] == mCurrentFlags[other]) mCurrentFlags[mSelected]++;

       mCurrentFlags[mSelected] = mCurrentFlags[mSelected] %20;
      }
      else
      {
        if (mCurrentFlags[mSelected] == 0) 
        {
           if (mCurrentFlags[other] == 19)
             mCurrentFlags[mSelected] = 18;
           else
             mCurrentFlags[mSelected] = 19;
        }
        else
        {
          mCurrentFlags[mSelected]--;
          if (mCurrentFlags[mSelected] ==  mCurrentFlags[other])
          {
            if(mCurrentFlags[mSelected])
              mCurrentFlags[mSelected]--;
            else
              mCurrentFlags[mSelected] = 19;
          }
        }
      }
      this->mFlags[mSelected][mCurrentFlags[mSelected]]->Show();
    }
    else if (event->mID == 3)
    {
      this->mAiButtons[mAiState]->Hide();
      this->mAiButtons[mAiState]->Disable();
      mAiState = event->mID2;
      this->mAiButtons[mAiState]->Show();
      this->mAiButtons[mAiState]->Enable();
    }
    GUI::Instance()->ReAddCursorToScene();
}


void GUIPanelFriendly::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false,NULL);
}


void GUIPanelFriendly::ForwardPressed()
{
  union _u
  {
    char c[4];
    unsigned long l;
  }u;
  u.c[0] = this->mCurrentFlags[0];
  u.c[1] = this->mCurrentFlags[1];
  u.c[2] = this->mAiState; 
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_STADIUMS,false,new unsigned long(u.l));
}


void GUIPanelFriendly::Reload()
{
  this->mStatic->Reload();
  this->mSwitches[0]->Reload();
  this->mSwitches[1]->Reload();
  for (int i = 0 ; i < 20 ; i ++)
  {
    this->mFlags[0][i]->Reload();
    this->mFlags[1][i]->Reload();
  }
  this->mTop->Reload();
  this->mFlagSelectors[0]->Reload();
  this->mFlagSelectors[1]->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelFriendly.h
#ifndef _GUIPANELFIRENDLY_H
#define _GUIPANELFIRENDLY_H


class GUIPanelFriendly :public GUIPanel, public EventHandler
{
 GUIIcon *mStatic;
 GUIIcon *mTop;
 GUIButton *mFlagSelectors[2];
 GUIIcon *mFlags[2][20];
 GUIButton *mSwitches[2];
 GUITextField *mTeamDesc[2];
 unsigned char mCurrentFlags[2];
 GUIButton *mAiButtons[2];
 unsigned char mAiState;
 char mSelected;
public:
  void ProcessEvent(Event *event);
  GUIPanelFriendly();
  virtual ~GUIPanelFriendly();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelGamePlay.cpp
#include "..\..\config.h"


#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\utility\tools.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"

#include "..\MeshManager.h"
#include "GUIItems.h"
#include "GUIPanelGamePlay.h"

GUIPanelGamePlay::GUIPanelGamePlay()
{
  for(int i = 0; i < 5;i++)
  {
    this->mSetBalls[i] = new GUIIcon(90 + (float)i *20,85,16,16,"GUI\\pilka_set.png");
  }
  mScoreCounter[0] = new GUINumbers(180,24,22,22,"score",2);
  mScoreCounter[1] = new GUINumbers(180,54,22,22,"score",2);

  this->mScoreBackground = new GUIIcon(40,20,194,60,"GUI\\ramka_wyniki.png");

  this->mTeams[0] = new GUITextField(80,35,112,22,ALIGN_LEFT);
  this->mTeams[1] = new GUITextField(80,65,112,22,ALIGN_LEFT);

  this->mServeBalls[0] = new  GUIIcon(18,25,20,20,"GUI\\pilka_zagrywka.png");
  this->mServeBalls[1] = new  GUIIcon(18,55,20,20,"GUI\\pilka_zagrywka.png");

  this->mFlags[0] = new GUIIcon(43,27,36,18,"GUI\\menu_friendly\\bra.png");
  this->mFlags[1] = new GUIIcon(43,57,36,18,"GUI\\menu_friendly\\bra.png");

  this->mServingSide = -1;
  this->mSetIcon =  new GUIIcon(40,82,50,22, "GUI\\set.png");
  this->mSlider = new GUIForceSlider(824,668,170,25);
}

GUIPanelGamePlay::~GUIPanelGamePlay()
{
  int i;
  if (mVisible) Hide();
  for (i = 0 ; i < 5 ; i++)
    delete this->mSetBalls[i];
  delete this->mScoreBackground;
  for (i = 0 ; i < 2; i++)
  {
    delete mScoreCounter[i];
    delete this->mTeams[i];
    delete this->mFlags[i];
  }
  delete this->mSlider;
  delete this->mSetIcon;
}


void GUIPanelGamePlay::Hide()
{
  if (this->mScoreCounter[0]->IsVisible())
  {
    this->mScoreCounter[0]->Hide();
    this->mScoreCounter[1]->Hide();
  }
  
    for (int i = 0 ; i < 5; i++)
    {
      if (this->mSetBalls[i]->IsVisible())
        this->mSetBalls[i]->Hide();
    }
    if (this->mServeBalls[0]->IsVisible())
      this->mServeBalls[0]->Hide();

    if (this->mServeBalls[1]->IsVisible())
      this->mServeBalls[1]->Hide();
    if (this->mSlider->IsVisible())
      this->mSlider->Hide();
    this->mScoreBackground->Hide();
    this->mSetIcon->Hide(); 
    if (this->mTeams[0]->IsVisible())
    {
      this->mTeams[0]->Hide();
      this->mTeams[1]->Hide();
    }
    this->mFlags[0]->Hide();
    this->mFlags[1]->Hide();

}

void GUIPanelGamePlay::Show()
{
  // ustawia nazwe zespo³ów do okienka z wynikami
  this->mTeams[0]->SetText(CGame::Instance()->GetTeamShortName(0)); 
  this->mTeams[1]->SetText(CGame::Instance()->GetTeamShortName(1)); 

  this->mTeams[0]->Show();
  this->mTeams[1]->Show();
  this->mScoreBackground->Show();
  this->mScoreCounter[0]->Show();
  this->mScoreCounter[1]->Show();
  this->mSetIcon->Show(); 
  
  char buffer[256]; // wczytaj flagi i wyœwietl
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(0)); 
  HTexture t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[0]->SetTexture(t);
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(1));
  t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[1]->SetTexture(t);
  this->mFlags[0]->Show();
  this->mFlags[1]->Show();
}


void GUIPanelGamePlay::Update()
{
  if (CGame::Instance() == NULL) return;
  SetStruct *set = CGame::Instance()->GetSetScores();
  // koniec seta
  if (CGame::Instance()->ShouldDisplaySetOver())
  {// wyœwietl seta
     POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SETOVER,false,NULL);
     return;
  }
  if (CGame::Instance()->IsMatchOver())
  {// koniec meczu wyœwietl koneic meczu
     POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_MATCHOVER,false,NULL);
     return;
  }
  if (GUI::Instance()->mEscPressed)
  {// rzpejdŸ do menu w grze
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_INGAMEMENU,false,NULL);
    return;
  }
  unsigned char gp = CGame::Instance()->GetGamePhase();
  if (gp == GP_LIGHTS) // jeœli nikt nie serwuje ani nie gra
  {
    if (this->mServingSide != -1) // jeœli zosta³a ju¿ któraœ pi³ka serwowania pokazana
    {
      this->mServeBalls[this->mServingSide]->Hide(); // to j¹ ukryj 
      this->mServingSide = -1; // i wyczyœæ
    }
  }
  else
  {
    if (gp < GP_GAMEPLAY && gp != this->mServingSide) // jeœli jest któraœ z faz serwuj¹cych
    { // i nie jest to ta sama co by³a
      if (this->mServingSide != -1) // jeœli nie by³a ukrtya
      {
        this->mServeBalls[this->mServingSide]->Hide(); // to j¹ ukryj
      }
      this->mServingSide  = gp; //i poka¿ now¹
      this->mServeBalls[this->mServingSide]->Show();
    }
  }
      
  for (int i = 0 ; i < CGame::Instance()->GetCurrentSet()+1; i++)
  {// poka¿ wszystkie do obecnego seta
    if (!this->mSetBalls[i]->IsVisible())
        this->mSetBalls[i]->Show();
  }

  // wype³nij wyniki
  this->mScoreCounter[0]->SetNumber(set[CGame::Instance()->GetCurrentSet()].Score[0]); 
  this->mScoreCounter[1]->SetNumber(set[CGame::Instance()->GetCurrentSet()].Score[1]);

  // i upewnij sie ¿e trzeba pokazaæ force slider
  if (GUI::Instance()->mForceSliderVisible && !this->mSlider->IsVisible())
  {
    this->mSlider->Show();
  }
  // albo go np. ukryæ
  if (!GUI::Instance()->mForceSliderVisible && this->mSlider->IsVisible())
  {
    this->mSlider->Hide();
  }
  // tak czy tak - zupdateowaæ warto
  this->mSlider->Update();
}


void GUIPanelGamePlay::Reload()
{
  this->mScoreBackground->Reload();
  this->mScoreCounter[0]->Reload();
  this->mServeBalls[0]->Reload();
  this->mSetBalls[0]->Reload();
  this->mSetIcon->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelGamePlay.h
#ifndef _GUIPANELGAMEPLAY_H
#define _GUIPANELGAMEPLAY_H




class GUIPanelGamePlay : public GUIPanel
{
  GUIIcon          *mScoreBackground;
  GUIIcon          *mSetBalls[5];
  GUIIcon          *mServeBalls[2];
  GUIIcon          *mFlags[2];
  GUITextField     *mTeams[2];  
  GUINumbers       *mScoreCounter[2];
  char              mServingSide;
  GUIIcon          *mSetIcon;
  GUIForceSlider   *mSlider;
public:
  GUIPanelGamePlay();
  ~GUIPanelGamePlay();
  void Show();
  void Hide();
  void Update();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelInGameMenu.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelInGameMenu.h"

char *InGameMenuItems[] =
{
  "continue",
  "sound",
  "video",
  "exit"
};
char *bStates[] =
{
  "normal",
  "presed",
  "rollon",
  "normal",
};

GUIPanelInGameMenu::GUIPanelInGameMenu()
{
  this->mInGameMenuBackground = new GUIIcon(100,100,824,568, "GUI\\menu_pauza\\sriodek_pauzaa.png");
  float w[] =
  {
    385.0f, 252.0f, 280.0f, 309.0f
  };
  char buffer[256];
  for (int i = 0 ; i < 4; i++)
  {
    buffer[256];
    this->mButtons[i] = new GUIButton (300.0f, 200.0f + (float)i * 100 , w[i] , 50);
    for (int j = 0; j < 4 ; j++)
    {
      my_snprintf(buffer,256,"GUI\\menu_pauza\\%s_%s",InGameMenuItems[i],bStates[j]);
      this->mButtons[i]->SetTexture((eButtonStates) j, buffer,1,10);
    }
  }
  this->mButtons[0]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_GAMEPLAY,false);
  this->mButtons[1]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_SOUND,false);
  this->mButtons[2]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_VIDEO,false);
  this->mButtons[3]->SetClickEvent(ET_GLOBAL,GEID_FORCE_END_GAME,0,false);
  this->mButtons[0]->SetClinable(false);
  this->mButtons[1]->SetClinable(false);
  this->mButtons[2]->SetClinable(false);
  this->mButtons[3]->SetClinable(false);
  this->mInGameMenuBackground->SetClinable(false);
}

GUIPanelInGameMenu::~GUIPanelInGameMenu()
{
  delete mInGameMenuBackground;
}



void GUIPanelInGameMenu::Show()
{
  mInGameMenuBackground->Show();
  for (int i = 0; i < 4; i++ )
    this->mButtons[i]->Show();
}


void GUIPanelInGameMenu::Hide()
{
  mInGameMenuBackground->Hide();
  for (int i = 0; i < 4; i++ )
    this->mButtons[i]->Hide();
}


void GUIPanelInGameMenu::Update()
{
  if (GUI::Instance()->mEscPressed)
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_GAMEPLAY,false,NULL);
    return;
  }
  for (int i = 0; i < 4; i++ )
    this->mButtons[i]->Update();
}

void GUIPanelInGameMenu::Reload()
{


}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelInGameMenu.h
#ifndef _GUIPANELINGAMEMENU_H
#define _GUIPANELINGAMEMENU_H


class GUIPanelInGameMenu : public GUIPanel
{
  GUIIcon          *mInGameMenuBackground;
  GUIButton        *mButtons[4];
public:
  GUIPanelInGameMenu(); 
  ~GUIPanelInGameMenu();
  void Show();
  void Hide();
  void Update();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelLeagueOver.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\core\EuroLeague.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\MeshManager.h"
#include "..\Renderer.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelLeagueOver.h"


GUIPanelLeagueOver::GUIPanelLeagueOver()
{
  this->mLeagueOverBackground[0] = new GUIIcon(100,100,824,568, "GUI\\results_european_lague.png");
  this->mLeagueOverBackground[1] = new GUIIcon(100,100,824,568, "GUI\\results_World_lague.png");
  this->mFlags[0] = new GUIIcon(345,236,335,175,"Quad.gif");
  this->mFlags[1] = new GUIIcon(223,440,169,88,"Quad.gif");
  this->mFlags[2] = new GUIIcon(643,441,166,85,"Quad.gif");
 
  char buffer[256];
  for (int i = 0; i < 20 ; i ++)
  {
    my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",team3let[i]);
    this->mFlagTex[i] = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  //  CMeshManager::Instance()->SetTextureClinable(this->mFlagTex[i], false);
  }
  this->mFlags[0]->SetTexture(mFlagTex[0]);
  this->mFlags[1]->SetTexture(mFlagTex[0]);
  this->mFlags[2]->SetTexture(mFlagTex[0]); 
  this->mTeamDesc[0] = new GUITextField(512,214,335,40);
  this->mTeamDesc[1] = new GUITextField(307,425,169,30);
  this->mTeamDesc[2] = new GUITextField(726,425,166,25);
}

GUIPanelLeagueOver::~GUIPanelLeagueOver()
{
  delete mLeagueOverBackground[0];
  delete mLeagueOverBackground[1];
  for (int i = 0; i < 3 ; i ++)
  {
    delete this->mFlags[i];
    delete this->mTeamDesc[i];
  }
}



void GUIPanelLeagueOver::Show()
{
  match *firstsec;
  match *thirdfourth;
  if (WorldLeague::Instance())
  {
     mLeagueOverBackground[1]->Show();
     firstsec  = WorldLeague::Instance()->GetFinalMatch(2,1);
     thirdfourth =  WorldLeague::Instance()->GetFinalMatch(2,0);
  }
  if (EuroLeague::Instance())
  {
     mLeagueOverBackground[1]->Show();
     firstsec  = EuroLeague::Instance()->GetFinalMatch(2,1);
     thirdfourth =  EuroLeague::Instance()->GetFinalMatch(2,0);
  }
  int first,sec,third;
  first = firstsec->teams[firstsec->winner];
  sec = firstsec->teams[firstsec->loser];
  third = thirdfourth->teams[thirdfourth->winner];
  HTexture t = this->mFlagTex[first];
  this->mFlags[0]->SetTexture(t);
  t = this->mFlagTex[sec];
  this->mFlags[1]->SetTexture(t);
  t = this->mFlagTex[third];
  this->mFlags[2]->SetTexture(t);

  this->mTeamDesc[0]->SetText(teamNames[first]);
  this->mTeamDesc[1]->SetText(teamNames[sec]);
  this->mTeamDesc[2]->SetText(teamNames[third]);
  for (int i = 0 ; i < 3 ; i++)
  {
    this->mFlags[i]->Show();
    this->mTeamDesc[i]->Show();
  }
}


void GUIPanelLeagueOver::Hide()
{ 
  if (mLeagueOverBackground[1]->IsVisible())
  {
     mLeagueOverBackground[1]->Hide();
  }
  if (mLeagueOverBackground[0]->IsVisible())
  {
    mLeagueOverBackground[0]->Hide();
  }
  for (int i = 0 ; i < 3 ; i++)
  {
    this->mFlags[i]->Hide();
    this->mTeamDesc[i]->Hide();
  }
}


void GUIPanelLeagueOver::Update()
{
  if (UserManager::Instance()->GetKeypressRaw(true) != -1)
  {
    POST_EVENT2(ET_GLOBAL,GEID_FORCE_END_GAME,0,false,NULL);
    return;
  }
}


void GUIPanelLeagueOver::Reload()
{
  for (int i = 0 ; i < 20 ; i++)
  {
    CMeshManager::Instance()->GetTexture(this->mFlagTex[i])->Load(Renderer::Instance()->GetDevice());
  }
  this->mLeagueOverBackground[0]->Reload();
  this->mLeagueOverBackground[1]->Reload();
}

int GUIPanelLeagueOver::GetReloadCount()
{
  int count = this->mLeagueOverBackground[0]->GetReloadCount();
  count += this->mLeagueOverBackground[1]->GetReloadCount();
  for (int i = 0 ; i < 20 ; i++)
  {
    count += (CMeshManager::Instance()->GetTexture(this->mFlagTex[i])->IsLoaded() ? 0 : 1);
  }
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelLeagueOver.h
#ifndef _GUIPANELLEAGUEOVER_H
#define _GUIPANELLEAGUEOVER_H


class GUIPanelLeagueOver : public GUIPanel
{
  GUIIcon          *mLeagueOverBackground[2];
  GUIIcon          *mFlags[3];
  HTexture          mFlagTex[20];
  GUITextField     *mTeamDesc[3];
public:
  GUIPanelLeagueOver(); 
  ~GUIPanelLeagueOver();
  void Show();
  void Hide();
  void Update();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelMainMenu.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\ctime.H"

#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelMainMenu.h"


GUIPanelMainMenu::GUIPanelMainMenu()
{
  
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_glowne\\sriodek.png");
  this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_glowne\\gora.png");

  this->mButtons[0] = new GUIButton(471,289,257,50);
  this->mButtons[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\game_normal",1,10);
  this->mButtons[0]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\game_normal",1,10);
  this->mButtons[0]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\game_presed",1,10);
  this->mButtons[0]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\game_rollon",1,10);
  this->mButtons[0]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false);
#if GERMAN
  this->mButtons[1] = new GUIButton(314,389,454,50);
#else
  this->mButtons[1] = new GUIButton(374,389,454,50);
#endif
  this->mButtons[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\options_normal",1,10);
  this->mButtons[1]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\options_normal",1,10);
  this->mButtons[1]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\options_presed",1,10);
  this->mButtons[1]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\options_rollon",1,10);
  this->mButtons[1]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_OPTIONS,false);

  this->mButtons[2] = new GUIButton(357,515,300,50);
  this->mButtons[2]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\credits_normal",1,10);
  this->mButtons[2]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\credits_normal",1,10);
  this->mButtons[2]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\credits_presed",1,10);
  this->mButtons[2]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\credits_rollon",1,10);
  this->mButtons[2]->SetClickEvent(ET_GUI,GUIE_PLAY_OUTRO,GUIP_OPTIONS,false);

  this->mButtons[3] = new GUIButton(277,599,115,110);
  this->mButtons[3]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mButtons[3]->Disable();

  this->mButtons[4] = new GUIButton(635,599,115,110);
  this->mButtons[4]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mButtons[4]->Disable();
  this->mQuit = new GUIButton(982,4,40,40);
  this->mQuit->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\quit_normal",1,10);
  this->mQuit->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\quit_normal",1,10);
  this->mQuit->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\quit_rollon",1,10);
  this->mQuit->SetTexture(BS_HOVER,"GUI\\menu_glowne\\quit_rollon",1,10);
  this->mQuit->SetClickEvent(ET_GLOBAL,GEID_QUIT,0,true);
}

GUIPanelMainMenu::~GUIPanelMainMenu()
{
  delete this->mStatic;
  delete this->mTop;
  delete this->mQuit;
  for (int i = 0 ; i < 5; i++)
  {
    delete this->mButtons[i];
  } 
}

int GUIPanelMainMenu::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  count += this->mTop->GetReloadCount();
  count += this->mQuit->GetReloadCount();
  for (int i = 0 ; i < 5; i++)
  {
    count += this->mButtons[i]->GetReloadCount();
  }
  return count;

}

void GUIPanelMainMenu::Show()
{
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  this->mQuit->Show();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Show();
  }
}


void GUIPanelMainMenu::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mQuit->Hide();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Hide();
  }
}



void GUIPanelMainMenu::Update()
{
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Update();
  }
  this->mQuit->Update();
}


void GUIPanelMainMenu::Reload()
{
  this->mTop->Reload();
  this->mStatic->Reload();
  this->mQuit->Reload();
  for (int i = 0 ; i < 5 ; i++)
    this->mButtons[i]->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelMainMenu.h
#ifndef _GUIPANELMAINMENU_H
#define _GUIPANELMAINMENU_H


class GUIPanelMainMenu :public GUIPanel
{
 GUIIcon *mTop;
 GUIIcon *mStatic;
 GUIButton *mButtons[5];
 GUIButton *mQuit;
public:
  GUIPanelMainMenu();
  virtual ~GUIPanelMainMenu();
  void Show();
  void Hide();
  void Update();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelMatchOver.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"

#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\MeshManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelMatchOver.h"


GUIPanelMatchOver::GUIPanelMatchOver()
{
  this->mMatchOverBackground[0] = new GUIIcon(100,100,824,568, "GUI\\Match_gora.png");
  this->mMatchOverBackground[1] = new GUIIcon(100,100,824,568, "GUI\\Match_dol.png");
  
  this->mMatchOverNumbers[0] = new GUINumbers(650,280,50,50,"score",1);
  this->mMatchOverNumbers[1] = new GUINumbers(650,455,50,50,"score",1);

  
  this->mMatchOverTeam[0] = new GUITextField(350,305,185,50,ALIGN_LEFT);
  this->mMatchOverTeam[1] = new GUITextField(350,480,185,50,ALIGN_LEFT);
  this->mFlags[0] = new GUIIcon(270,280,75,50,"GUI\\menu_friendly\\bra.png");
  this->mFlags[1] = new GUIIcon(270,455,75,50,"GUI\\menu_friendly\\bra.png");
}

GUIPanelMatchOver::~GUIPanelMatchOver()
{
  for (int i = 0 ; i < 2; i++)
  {
    delete mMatchOverBackground[i];
    delete this->mMatchOverNumbers[i];
    delete this->mMatchOverTeam[i];
    delete this->mFlags[i];
  }
}



void GUIPanelMatchOver::Show()
{
  SetStruct *set = CGame::Instance()->GetSetScores();
  this->mMatchOverTeam[0]->SetText(CGame::Instance()->GetTeamName(0));
  this->mMatchOverTeam[1]->SetText(CGame::Instance()->GetTeamName(1));
  char team1score = 0, team0score = 0;
  for (int i = 0 ; i < CGame::Instance()->GetCurrentSet() ; i++)
  {
    if (set[i].winningTeam == 1)
    {
      team1score++;
    }
    else
    {
      team0score++;
    }
  }
  if (team0score > team1score)
    mMatchOverBackground[0]->Show();
  else
    mMatchOverBackground[1]->Show();

  mMatchOverNumbers[0]->Show();
  mMatchOverNumbers[1]->Show();
  mMatchOverNumbers[0]->SetNumber(team0score);
  mMatchOverNumbers[1]->SetNumber(team1score);
  mMatchOverTeam[0]->Show();
  mMatchOverTeam[1]->Show();
  char buffer[256];
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(0)); 
  HTexture t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[0]->SetTexture(t);
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(1));
  t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[1]->SetTexture(t);
  this->mFlags[0]->Show();
  this->mFlags[1]->Show();
}


void GUIPanelMatchOver::Hide()
{
  if (this->mMatchOverBackground[0]->IsVisible())
  {
    mMatchOverBackground[0]->Hide();
  }
  if (this->mMatchOverBackground[1]->IsVisible())
  {
    mMatchOverBackground[1]->Hide();
  }
  mMatchOverNumbers[0]->Hide();
  mMatchOverNumbers[1]->Hide();
  mMatchOverTeam[0]->Hide();
  mMatchOverTeam[1]->Hide();
  this->mFlags[0]->Hide();
  this->mFlags[1]->Hide();
}


void GUIPanelMatchOver::Update()
{
  if (GUI::Instance()->mEscPressed)
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_INGAMEMENU,false,NULL);
  }
}


void GUIPanelMatchOver::Reload()
{
 this->mMatchOverBackground[0]->Reload();
 this->mMatchOverBackground[1]->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelMatchOver.h
#ifndef _GUIPANELMATCHOVER_H
#define _GUIPANELMATCHOVER_H


class GUIPanelMatchOver : public GUIPanel
{
  GUIIcon          *mMatchOverBackground[2];
  GUINumbers       *mMatchOverNumbers[2]; 
  GUITextField     *mMatchOverTeam[2];
  GUIIcon          *mFlags[2];
public:
  GUIPanelMatchOver(); 
  ~GUIPanelMatchOver();
  void Show();
  void Hide();
  void Update();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptions.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelOptions.h"


GUIPanelOptions::GUIPanelOptions()
{
  
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_glowne\\sriodek.png");
  this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_glowne\\gora.png");

  this->mButtons[0] = new GUIButton(456,289,280,50);
  this->mButtons[0]->SetTexture(BS_DISABLED,"GUI\\menu_options\\video_normal",1,10);
  this->mButtons[0]->SetTexture(BS_NORMAL,"GUI\\menu_options\\video_normal",1,10);
  this->mButtons[0]->SetTexture(BS_PRESSED,"GUI\\menu_options\\video_presed",1,10);
  this->mButtons[0]->SetTexture(BS_HOVER,"GUI\\menu_options\\video_rollon",1,10);
  this->mButtons[0]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_VIDEO,false);


  this->mButtons[1] = new GUIButton(382,389,252,50);
  this->mButtons[1]->SetTexture(BS_DISABLED,"GUI\\menu_options\\sound_normal",1,10);
  this->mButtons[1]->SetTexture(BS_NORMAL,"GUI\\menu_options\\sound_normal",1,10);
  this->mButtons[1]->SetTexture(BS_PRESSED,"GUI\\menu_options\\sound_presed",1,10);
  this->mButtons[1]->SetTexture(BS_HOVER,"GUI\\menu_options\\sound_rollon",1,10);
  this->mButtons[1]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_SOUND,false);

  this->mButtons[2] = new GUIButton(325,515,375,50);
  this->mButtons[2]->SetTexture(BS_DISABLED,"GUI\\menu_options\\controls_normal",1,10);
  this->mButtons[2]->SetTexture(BS_NORMAL,"GUI\\menu_options\\controls_normal",1,10);
  this->mButtons[2]->SetTexture(BS_PRESSED,"GUI\\menu_options\\controls_presed",1,10);
  this->mButtons[2]->SetTexture(BS_HOVER,"GUI\\menu_options\\controls_rollon",1,10);
  this->mButtons[2]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_CONTROLS,false);

  this->mButtons[3] = new GUIButton(277,599,115,110);
  this->mButtons[3]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mButtons[3]->Disable();
  this->mButtons[4] = new GUIButton(635,599,115,110);
  this->mButtons[4]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mButtons[4]->Disable();

}

GUIPanelOptions::~GUIPanelOptions()
{
  delete this->mStatic;
  delete this->mTop; 
  for (int i = 0 ; i < 5; i++)
  {
    delete this->mButtons[i];
  }
}


void GUIPanelOptions::Show()
{
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Show();
  }
}


void GUIPanelOptions::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Hide();
  }
}



void GUIPanelOptions::Update()
{
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Update();
  }
}

void GUIPanelOptions::BackwardPressed()
{
 POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_MAINMENU,false,NULL);
}



void GUIPanelOptions::Reload()
{
  for (int i = 0 ; i < 5 ;i++)
   this->mButtons[i]->Reload();
  this->mStatic->Reload();
  this->mTop->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptions.h
#ifndef _GUIPANELOPTIONSOPTIONS_H
#define _GUIPANELOPTIONSOPTIONS_H


class GUIPanelOptions :public GUIPanel
{
  GUIIcon *mTop;
 GUIIcon *mStatic;
 GUIButton *mButtons[5];
public:
  GUIPanelOptions();
  virtual ~GUIPanelOptions();
  void Show();
  void Hide();
  void Update();
  void BackwardPressed();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptionsSound.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\SetupManager.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelOptionsSound.h"


GUIPanelOptionsSound::GUIPanelOptionsSound()
{
  
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_sound\\sriodek_sound.png");
  this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_sound\\gora_sound.png");
  this->mText = new GUIIcon(163,0,700,768,"GUI\\menu_sound\\napisy_sound.png");
  
  this->mCurrentSoundSettings = new SOUND;

  this->mChecks[0] = new GUICheckBox(592,352+ 40 * 0,30,30,"gui\\menu_video\\checker",&this->mCurrentSoundSettings->ball);
  this->mChecks[1] = new GUICheckBox(592,352+ 40 * 1,30,30,"gui\\menu_video\\checker",&this->mCurrentSoundSettings->referee);
  this->mChecks[2] = new GUICheckBox(592,352+ 40 * 2,30,30,"gui\\menu_video\\checker",&this->mCurrentSoundSettings->peoples);
  this->mChecks[3] = new GUICheckBox(592,352+ 40 * 3,30,30,"gui\\menu_video\\checker",&this->mCurrentSoundSettings->menu);
  
   
  this->mSliders[0] = new GUISlider(523,235,120,20,&this->mSliderVals[0],100); 
  this->mSliders[1] = new GUISlider(523,274,120,20,&this->mSliderVals[1],100);
  this->mSliders[2] = new GUISlider(523,313,120,20,&this->mSliderVals[2],100);

  this->mSwitches[0] = new GUIButton(277,599,115,110);
  this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mSwitches[0]->Disable();
  this->mSwitches[1] =  new GUIButton(635,599,115,110);
  this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mSwitches[1]->Disable();
  this->mSliders[0]->SetClinable(false);
  this->mSliders[1]->SetClinable(false);
  this->mStatic->SetClinable(false);
  this->mText->SetClinable(false);
  this->mTop->SetClinable(false);
  for (int i = 0 ; i < 4; i++)
    this->mChecks[i]->SetClinable(false);
  for (int i = 0 ; i < 3 ; i++)
    this->mSliders[i]->SetClinable(false);

}

GUIPanelOptionsSound::~GUIPanelOptionsSound()
{
  delete this->mCurrentSoundSettings; 
  delete this->mStatic;
  delete this->mTop; 
  delete this->mText;
  for (int i = 0 ; i < 4; i++)
  {
    if (i < 2)
      delete this->mSwitches[i];
   
    delete this->mChecks[i];
    if (i < 3) 
      delete this->mSliders[i];
  }
}


void GUIPanelOptionsSound::Show()
{
  memcpy (this->mCurrentSoundSettings,SetupManager::Instance()->GetSound(), sizeof (SOUND));  
  this->mSliderVals[0] = ((float)this->mCurrentSoundSettings->music_volume)/100.0f;
  this->mSliderVals[1] = ((float)this->mCurrentSoundSettings->effect_volume)/100.0f;
  this->mSliderVals[2] = ((float)this->mCurrentSoundSettings->fx_volume)/100.0f;
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  
  for (int i = 0 ; i < 4; i++)
  {
    if (i < 2)
     this->mSwitches[i]->Show();
    
    this->mChecks[i]->Show();
    if (i < 3) 
      this->mSliders[i]->Show();
  }
  this->mText->Show();
}


void GUIPanelOptionsSound::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  for (int i = 0 ; i < 4; i++)
  {
    if (i < 2)
      this->mSwitches[i]->Hide();
    
    this->mChecks[i]->Hide();
    if (i < 3) 
      this->mSliders[i]->Hide();
  }
  this->mText->Hide();
}



void GUIPanelOptionsSound::Update()
{
  int i;
  for (i = 0 ; i < 4; i++)
  {
    if (i < 2)
      this->mSwitches[i]->Update();
    
    this->mChecks[i]->Update();
    if (i < 3) 
      this->mSliders[i]->Update();
  }
  
  
 this->mCurrentSoundSettings->music_volume = (int)(100.0f * this->mSliderVals[0]);
 this->mCurrentSoundSettings->effect_volume = (int)(100.0f * this->mSliderVals[2]);
 this->mCurrentSoundSettings->fx_volume  = (int)(100.0f * this->mSliderVals[1]);

 SetupManager::Instance()->UpdateSound(this->mCurrentSoundSettings);  
}

void GUIPanelOptionsSound::BackwardPressed()
{
  if (CGame::Instance())
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_INGAMEMENU,false,NULL);
  }
  else
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_OPTIONS,false,NULL);
  }
}

void GUIPanelOptionsSound::Reload() {}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptionsSound.h
#ifndef _GUIPANELOPTIONSSOUND_H
#define _GUIPANELOPTIONSSOUND_H

struct SOUND;
class GUIPanelOptionsSound :public GUIPanel
{
 GUIIcon *mTop;
 GUIIcon *mStatic;
 GUIIcon *mText;
 GUIButton *mSwitches[2];
 GUISlider *mSliders[3];
 float mSliderVals[3];
 GUICheckBox *mChecks[4];
 bool  mCheckVals[4][2];
 SOUND *mCurrentSoundSettings;
public:
  GUIPanelOptionsSound();
  virtual ~GUIPanelOptionsSound();
  void Show();
  void Hide();
  void Update();
  void BackwardPressed();
  void Reload();
};




#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptionsVideo.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\SetupManager.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\Renderer.h"
#include "..\MeshManager.h"

#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelOptionsVideo.h"


struct _WH
{
  unsigned int w,h;
} WH[3] =
{
  {800,600},
  {1024,768},
  {1280,1024}
};

GUIPanelOptionsVideo::GUIPanelOptionsVideo() 
{
  this->mSelectedButton = 0;
  this->mMaxShaderLevel = CMeshManager::Instance()->GetMaxShaderLevel();
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_Video\\sriodek_video.png");
  this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_Video\\gora_video.png");
  this->mText = new GUIIcon(163,0,700,768,"GUI\\menu_Video\\napisy_video.png");
  for (int i = 0; i < 3; i ++)
  {
    this->mCheckVals[i][0] = this->mCheckVals[i][1] = false;
    this->mResBools[i] = false;
  }
  this->mCurrentVideoSettings = new VIDEO;
  
  this->mResBools[mSelectedButton] = true;
  this->mResButtons[0] = new GUICheckBox(325,240,100,40,"gui\\menu_video\\800",&mResBools[0]);
  this->mResButtons[1] = new GUICheckBox(465,240,100,40,"gui\\menu_video\\1024",&mResBools[1]);
  this->mResButtons[2] = new GUICheckBox(605,240,100,40,"gui\\menu_video\\1280",&mResBools[2]);

  
  
  this->mChecks[0] = new GUICheckBox(499,324,30,30,"gui\\menu_video\\checker",&this->mCurrentVideoSettings->reflections );
  this->mChecks[1] = new GUICheckBox(499,404,30,30,"gui\\menu_video\\checker",&this->mCurrentVideoSettings->crawd);
  this->mChecks[2] = new GUICheckBox(499,644,30,30,"gui\\menu_video\\checker",&this->mCurrentVideoSettings->referees );

  this->mSliders[0] = new GUISlider(360,478,300,20,&this->mSliderVals[0],2); 
  this->mSliders[1] = new GUISlider(360,558,300,20,&this->mSliderVals[1],mMaxShaderLevel-1);
  

  this->mSwitches[0] = new GUIButton(277,599,115,110);
  this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mSwitches[0]->Disable();
  this->mSwitches[1] =  new GUIButton(635,599,115,110);
  this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mSwitches[1]->Disable();
    this->mSliders[0]->SetClinable(false);
  this->mSliders[1]->SetClinable(false);
  this->mStatic->SetClinable(false);
  this->mText->SetClinable(false);
  this->mTop->SetClinable(false);

  for (int i = 0 ; i < 3; i++)
  {
    this->mResButtons[i]->SetClinable(false);
    this->mChecks[i]->SetClinable(false);
  }
  for (int i = 0 ; i < 2 ; i++)
    this->mSliders[i]->SetClinable(false);

}

GUIPanelOptionsVideo::~GUIPanelOptionsVideo()
{
  delete this->mCurrentVideoSettings; 
  delete this->mStatic;
  delete this->mTop; 
  delete this->mText;
  for (int i = 0 ; i < 4; i++)
  {
    if (i < 2)
    {
      delete this->mSwitches[i];
      delete this->mSliders[i];
    }
    if (i < 3)
    {
      delete this->mChecks[i];
      delete this->mResButtons[i];
    }
     
      
  }
}


void GUIPanelOptionsVideo::Show()
{
  memcpy(this->mCurrentVideoSettings, SetupManager::Instance()->GetVideo(), sizeof(VIDEO));
  this->mSliderVals[0] = ((float)this->mCurrentVideoSettings->texture_level) /2.0f;   
  this->mSliderVals[1] = ((float)this->mCurrentVideoSettings->graphic_level) /(float)this->mMaxShaderLevel;
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  int i;
  for (i = 0 ; i < 3 ; i++)
  {
    if (this->mCurrentVideoSettings->res == (Resolution) i )
    {
      mSelectedButton = mInitRes = i;
      this->mResBools[i] = true;
    }
    else
      this->mResBools[i] = false;
  }

  for (i = 0 ; i < 4; i++)
  {
    if (i < 2)
    {
      this->mSwitches[i]->Show();
      this->mSliders[i]->Show();
    }
    if (i < 3) 
    {
      this->mChecks[i]->Show();
      this->mResButtons[i]->Show();
    }
    
  }
  this->mText->Show();
}


void GUIPanelOptionsVideo::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  for (int i = 0 ; i < 4; i++)
  {
    if (i < 2)
    {
      this->mSwitches[i]->Hide();
      this->mSliders[i]->Hide();
    }
    if (i < 3) 
    {
      this->mChecks[i]->Hide();
      this->mResButtons[i]->Hide();
    }
  }
  this->mText->Hide();
}



void GUIPanelOptionsVideo::Update()
{
  int i;
  for (i = 0 ; i < 4; i++)
  {
   if (i < 2)
    {
      this->mSwitches[i]->Update();
      this->mSliders[i]->Update();
    }
    if (i < 3) 
    {
      this->mChecks[i]->Update();
      this->mResButtons[i]->Update();
    }
  }

  if (!mResBools[mSelectedButton])
  {
    this->mResButtons[mSelectedButton]->Toggle();
  }
  for (i = 0 ; i <3 ; i++)
   {
     if ( mResBools[i])
     {
       if (i != this->mSelectedButton)
       {
         this->mResButtons[mSelectedButton]->Toggle();
         this->mSelectedButton = i;
       }
     }
   }
  SetupManager::Instance()->UpdateVideo(this->mCurrentVideoSettings);
}

void GUIPanelOptionsVideo::BackwardPressed()
{
 this->mCurrentVideoSettings->graphic_level =(int) (this->mSliderVals[1] * this->mMaxShaderLevel);
 this->mCurrentVideoSettings->texture_level =(int) (this->mSliderVals[0] * 2);
 this->mCurrentVideoSettings->res = (Resolution) this->mSelectedButton; 
 SetupManager::Instance()->UpdateVideo(this->mCurrentVideoSettings);

 if (CGame::Instance())
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_INGAMEMENU,false,NULL);
  }
  else
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_OPTIONS,false,NULL);
  }
}


void GUIPanelOptionsVideo::Reload() {}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelOptionsVideo.h
#ifndef _GUIPANELOPTIONSVIDEO_H
#define _GUIPANELOPTIONSVIDEO_H

struct VIDEO;
class GUIPanelOptionsVideo :public GUIPanel 
{
 unsigned char mSelectedButton;
 GUIIcon *mTop;
 GUIIcon *mStatic;
 GUIIcon *mText;
 GUIButton *mSwitches[2];
 GUICheckBox *mResButtons[3];
 GUISlider *mSliders[3];
 float mSliderVals[3];
 GUICheckBox *mChecks[4];
 bool  mCheckVals[4][2];
 bool mResBools[3];
 unsigned char mInitRes;
 VIDEO *mCurrentVideoSettings;
 unsigned char mMaxShaderLevel;
public:
  GUIPanelOptionsVideo();
  virtual ~GUIPanelOptionsVideo();
  void Show();
  void Hide();
  void Update();
  void BackwardPressed();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSelectGame.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"

#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelSelectGame.h"
#include "..\GUI.h"

GUIPanelSelectGame::GUIPanelSelectGame()
{
  
  this->mStatic = new GUIIcon(163,0,700,768,"GUI\\menu_glowne\\sriodek.png");
 this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_glowne\\gora.png");

#if !(POLISH | GERMAN)
  this->mButtons[2] = new GUIButton(392,289,599,50);
  this->mButtons[0] = new GUIButton(338,389,429,50);
  this->mButtons[1] = new GUIButton(288,515,503,50);
#else
  this->mButtons[0] = new GUIButton(338,389,343,40);
  this->mButtons[1] = new GUIButton(288,515,403,40);

#if POLISH
  this->mButtons[2] = new GUIButton(392,289,479,40);
#else
  this->mButtons[2] = new GUIButton(352,279,479,40);
#endif
#endif
  this->mButtons[0]->SetTexture(BS_DISABLED,"GUI\\menu_game\\world_league_normal",1,10);
  this->mButtons[0]->SetTexture(BS_NORMAL,"GUI\\menu_game\\world_league_normal",1,10);
  this->mButtons[0]->SetTexture(BS_PRESSED,"GUI\\menu_game\\world_league_presed",1,10);
  this->mButtons[0]->SetTexture(BS_HOVER,"GUI\\menu_game\\world_league_rollon",1,10);

  this->mButtons[0]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_WORLDLEAGUESELECT,false);

  
  this->mButtons[1]->SetTexture(BS_DISABLED,"GUI\\menu_game\\europe_league_normal",1,10);
  this->mButtons[1]->SetTexture(BS_NORMAL,"GUI\\menu_game\\europe_league_normal",1,10);
  this->mButtons[1]->SetTexture(BS_PRESSED,"GUI\\menu_game\\europe_league_presed",1,10);
  this->mButtons[1]->SetTexture(BS_HOVER,"GUI\\menu_game\\europe_league_rollon",1,10);
  this->mButtons[1]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_EUROLEAGUESELECT,false);

  
  this->mButtons[2]->SetTexture(BS_DISABLED,"GUI\\menu_game\\friendly_normal",1,10);
  this->mButtons[2]->SetTexture(BS_NORMAL,"GUI\\menu_game\\friendly_normal",1,10);
  this->mButtons[2]->SetTexture(BS_PRESSED,"GUI\\menu_game\\friendly_presed",1,10);
  this->mButtons[2]->SetTexture(BS_HOVER,"GUI\\menu_game\\friendly_rollon",1,10);
  this->mButtons[2]->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_FRIENDLYSELECT,false);

  this->mButtons[3] = new GUIButton(277,599,115,110);
  this->mButtons[3]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
  this->mButtons[3]->Disable();
  this->mButtons[4] = new GUIButton(635,599,115,110);
  this->mButtons[4]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
  this->mButtons[4]->Disable();

}

GUIPanelSelectGame::~GUIPanelSelectGame()
{
  delete this->mStatic;
  delete this->mTop;
  for (int i = 0 ; i < 5; i++)
  {
    delete this->mButtons[i];
  }
}


void GUIPanelSelectGame::Show()
{
  this->mVisible = true;
  this->mStatic->Show();
  this->mTop->Show();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Show();
  }
}


void GUIPanelSelectGame::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Hide();
  }
}



void GUIPanelSelectGame::Update()
{
  for (int i = 0 ; i < 5; i++)
  {
    this->mButtons[i]->Update();
  }
}

void GUIPanelSelectGame::BackwardPressed()
{
 POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_MAINMENU,false,NULL);
}


void GUIPanelSelectGame::Reload()
{
  for (int i = 0 ; i < 5 ; i++)
    this->mButtons[i]->Reload();
  this->mTop->Reload();
  this->mStatic->Reload();
}

int GUIPanelSelectGame::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  count += this->mTop->GetReloadCount();
  for (int i = 0 ; i < 5; i++)
  {
    count += this->mButtons[i]->GetReloadCount();
  }
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSelectGame.h
#ifndef _GUIPANELSELECTGAME_H
#define _GUIPANELSELECTGAME_H


class GUIPanelSelectGame : public  GUIPanel
{
 GUIIcon *mTop;
 GUIIcon *mStatic;
 GUIButton *mButtons[5];
public:
  GUIPanelSelectGame();
  virtual ~GUIPanelSelectGame();
  void Update();
  void Show();
  void Hide();
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSetOver.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "..\MeshManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelSetOver.h"


GUIPanelSetOver::GUIPanelSetOver()
{
  this->mSetOverBackground[0] = new GUIIcon(100,100,824,568, "GUI\\set_gora.png");
  this->mSetOverBackground[1] = new GUIIcon(100,100,824,568, "GUI\\set_dol.png");
  
  this->mSetOverNumbers[0] = new GUINumbers(650,280,50,50,"score",2);
  this->mSetOverNumbers[1] = new GUINumbers(650,455,50,50,"score",2);

  
  this->mSetOverTeam[0] =  new GUITextField(350,305,185,50,ALIGN_LEFT);
  this->mSetOverTeam[1] =  new GUITextField(350,480,185,50,ALIGN_LEFT);

  this->mFlags[0] = new GUIIcon(270,280,75,50,"GUI\\menu_friendly\\bra.png");
  this->mFlags[1] = new GUIIcon(270,455,75,50,"GUI\\menu_friendly\\bra.png");
}

GUIPanelSetOver::~GUIPanelSetOver()
{
  for (int i = 0 ; i < 2; i++)
  {
    delete mSetOverBackground[i];
    delete this->mSetOverNumbers[i];
    delete this->mSetOverTeam[i];
    delete this->mFlags[i];
  }
}



void GUIPanelSetOver::Show()
{
  SetStruct *set = CGame::Instance()->GetSetScores();
  this->mSetOverTeam[0]->SetText(CGame::Instance()->GetTeamName(0));
  this->mSetOverTeam[1]->SetText(CGame::Instance()->GetTeamName(1));
  unsigned char winner = set[CGame::Instance()->GetCurrentSet()].Score[0] >
                         set[CGame::Instance()->GetCurrentSet()].Score[1] ? TEAM_0 : TEAM_1; 
  mSetOverBackground[winner]->Show();
  mSetOverNumbers[0]->Show();
  mSetOverNumbers[1]->Show();
  mSetOverNumbers[0]->SetNumber(set[CGame::Instance()->GetCurrentSet()].Score[0]);
  mSetOverNumbers[1]->SetNumber(set[CGame::Instance()->GetCurrentSet()].Score[1]);
  mSetOverTeam[0]->Show();
  mSetOverTeam[1]->Show();
  char buffer[256];
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(0)); 
  HTexture t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[0]->SetTexture(t);
  my_snprintf(buffer,256,"GUI\\menu_friendly\\%s.png",CGame::Instance()->GetTeamShortName(1));
  t = CMeshManager::Instance()->GetTextureHandlerLoad(buffer);
  CMeshManager::Instance()->SetTextureClinable(t, false);
  this->mFlags[1]->SetTexture(t);
  this->mFlags[0]->Show();
  this->mFlags[1]->Show();
}


void GUIPanelSetOver::Hide()
{
  if (this->mSetOverBackground[0]->IsVisible())
  {
    mSetOverBackground[0]->Hide();
  }
  if (this->mSetOverBackground[1]->IsVisible())
  {
    mSetOverBackground[1]->Hide();
  }
  mSetOverNumbers[0]->Hide();
  mSetOverNumbers[1]->Hide();
  mSetOverTeam[0]->Hide();
  mSetOverTeam[1]->Hide();
  this->mFlags[0]->Hide();
  this->mFlags[1]->Hide();
}


void GUIPanelSetOver::Update()
{
  if (!CGame::Instance()->ShouldDisplaySetOver())
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_GAMEPLAY,false,NULL);
    return;
  }
  if (GUI::Instance()->mEscPressed)
  {
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_INGAMEMENU,false,NULL);
    return;
  }
}


void GUIPanelSetOver::Reload()
{
 this->mSetOverBackground[0]->Reload();
 this->mSetOverBackground[1]->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSetOver.h
#ifndef _GUIPANELSETOVER_H
#define _GUIPANELSETOVER_H


class GUIPanelSetOver : public GUIPanel
{
  GUIIcon          *mSetOverBackground[2];
  GUINumbers       *mSetOverNumbers[2]; 
  GUITextField     *mSetOverTeam[2];
  GUIIcon          *mFlags[2];
public:
  GUIPanelSetOver(); 
  ~GUIPanelSetOver();
  void Show();
  void Hide();
  void Update();
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSound.cpp

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelSound.h
#ifndef _GUIPANELSOUND_H
#define _GUIPANELSOUND_H


class GUIPanelSound
{

public:
  GUIPanelSound();
  ~GUIPanelSound();
  void Show();
  void Hide();
  
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelStadium.cpp


#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"

#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelStadium.h"


  


GUIPanelStadium::GUIPanelStadium() 
{
 this->mStatic = new GUIIcon(150,10,700,768,"GUI\\menu_stadion\\sriodek_stadion.png");
 this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_stadion\\gora_stadion.png");
 this->mSelectedStadium = 0;
 for (int i = 0 ; i < 4; i ++)
 {
   mStadiumBools[i] = false;
 }
 this->mStadiumBools[0] = true;
 this->mStadionButtons[0] = new GUICheckBox(340,250,96,96,"GUI\\menu_stadion\\stadion1",&this->mStadiumBools[0]);//new GUIButton(200,400,96,96); 
 this->mStadionButtons[1] = new GUICheckBox(550,250,96,96,"GUI\\menu_stadion\\stadion2",&this->mStadiumBools[1]);
 this->mStadionButtons[2] = new GUICheckBox(340,450,96,96,"GUI\\menu_stadion\\stadion3",&this->mStadiumBools[2]);
 this->mStadionButtons[3] = new GUICheckBox(550,450,96,96,"GUI\\menu_stadion\\stadion4",&this->mStadiumBools[3]);

 this->mSwitches[0] = new GUIButton(262,606,115,110);
 this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
 this->mSwitches[0]->Disable();
 
 this->mSwitches[1] = new GUIButton(622,606,115,110);
 this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
 this->mSwitches[1]->Disable();
 
}


GUIPanelStadium::~GUIPanelStadium()
{
  int i;
 delete this->mStatic;
 delete this->mTop; 
 for(i = 0 ; i < 4 ; i++)
 {
   delete this->mStadionButtons[i];
 }
 
 for(i = 0 ; i < 2 ; i++)
 {
   delete this->mSwitches[i];
 }
}


void GUIPanelStadium::Show()
{
  this->mStadionButtons[mSelectedStadium]->Disable();
  this->mStatic->Show();
  this->mTop->Show();
  for(int i = 0 ; i < 4 ; i++)
  {
    this->mStadionButtons[i]->Show();
  }
  this->mSwitches[0]->Show();
  this->mSwitches[1]->Show();
}



void GUIPanelStadium::Hide()
{
  this->mStatic->Hide();
  this->mTop->Hide();
  for(int i = 0 ; i < 4 ; i++)
  {
    this->mStadionButtons[i]->Hide();
  }
  this->mSwitches[0]->Hide();
  this->mSwitches[1]->Hide();
}


void GUIPanelStadium::Update()
{
  this->mSwitches[0]->Update();
  this->mSwitches[1]->Update();
  for(int i = 0 ; i < 4 ; i++)
  {
    this->mStadionButtons[i]->Update();
  }
  
  if (!this->mStadiumBools[mSelectedStadium])
     this->mStadionButtons[mSelectedStadium]->Toggle();

  for (int i = 0; i < 4 ; i++)
  {
    if (this->mStadiumBools[i] && i != mSelectedStadium)
    {
      this->mStadionButtons[mSelectedStadium]->Toggle();
      mSelectedStadium = i;
    }
  }
}



void GUIPanelStadium::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_FRIENDLYSELECT,false,NULL);
}


void GUIPanelStadium::ForwardPressed()
{
  union _u
  {
    char c[4];
    unsigned long l;
  }u;
  u.l = this->mPassedData;
  u.c[3] = this->mSelectedStadium;
  POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,u.l,false,NULL);
}


void GUIPanelStadium::GetPassedData(void *data)
{
 this->mPassedData = *(unsigned long *)data;
}



void GUIPanelStadium::Reload()
{
  for (int i = 0 ; i < 4 ; i++)
  {
    this->mStadionButtons[i]->Reload();
  }
  this->mStatic->Reload();
  this->mSwitches[0]->Reload();
  this->mSwitches[1]->Reload();
  this->mTop->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelStadium.h
#ifndef _GUIPANELSTADIUM_H
#define _GUIPANELSTADIUM_H


class GUIPanelStadium : public GUIPanel
{
  GUIIcon *mStatic;
  GUIIcon *mTop;
  GUICheckBox *mStadionButtons[4];
  GUIButton *mSwitches[2];
  char mSelectedStadium;
  bool mStadiumBools[4];
  unsigned long mPassedData;
public:
  GUIPanelStadium();
  ~GUIPanelStadium();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void GetPassedData(void * data);
  void Reload();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelVideo.cpp

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelVideo.h
#ifndef _GUIPANEL_H
#define _GUIPANEL_H


class GUIPanel
{
protected:
  bool mVisible;
public:
  GUIPanel() {mVisible = false};
  virtual ~GUIPanel() = 0;
  virtual void Show() = 0;
  virtual void Hide() = 0;
  void IsVisible() {return mVisible;}
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldFinal.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\core\EuroLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelWorldFinal.h"


GUIPanelWorldFinal::GUIPanelWorldFinal()
{
//  char buffer[256];
  this->mStatic = new GUIIcon(222,50,580,620,"GUI\\menu_final_round\\final_round.png");
  this->mTop = new GUIIcon(0,1,1024,768,"GUI\\menu_round\\goora_round.png");
  this->mTop->SetLevel(-26);
  for (int i = 0; i < 6; i ++)
  {
    this->mPhase[i] = new GUIIcon(260,170 + (float)i * 80,160,90,"GUI\\menu_final_round\\final.png");
    this->mPhaseA[i] = new GUIIcon(605,170 + (float)i * 80,160,90,"GUI\\menu_final_round\\finala.png");
  }
  memset(this->mTextbuf,0, sizeof(mTextbuf));

  memset(this->mScorebuf,0, sizeof(mScorebuf));
  for (int j = 0 ; j < 6; j++)
  {
    this->mMatchDesc[j] = new GUITextField(512, 190 + (float)j * 80,160,20);
    this->mMatchDesc[j]->SetText(this->mTextbuf[j]);
    this->mMatchScores[j] = new  GUITextField(512, 230 + (float)j * 80,160,20);
    this->mMatchScores[j]->SetText(this->mScorebuf[j]); 
  }
}

GUIPanelWorldFinal::~GUIPanelWorldFinal()
{
  delete this->mStatic;
  delete this->mTop; 
  for (int i = 0 ; i < 6; i++)
  {
    delete this->mPhase[i];
    delete this->mPhaseA[i];
  }
  for (int j = 0 ; j < 6; j++)
  {
    delete this->mMatchDesc[j];
    delete this->mMatchScores[j];
  }
}




void GUIPanelWorldFinal::Show()
{
  if (WorldLeague::Instance())
  {
    WorldLeague::Instance()->GetNextMatch();
    this->mVisible = true;
    for (int k = 0; k < WorldLeague::Instance()->GetFinalStage()+1 ; k++)
    {
      match *temp = WorldLeague::Instance()->GetFinalMatch(k,0);
      my_snprintf (this->mTextbuf[k*2],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
      this->mMatchDesc[k*2]->Show(); 
      temp = WorldLeague::Instance()->GetFinalMatch(k,1);
      my_snprintf (this->mTextbuf[k*2+1],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
      this->mMatchDesc[k*2+1]->Show(); 
    }
    for (int k = 0; k < WorldLeague::Instance()->GetFinalStage() ; k++)
    {
      match *temp = WorldLeague::Instance()->GetFinalMatch(k,0);
      my_snprintf (this->mScorebuf[k*2],10,"%i - %i",temp->sets_won[0], temp->sets_won[1] );
      this->mMatchScores[k*2]->Show(); 
      temp = WorldLeague::Instance()->GetFinalMatch(k,1);
      my_snprintf (this->mScorebuf[k*2+1],10,"%i - %i",temp->sets_won[0], temp->sets_won[1] );
      this->mMatchScores[k*2+1]->Show(); 
    }
    this->mTop->Show();
    this->mCurrentPhase =  WorldLeague::Instance()->GetFinalStage() *2 +  WorldLeague::Instance()->GetCurrentMatch() ;
    this->mPhase[mCurrentPhase]->Show();  
    this->mPhaseA[mCurrentPhase]->Show();  
  } else 
  if(EuroLeague::Instance())
  {
    EuroLeague::Instance()->GetNextMatch();
    this->mVisible = true;
    for (int k = 0; k < EuroLeague::Instance()->GetFinalStage()+1 ; k++)
    {
      match *temp = EuroLeague::Instance()->GetFinalMatch(k,0);
      my_snprintf (this->mTextbuf[k*2],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
      this->mMatchDesc[k*2]->Show(); 
      temp = EuroLeague::Instance()->GetFinalMatch(k,1);
      my_snprintf (this->mTextbuf[k*2+1],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
      this->mMatchDesc[k*2+1]->Show(); 
    }
    for (int k = 0; k < EuroLeague::Instance()->GetFinalStage() ; k++)
    {
      match *temp = EuroLeague::Instance()->GetFinalMatch(k,0);
      my_snprintf (this->mScorebuf[k*2],10,"%i - %i",temp->sets_won[0], temp->sets_won[1] );
      this->mMatchScores[k*2]->Show(); 
      temp = EuroLeague::Instance()->GetFinalMatch(k,1);
      my_snprintf (this->mScorebuf[k*2+1],10,"%i - %i",temp->sets_won[0], temp->sets_won[1] );
      this->mMatchScores[k*2+1]->Show(); 
    }
    
    this->mTop->Show();
    this->mCurrentPhase =  EuroLeague::Instance()->GetFinalStage() *2 +  EuroLeague::Instance()->GetCurrentMatch() ;
    this->mPhase[mCurrentPhase]->Show();  
    this->mPhaseA[mCurrentPhase]->Show();  
  }
  
  this->mStatic->Show();
}


void GUIPanelWorldFinal::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mPhase[mCurrentPhase]->Hide();  
  this->mPhaseA[mCurrentPhase]->Hide();  
  for (int j = 0 ; j < 6; j++)
  {
    this->mMatchDesc[j]->Hide();
    this->mMatchScores[j]->Hide();
  }
}


void GUIPanelWorldFinal::ForwardPressed()
{
  POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,0,false,NULL);
}

void GUIPanelWorldFinal::Reload()
{
  for (int i = 0 ; i < 6 ; i++)
  {
    this->mPhase[i]->Reload();
    this->mPhaseA[i]->Reload();
  }
  this->mStatic->Reload();
}

int GUIPanelWorldFinal::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  for (int i = 0 ; i < 6 ; i++)
  {
    count += this->mPhase[i]->GetReloadCount();
    count += this->mPhaseA[i]->GetReloadCount();
  }
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldFinal.h
#ifndef _GUIPANELWORLDFINAL_H
#define _GUIPANELWORLDFINAL_H


class GUIPanelWorldFinal : public GUIPanel
{
  GUIIcon *mStatic;
  GUIIcon *mTop;
  GUIIcon  *mPhase[6];
  GUIIcon  *mPhaseA[6];
  unsigned char mCurrentPhase;
  char mTextbuf[6][10];
  char mScorebuf[6][10];
  GUITextField *mMatchDesc[6];
  GUITextField *mMatchScores[6];
public:
  GUIPanelWorldFinal(); 
  ~GUIPanelWorldFinal();
  void Show();
  void Hide();
  void Update(){};
  void ForwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLadder.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelWorldLadder.h"


GUIPanelWorldLadder::GUIPanelWorldLadder()
{
  int i, k;
  char buffer[256];
  this->mStatic = new GUIIcon(222,0,580,620,"GUI\\menu_round\\sriodek_round.png");
  for (i = 0; i < 6; i ++)
  {
    my_snprintf(buffer,256,"GUI\\menu_round\\weekend%i.png",i+1);
    this->mWeekends[i] = new GUIIcon(60,120 + (float)i * 80,160,90,buffer);
    my_snprintf(buffer,256,"GUI\\menu_round\\weekend%ia.png",i+1);
    this->mWeekendsA[i] = new GUIIcon(805,120 + (float)i * 80,160,90,buffer);
  }
  memset(this->mTextbuf,0, sizeof(mTextbuf));
  memset(this->mScoreTextbuf,0, sizeof(mScoreTextbuf));
  float offs[2] =
  {
    0.0f , 33.0f
  };
  float offs2[2] = 
  {
    -30.0f,30.0f
  };

  for(i = 0 ; i < 3; i++)
   for (int j = 0 ; j < 6; j++)
   {
     for (k = 0; k < 2 ; k++)
     {
       this->mMatchDesc[i][j][k] = new GUITextField(320.0f + (float)i * 190.0f, 132.0f + (float)j * 82.0f + offs[k],160.0f,17.0f);
       this->mMatchDesc[i][j][k]->SetText(this->mTextbuf[i][j][k]);
     }
     for (k = 0; k < 4 ; k++)
     {
       this->mMatchScores[i][j][k] =  new GUITextField(320.0f + (float)i * 190 + offs2[k/2], 147.0f + (float)j * 82.0f + offs[k%2],160.0f,17.0f);
       this->mMatchScores[i][j][k]->SetText(this->mScoreTextbuf[i][j][k]);
     }
   }

   this->mShowStats = new GUIButton(452,668,120,50);
   this->mShowStats->SetTexture(BS_DISABLED,"GUI\\menu_round\\statistics_normal",1,10);
   this->mShowStats->SetTexture(BS_NORMAL,"GUI\\menu_round\\statistics_normal",1,10);
   this->mShowStats->SetTexture(BS_HOVER,"GUI\\menu_round\\statistics_rollon",1,10);
   this->mShowStats->SetTexture(BS_PRESSED,"GUI\\menu_round\\statistics_presed",1,10);
   this->mShowStats->SetClickEvent(ET_GUI,GUIE_SHOW_PANEL,GUIP_WORLDLEAGUEMATCHOVER,false);

}

GUIPanelWorldLadder::~GUIPanelWorldLadder()
{
  int i,k;
  delete this->mStatic;
  for (i = 0 ; i < 6; i++)
  {
    delete this->mWeekends[i];
    delete this->mWeekendsA[i];
  }
   for(i = 0 ; i < 3; i++)
    for (int j = 0 ; j < 6; j++)
    {
      for (k = 0; k < 2 ; k++)
      {
        delete this->mMatchDesc[i][j][k];
      }
      for (k = 0; k < 4 ; k++)
      {
        delete this->mMatchScores[i][j][k];
      }
    }

}




void GUIPanelWorldLadder::Show()
{
  if (WorldLeague::Instance()->WasMatchPlayed())
  {
    GUI::Instance()->ResetOverlay(OBS_BUTTON_F);
    this->mShowStats->Show(); 
  }else
  {
    memset(this->mTextbuf,0, sizeof(mTextbuf));
    memset(this->mScoreTextbuf,0, sizeof(mScoreTextbuf));
  }
  WorldLeague::Instance()->GetNextMatch();
  this->mCurrentWeekend =  WorldLeague::Instance()->GetCurrentWeekend();  

  
  this->mVisible = true;
  for(int i = 0 ; i < 3; i++)
    for (int j = 0 ; j < 6; j++)
      for (int k = 0; k < 4 ; k++)
      {
        match *temp = WorldLeague::Instance()->GetMatchByParams(i , j , k);
        if (k < 2)
        {
          my_snprintf (this->mTextbuf[i][j][k],10,"%s v %s",team3let[temp->teams[0]],team3let[temp->teams[1]]);
          this->mMatchDesc[i][j][k]->Show(); 
          char t1 = temp->sets_won[0],
               t2 = temp->sets_won[1];
          if (j < mCurrentWeekend)
          {
            my_snprintf (this->mScoreTextbuf[i][j][k],6,"%i - %i",t1,t2);
            this->mMatchScores[i][j][k]->Show();
          }

        }else
        {
          char t1 = temp->sets_won[1],
               t2 = temp->sets_won[0];
          if (j < mCurrentWeekend)
          {
            my_snprintf (this->mScoreTextbuf[i][j][k],6,"%i - %i",t1,t2);
            this->mMatchScores[i][j][k]->Show();
          }
        }
      }
  
  this->mWeekends[mCurrentWeekend]->Show();  
  this->mWeekendsA[mCurrentWeekend]->Show();  
  
  this->mStatic->Show();
}


void GUIPanelWorldLadder::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  this->mWeekends[mCurrentWeekend]->Hide();  
  this->mWeekendsA[mCurrentWeekend]->Hide();  
  for(int i = 0 ; i < 3; i++)
    for (int j = 0 ; j < 6; j++)
      for (int k = 0; k < 4 ; k++)
      {
        if (k < 2)
          this->mMatchDesc[i][j][k]->Hide();
        this->mMatchScores[i][j][k]->Hide();
      }
  if (this->mShowStats->IsVisible())
  {
    this->mShowStats->Hide();
  }
}


void GUIPanelWorldLadder::ForwardPressed()
{
  POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,0,false,NULL);
}

void GUIPanelWorldLadder::BackwardPressed()
{
  if (!WorldLeague::Instance()->WasMatchPlayed())
  {
    delete WorldLeague::Instance();
    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false,NULL);
  }
}


void GUIPanelWorldLadder::Update()
{
  if (this->mShowStats->IsVisible())
  {
    this->mShowStats->Update();
  }
}

void GUIPanelWorldLadder::Reload()
{
  for (int i = 0 ; i < 6 ;i ++)
  {
    this->mWeekends[i]->Reload();
    this->mWeekendsA[i]->Reload();
  }
  this->mStatic->Reload();
  this->mShowStats->Reload();
}

int GUIPanelWorldLadder::GetReloadCount()
{
  int count = this->mStatic->GetReloadCount();
  count += this->mShowStats->GetReloadCount();
  for (int i = 0 ; i < 6 ;i ++)
  {
    count += this->mWeekends[i]->GetReloadCount();
    count += this->mWeekendsA[i]->GetReloadCount();
  }
  return count;
}

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLadder.h
#ifndef _GUIPANELWORLDLADDER_H
#define _GUIPANELWORLDLADDER_H


class GUIPanelWorldLadder : public GUIPanel
{
  GUIIcon *mStatic;
  GUIIcon  *mWeekends[6];
  GUIIcon  *mWeekendsA[6];
  unsigned char mCurrentWeekend;
  char mTextbuf[3][6][2][10];
  char mScoreTextbuf[3][6][4][6];
  GUITextField *mMatchDesc[3][6][2];
  GUITextField *mMatchScores[3][6][4];
  GUIButton    *mShowStats;
public:
  GUIPanelWorldLadder(); 
  ~GUIPanelWorldLadder();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLeague.cpp


#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"

#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"

#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\User.h"
#include "..\..\core\UserManager.h"
#include "..\..\core\WorldLeague.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelWorldLeague.h"



GUIPanelWorldLeague::GUIPanelWorldLeague() :EventHandler(ET_GUI_WORLDLEAGUE)
{
 this->mStatic = new GUIIcon(150,10,700,768,"GUI\\menu_reprezentation\\sriodek_reprezentation.png");
 this->mTop = new GUIIcon(0,-1,1024,376,"GUI\\menu_reprezentation\\gora_reprezentation.png");
 this->mCurrentFlag = 0;
 char buffer[256];

 for(int i = 0 ; i < 12; i++)
 { 
   my_snprintf(buffer,256,"GUI\\menu_reprezentation\\%s2.png", team3let[i]);  
   this->mFlags[i] = new GUIIcon(380,443,240,130,buffer);
 }
 this->mTeamDesc = new GUITextField(500,380,290,40);

 this->mSwitches[0] = new GUIButton(262,606,115,110);
 this->mSwitches[0]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\backward_disabled",1,10);
 this->mSwitches[0]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\backward_normal",1,10);
 this->mSwitches[0]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\backward_presed",1,10);
 this->mSwitches[0]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\backward_rollon",1,10);
 this->mSwitches[0]->SetClickEvent(ET_GUI_WORLDLEAGUE,2,0,false);
 
 this->mSwitches[1] = new GUIButton(622,606,115,110);
 this->mSwitches[1]->SetTexture(BS_DISABLED,"GUI\\menu_glowne\\forward_disabled",1,10);
 this->mSwitches[1]->SetTexture(BS_NORMAL,"GUI\\menu_glowne\\forward_normal",1,10);
 this->mSwitches[1]->SetTexture(BS_PRESSED,"GUI\\menu_glowne\\forward_presed",1,10);
 this->mSwitches[1]->SetTexture(BS_HOVER,"GUI\\menu_glowne\\forward_rollon",1,10);
 this->mSwitches[1]->SetClickEvent(ET_GUI_WORLDLEAGUE,2,1,false); 
 
}


GUIPanelWorldLeague::~GUIPanelWorldLeague()
{
 delete this->mStatic;
 delete this->mTop; 
 int i;
 for(i = 0 ; i < 12 ; i++)
 {
   delete this->mFlags[i];
 }
 
 for(i = 0 ; i < 2 ; i++)
 {
   delete this->mSwitches[i];
 }
 delete this->mTeamDesc;
}


void GUIPanelWorldLeague::Show()
{
  
  this->mStatic->Show();
  this->mTop->Show();
  this->mFlags[mCurrentFlag]->Show();
  this->mSwitches[0]->Show();
  this->mSwitches[1]->Show();
  this->mTeamDesc->Show();
}



void GUIPanelWorldLeague::Hide()
{
  this->mStatic->Hide();
  this->mTop->Hide();
  this->mFlags[mCurrentFlag]->Hide();
  this->mSwitches[0]->Hide();
  this->mSwitches[1]->Hide();
  this->mTeamDesc->Hide();
}


void GUIPanelWorldLeague::Update()
{
  this->mSwitches[0]->Update();
  this->mSwitches[1]->Update();
  this->mTeamDesc->SetText(teamNames[this->mCurrentFlag]);
}
void GUIPanelWorldLeague::ProcessEvent(Event *event)
{
  if (event->mID == 2)
  {
    this->mFlags[mCurrentFlag]->Hide();
    if (event->mID2 == 1)
    {
      mCurrentFlag++;
      if (mCurrentFlag == 12) mCurrentFlag = 0;
    }
    else
    {
      if (mCurrentFlag == 0) mCurrentFlag = 11;
      else
        mCurrentFlag--;
    }
    this->mFlags[mCurrentFlag]->Show();
  }
}


void GUIPanelWorldLeague::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_SELECTGAME,false,NULL);
}


void GUIPanelWorldLeague::ForwardPressed()
{
  new WorldLeague((eTeams) mCurrentFlag);
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_WORLDLEAGUEMAIN,false,NULL);
}

void GUIPanelWorldLeague::Reload()
{
  for (int i = 0 ; i < 12 ; i++)
  {
    this->mFlags[i]->Reload();
  }
  this->mSwitches[0]->Reload();
  this->mSwitches[1]->Reload();
  this->mTop->Reload();
  this->mStatic->Reload();
}

int GUIPanelWorldLeague::GetReloadCount()
{
  int count = this->mSwitches[0]->GetReloadCount();
  count += this->mSwitches[1]->GetReloadCount();
  count += this->mTop->GetReloadCount();
  count += this->mStatic->GetReloadCount();
  for (int i = 0 ; i < 12 ; i++)
  {
    count += this->mFlags[i]->GetReloadCount();
  }
  return count;
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLeague.h
#ifndef _GUIPANELWORLDLEAGUE_H
#define _GUIPANELWORLDLEAGUE_H



class GUIPanelWorldLeague :public GUIPanel, public EventHandler
{
 GUIIcon *mStatic;
 GUIIcon *mTop;
 GUIIcon *mFlags[12];
 GUIButton *mSwitches[2];
 unsigned char mCurrentFlag;
 GUITextField *mTeamDesc; 
public:
  void ProcessEvent(Event *event);
  GUIPanelWorldLeague();
  virtual ~GUIPanelWorldLeague();
  void Show();
  void Hide();
  void Update();
  void ForwardPressed();
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLeagueStats.cpp
#include "..\..\config.h"

#include <d3dx9effect.h>
#include <assert.h>

#include "..\..\utility\singleton.h"
#include "..\..\utility\defines.h"
#include "..\..\utility\vbmath.H"
#include "..\..\utility\tools.h"
#include "..\..\utility\CTime.h"
#include "..\..\utility\Event.h"
#include "..\..\utility\EventManager.h"
#include "..\..\utility\Eventhandler.h"
#include "..\..\core\Team.h"
#include "..\..\core\Game.h"
#include "..\..\core\WorldLeague.h"
#include "..\..\audio\AudioManager.h"

#include "..\texture.h"
#include "..\SceneObject.h"
#include "..\Camera.h"
#include "..\SceneManager.h"
#include "GUIItems.h"
#include "GUIPanel.h"
#include "GUIPanelWorldLeagueStats.h"


GUIPanelWorldLeagueStats::GUIPanelWorldLeagueStats()
{
//  char buffer[256];
  this->mStatic = new GUIIcon(77,-15,869,586,"GUI\\menu_statistics\\statistics.png");

  memset(this->mTextbuf,0, sizeof(mTextbuf));
  for(int i = 0 ; i < 12; i++)
  {
    this->mFields[i][0] = new GUITextField(151.0f,147.0f + (float)i * 29.0f,100.0f,23.0f);
    this->mFields[i][1] = new GUITextField(865.0f,147.0f + (float)i * 29.0f,100.0f,23.0f);
    for (int j = 0 ; j < 6; j++)
    {
      this->mStats[i][j] = new GUITextField(265.0f + (float)j * 95.0f, 147.0f + (float)i * 29.0f ,80.0f, 23.0f);
      this->mStats[i][j]->SetText(this->mTextbuf[i][j]);
    }
  }
}

GUIPanelWorldLeagueStats::~GUIPanelWorldLeagueStats()
{
  delete this->mStatic;
  for(int i = 0 ; i < 12; i++)
  {
    delete this->mFields[i][0];
    delete this->mFields[i][1];
    for (int j = 0 ; j < 6; j++)
      {
        delete this->mStats[i][j];
      }
  }
}




void GUIPanelWorldLeagueStats::Show()
{
  WorldLeague::Instance()->GetNextMatch();
  this->mVisible = true;
  this->mStatic->Show();
  for(int i = 0 ; i < 12; i++)
  {
    ranking *temp = WorldLeague::Instance()->GetTeamByRanking(i /4 , i % 4);
    my_snprintf(this->mTextbuf[i][0], 5, "%i",temp->matches_won); 
    my_snprintf(this->mTextbuf[i][1], 5, "%i",temp->matches_lost);
    my_snprintf(this->mTextbuf[i][2], 5, "%i",temp->sets_won);
    my_snprintf(this->mTextbuf[i][3], 5, "%i",temp->sets_lost);
    my_snprintf(this->mTextbuf[i][4], 5, "%i",temp->points_won);
    my_snprintf(this->mTextbuf[i][5], 5, "%i",temp->points_lost);
    this->mFields[i][0]->SetText(team3let[temp->team]); 
    this->mFields[i][1]->SetText(team3let[temp->team]);
    this->mFields[i][0]->Show();
    this->mFields[i][1]->Show();
    for (int j = 0 ; j < 6; j++)
      this->mStats[i][j]->Show(); 
  }
}


void GUIPanelWorldLeagueStats::Hide()
{
  this->mVisible = false;
  this->mStatic->Hide();
  for(int i = 0 ; i < 12; i++)
  {
    this->mFields[i][0]->Hide();
    this->mFields[i][1]->Hide();
    for (int j = 0 ; j < 6; j++)
    {
      this->mStats[i][j]->Hide();
    }
  }
}

void GUIPanelWorldLeagueStats::BackwardPressed()
{
  POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_WORLDLEAGUEMAIN,false,NULL);
}

void  GUIPanelWorldLeagueStats::Reload()
{
  this->mStatic->Reload();
}

int GUIPanelWorldLeagueStats::GetReloadCount()
{
  return this->mStatic->GetReloadCount();
}

E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIPanelWorldLeagueStats.h
#ifndef _GUIPANELWORLDLEAGUESTATS_H
#define _GUIPANELWORLDLEAGUESTATS_H


class GUIPanelWorldLeagueStats : public GUIPanel
{
  GUIIcon *mStatic;
  char mTextbuf[12][6][5];
  GUITextField *mStats[12][6];
  GUITextField *mFields[12][2];
public:
  GUIPanelWorldLeagueStats(); 
  ~GUIPanelWorldLeagueStats();
  void Show();
  void Hide();
  void Update(){};
  void BackwardPressed();
  void Reload();
  int GetReloadCount();
};



#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIScore.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"
#include "GUIDef.h"
#include "GUIScore.h"



GUI_score::GUI_score(float x, float y)
{
/*  mx = x;
  my = y;
  char buffer[256];
  for (int i = 0; i <10;i++)
  {
    pNumbers[i] = new CTexture();
    my_snprintf(buffer,256,"score%i.png",i);
    pNumbers[i]->Init(buffer);
    pNumbers[i]->Load(Renderer::Instance()->GetDevice());
  }
  LPDIRECT3DTEXTURE9 tex = pNumbers[0]->GetDXTexture();
  D3DSURFACE_DESC dsc;
  tex->GetLevelDesc(0, &dsc);
  mw = (float)dsc.Width;
  mh = (float)dsc.Height;*/
}

 



void GUI_score::Render(CMatrix4 *pViewProj)
{
 /* simpleVTX Quad[4] =
  {
    {mx    - (1024/2)  ,(768/2)-     my, 0.1f ,0.0f,0.0f}, 
    {mx+mw - (1024/2)  ,(768/2)-     my, 0.1f ,1.0f,0.0f},
    {mx    - (1024/2)  ,(768/2)-(my+mh), 0.1f ,0.0f,1.0f},
    {mx+mw - (1024/2)  ,(768/2)-(my+mh), 0.1f ,1.0f,1.0f}
  };

  D3DXMATRIX mat,mid;
  D3DXMatrixOrthoLH(&mat, 1024,768,0.0f,1.0f);
  D3DXMatrixIdentity(&mid);
  unsigned char temp_score = *mScore;

  int number = temp_score/10;
  HRESULT res;
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_LIGHTING, FALSE);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_WORLD,&mid);
  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_VIEW,&mid);
  res = Renderer::Instance()->GetDevice()->SetTransform(D3DTS_PROJECTION,&mat);
  res = Renderer::Instance()->GetDevice()->SetFVF(D3DFVF_SIMPLE);
//  res = Renderer::Instance()->GetDevice()->SetTexture(0,pNumbers[number]->GetDXTexture());
  res = Renderer::Instance()->GetDevice()->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,&Quad,sizeof(simpleVTX));
  
  for (int i = 0 ; i < 4 ; i++)
  {
    Quad[i].x += mw;
  }
  temp_score -= number*10;
  res = Renderer::Instance()->GetDevice()->SetFVF(D3DFVF_SIMPLE);
  res = Renderer::Instance()->GetDevice()->SetTexture(0,pNumbers[temp_score]->GetDXTexture());
  res = Renderer::Instance()->GetDevice()->DrawPrimitiveUP(D3DPT_TRIANGLESTRIP,2,&Quad,sizeof(simpleVTX));
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_ZFUNC, D3DCMP_LESSEQUAL);
  res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_ALPHABLENDENABLE, FALSE);
   res = Renderer::Instance()->GetDevice()->SetRenderState(D3DRS_LIGHTING, TRUE);*/
}

GUI_score::~GUI_score()
{
  /*for (int i = 0; i <10; i++)
  {
    pNumbers[i]->UnLoad();
    delete pNumbers[i];
  }*/
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUIScore.h
#ifndef _GUISCORE_H
#define _GUISCORE_H

class GUI_score :public SceneObject
{
  HTexture mNumbers[10];
  int mNumberCount;
  unsigned char *mScore; 
  float mx, my;
  float mw, mh;
public:
  GUI_score(float x, float y);
  ~GUI_score();
  void Render(CMatrix4 *pViewProj);
  void SetScoreVar(unsigned char *score) {mScore = score;}
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUISlider.cpp
#include "..\..\config.h"

#include <crtdbg.h>
#include <assert.h>
#include <d3dx9.h>
#include <dinput.h>

#include "..\..\utility\Misc.h"
#include "..\..\utility\Profile.h"
#include "..\..\utility\Singleton.h"

#include "..\..\utility\ctime.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\vbmath.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include "..\renderer.h"
#include "..\camera.h"
#include "..\sceneobject.h"
#include "..\scenemanager.h"
#include "..\meshManager.h"

#include "..\..\input\mapper.h"
#include "..\..\input\input.h"


#include "GUIItems.h"





GUISlider::GUISlider(float x0, float y0, float w, float h, float *target_var, unsigned char steps)
                           :GUIObject(x0,y0,w,h), mTarget(target_var), mSteps(steps)
                          
{

 this->mBackground = new GUIIcon(x0,y0+h/3,w,h/3,"GUI\\menu_video\\skrol_pasek.png");
 this->mGlider = new GUIIcon(x0, y0, h,h, "GUI\\menu_video\\skrol_normal_0.png");
 this->mLeft = new GUIIcon(-mh+x0,y0 , mh,mh,"GUI\\menu_video\\strzalka_lewo.png"); 
 this->mRight = new GUIIcon(mw+x0,y0 , mh,mh,"GUI\\menu_video\\strzalka_prawo.png");
 mHovered = false;
 this->mCounter = 30;
}

GUISlider::~GUISlider()
{
  delete this->mBackground;
  delete this->mGlider; 
  delete this->mLeft;
  delete this->mRight;
}


void GUISlider::Show()
{
  *mTarget = ROUND (*mTarget * (float) mSteps) / (float) mSteps;
  this->mGlider->SetDimensions(*mTarget * mw - mh/2 + mx, my, mh,mh);
  this->mBackground->Show();
  if (this->mSteps)
  {
    this->mGlider->Show();
    this->mLeft->Show();
    this->mRight->Show();
  }
}


void GUISlider::Hide()
{
  this->mBackground->Hide();
  if (this->mSteps)
  {
    this->mGlider->Hide();
    this->mLeft->Hide();
    this->mRight->Hide();
  }
}



void GUISlider::Update()
{
  float mouse_x = Input::Instance()->total_mouse_x;
  float mouse_y = Input::Instance()->total_mouse_y;
  if (!this->mSteps) return;

  if ( mouse_y > my && mouse_y < (my + mh) )
  {
    if (mouse_x > mx && mouse_x < (mx + mw))
    {
      if (Input::Instance()->wlaczonyl)
      {
        if (mHovered)
        {
          float temp = (mouse_x - mx) / (mw );
          *mTarget = ROUND (temp * (float) mSteps) / (float) mSteps; 
          this->mGlider->SetDimensions(*mTarget * mw - mh/2 + mx , my, mh,mh);
        }
      }
      else
      {
        mHovered = true;
      }
    }
    else
    {return;
      if (mouse_x > (mx - mh) && mouse_x < mx)
      {
        if (Input::Instance()->wlaczonyl)
        {
          if (mCounter)
          {
            mCounter--;
          }
          else
          {
            unsigned char val = (unsigned char)(*this->mTarget * (float)this->mSteps);
            val = MAX((val + 1),this->mSteps);
            *this->mTarget = (float) val/(float)this->mSteps;
            this->mCounter = 0;
          }
        }
      }
      if (mouse_x > (mx + mw) && mouse_x < (mx + mw + mh))
      {
        if (Input::Instance()->wlaczonyl)
        {
          if (mCounter)
          {
            mCounter--;
          }
          else
          {
            unsigned char val = unsigned char(*this->mTarget * (float)this->mSteps);
            val = MIN((val - 1),0);
            *this->mTarget = (float) val/(float)this->mSteps;
            this->mCounter = 0;
          }
        }
      }
    }
  }
  else
  {
    mCounter = 0;
    mHovered = false;
  }
}

int GUISlider::GetReloadCount()
{
  int count = this->mBackground->GetReloadCount();
  count += this->mGlider->GetReloadCount();
  count += this->mRight->GetReloadCount();
  count += this->mLeft->GetReloadCount();
  return count;
}

void GUISlider::Reload()
{
  this->mBackground->Reload();
  this->mGlider->Reload();
  this->mRight->Reload();
  this->mLeft->Reload();
}


void GUISlider::SetClinable(bool cl)
{
  this->mBackground->SetClinable(cl);
  this->mGlider->SetClinable(cl);
  this->mLeft->SetClinable(cl);
  this->mRight->SetClinable(cl);
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUISlider.h
#ifndef _GUISLIDER_H
#define _GUISLIDER_H





//-----------------------------------------------------------------------------
// CTextureRenderer Class Declarations
//-----------------------------------------------------------------------------



class GUISlider :public GUIObject
{
  GUIIcon *mBackground;
  GUIIcon *mGlider;
  GUIIcon *mLeft,*mRight;
  float *mTarget;
  unsigned char mSteps;
  bool mHovered;
  unsigned char mCounter;
public:
  GUISlider(float x0, float y0, float w, float h, float *target_var, unsigned char steps);
  ~GUISlider();
  void Update();
  void Show();
  void Hide();
  void Reload();
  int GetReloadCount();
  void SetClinable(bool cl);
};


#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUITextField.cpp
#include "..\..\config.h"
#include <assert.h>
#include "..\..\utility\defines.h"
#include "..\..\utility\misc.h"
#include "..\..\utility\singleton.h"
#include "..\..\utility\vbmath.h"
#include "..\..\utility\tools.h"
#include "..\..\utility\Logger.h"

#include "..\..\Utility\Event.h"
#include "..\..\Utility\EventManager.h"
#include "..\..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "..\renderer.h"
#include "..\Camera.h"
#include "..\ShaderManager.h"
#include "..\Texture.h"
#include "..\TextureManager.h"
#include "..\meshmanager.h"
#include "..\SceneObject.h"
#include "..\SceneManager.h"
#include "GUIDef.h"
#include "GUIScore.h"
#include "GUIObject.h"
#include "..\BmpFont.h"
#include "GUITextField.h"




GUITextField::GUITextField(float x,float y, float w, float h,align_type alignment)
                           :GUIObject(x,y,w,h, 0,true)                            
{
  this->mText = NULL;
  this->mFont = new CBmpFont();
  this->mFont->Init(Renderer::Instance()->GetDevice());
  this->mFont->LoadFont("arialblack");
  mAlignment = alignment;
}

GUITextField::~GUITextField()
{
  delete this->mFont;
}


void GUITextField::Render(CMatrix4 *pViewProj)
{
  if (mText == NULL ) return;
  float xscale;
  float yscale;
  this->mFont->StrSize(mText,1.0f,&xscale,&yscale);
  if (xscale > this->mw)
    yscale *= xscale/(mw);
  CVector3 pos(mx ,768 - my ,0.0f);
  CVector3 scale(mh/yscale,mh/yscale,0.0f);

  D3DXMATRIX mat, mid;
  D3DXMatrixOrthoOffCenterLH(&mat, 0, 1024, 0,768, 0.0f,1.0f);
  D3DXMatrixIdentity(&mid);

  Renderer::Instance()->GetDevice()->SetTransform(D3DTS_VIEW,&mid);
  Renderer::Instance()->GetDevice()->SetTransform(D3DTS_PROJECTION, &mat);
  mFont->Print(&pos,&scale,mAlignment,mText);
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GUITextField.h
#ifndef _GUITEXTFIELD_H
#define _GUITEXTFIELD_H


class CBmpFont;
class GUITextField :public GUIObject
{
  CBmpFont *mFont;
  char  *mText;
  align_type mAlignment;
public:
  GUITextField(float x, float y, float w, float h, align_type alignment = ALIGN_CENTER);
  ~GUITextField();
  void Render(CMatrix4 *pViewProj);
  void SetText(char *text) {mText = text;}
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI\GuiVideoQuad.cpp
#include "..\..\config.h"

#include <crtdbg.h>
#include <assert.h>
#include <d3dx9.h>




#include "..\..\utility\Misc.h"
#include "..\..\utility\Profile.h"
#include "..\..\utility\Singleton.h"
#include "..\..\utility\ctime.h"
#include "..\..\utility\vbmath.h"

#include "..\..\utility\event.h"
#include "..\..\utility\eventmanager.h"
#include "..\..\utility\eventhandler.h"

#include "..\..\utility\event.h"
#include "..\..\utility\eventmanager.h"
#include "..\..\utility\eventhandler.h"

#include "..\renderer.h"
#include "..\camera.h"
#include "..\sceneobject.h"
#include "..\scenemanager.h"
#include "..\meshManager.h"
#include "..\texture.h"



#include "GUIItems.h"





GUIVideoQuad::GUIVideoQuad(float x0, float y0, float w, float h, char *meshname,char * filename, bool silent,
                           unsigned long FinishEventTarget, unsigned long FinishEventID, bool looping)
                           :GUIObject(x0,y0,w,h,0,true)
                          
{
  this->mCurrentTexture = CMeshManager::Instance()->GetVideoTextureHandler(filename,silent,FinishEventTarget,FinishEventID,looping); 
  this->mQuad = CMeshManager::Instance()->GetMeshHandlerLoad(meshname);
  this->mOriginalTexture = CMeshManager::Instance()->GetTextureHandler("quad.gif"); 
  this->RebuildMatrix();
  CMeshManager::Instance()->GetTexture(this->mCurrentTexture)->Touch();
}

GUIVideoQuad::~GUIVideoQuad()
{

  CTexture *temp = CMeshManager::Instance()->GetTexture(this->mCurrentTexture);
  temp->UnLoad();
}


E:\Project\Kopia (5) VBEngine\Graphics\GUI\GuiVideoQuad.h
#ifndef _GUIVIDEOQUAD_H
#define _GUIVIDEOQUAD_H





//-----------------------------------------------------------------------------
// CTextureRenderer Class Declarations
//-----------------------------------------------------------------------------



class GUIVideoQuad :public GUIObject
{
public:
  GUIVideoQuad(float x0,float y0, float w,float h,char *meshname, char *filename, bool silent = true,
               unsigned long FinishEventTarget = 0,unsigned long FinishEventID = 0,bool looping = true);
  ~GUIVideoQuad();
};


#endif 
E:\Project\Kopia (5) VBEngine\Graphics\GUI.cpp
#include "..\config.h"
#include <assert.h>
#include "..\utility\defines.h"
#include "..\utility\misc.h"
#include "..\utility\singleton.h"
#include "..\utility\vbmath.h"
#include "..\utility\tools.h"
#include "..\utility\Logger.h"
#include "..\utility\profile.h"
#include "..\Utility\CTime.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"

#include <d3dx9effect.h>
#include "renderer.h"
#include "Camera.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "meshmanager.h"
#include "SceneObject.h"
#include "SceneManager.h"


#include "..\Core\Ball.h"
#include "GUI\GUIItems.h"
#include "GUI.h"



#include "GUI\GUIVideoQuad.h"
#include "GUI\GUIIcon.h"
#include "GUI\GUIForceSlider.h"
#include "GUI\GUIScore.h"

#include "GUI\GUIDef.h"
#include "GUI\GUIPanelMainMenu.h"
#include "GUI\GUIPanelSelectGame.h"
#include "GUI\GUIPanelFriendly.h"
#include "GUI\GUIPanelWorldLeague.h"
#include "GUI\GUIPanelWorldLadder.h"
#include "GUI\GUIPanelEuroLadder.h"
#include "GUI\GUIPanelWorldFinal.h"
#include "GUI\GUIPanelEuroLeague.h"
#include "GUI\GUIPanelOptions.h"
#include "GUI\GUIPanelOptionsSound.h"
#include "GUI\GUIPanelOptionsVideo.h"
#include "GUI\GUIPanelControls.h"
#include "GUI\GUIPanelGamePlay.h"
#include "GUI\GUIPanelMatchOver.h"
#include "GUI\GUIPanelLeagueOver.h"
#include "GUI\GUIPanelSetOver.h"
#include "GUI\GUIPanelInGameMenu.h"
#include "GUI\GUIOverlay.h"
#include "GUI\GUIPanelWorldLeagueStats.h"
#include "GUI\GUIPanelEuroLeagueStats.h"
#include "GUI\GUIPanelStadium.h"

#include "..\core\Team.h"
#include "..\core\game.h"

void GUI::DisplayLoadingScreen()
{
  //GUIIcon Loading(1,1,1024,768,"loading2.png");
  //GUIIcon Bar(12,700,0.0001f,25,"gradient.png");
  if (this->mMenuMusicPlaying)
  {
    this->mMenuMusicPlaying = false;
    POST_EVENT(ET_AUDIO, LAST_AUDIO, true, NULL);
  }

  Loading->Show();
 
  if(this->loading_count)
  {
    float w = (1000.0f / this->loading_total_count) * (this->loading_total_count - this->loading_count);
    Bar->SetDimensions(12,730,w,25);
    Bar->Show();
  }
  
  Renderer::Instance()->BeginRender();
      
  //res = Renderer::Instance()->GetDevice()->BeginScene();
  //res = Renderer::Instance()->GetDevice()->Clear(0,0,D3DCLEAR_TARGET | D3DCLEAR_STENCIL |D3DCLEAR_ZBUFFER,0,1.0f,0);

  
  Loading->Render(NULL);
  if(this->loading_count)
  {
    Bar->Render(NULL);
  }
  //res = Renderer::Instance()->GetDevice()->EndScene();
  Renderer::Instance()->EndRender();

  if(Bar->IsVisible())
  {
    Bar->Hide();
  }
  Loading->Hide();
}

unsigned char OverlayStatus[GUIP_PANEL_COUNT] = 
{
  OBS_OVERLAY ,                               
  OBS_OVERLAY | OBS_BUTTON_B,                 
  OBS_OVERLAY | OBS_BUTTON_B,                 
  OBS_OVERLAY | OBS_BUTTON_B,                 
  OBS_OVERLAY | OBS_BUTTON_B,                 
  OBS_OVERLAY | OBS_BUTTON_B,                 
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  OBS_OVERLAY | OBS_BUTTON_B | OBS_BUTTON_F,  
  0,              
  OBS_OVERLAY | OBS_BUTTON_B,
  OBS_OVERLAY | OBS_BUTTON_F,
  0,
  0,
  0,
  0,
  OBS_OVERLAY | OBS_BUTTON_B
};                                            



GUI::GUI() :EventHandler(ET_GUI)
{
  this->loading_count = 0;
  this->loading_total_count = 0;

  this->Loading = new GUIIcon(1,1,1024,768,"GUI\\loading.png");
  this->Loading->SetClinable(false); 
  this->Bar = new GUIIcon(12,730,0.0001f,25,"load_bar.png");
  this->Bar->SetClinable(false);
  this->loading_count = 208;
  this->loading_total_count = 208;

  this->Bar->Hide();
  this->Loading->Hide();
  this->mMenuMusicPlaying = false;
     

  DisplayLoadingScreen();

  this->mCurrentPanel = GUIP_MAINMENU;
  memset(mPanels,0,sizeof(mPanels));
  this->mPanels[mCurrentPanel] = new GUIPanelMainMenu(); 
  this->mPanels[GUIP_SELECTGAME] = new GUIPanelSelectGame(); 
  this->mPanels[GUIP_OPTIONS] = new GUIPanelOptions(); 
  this->mPanels[GUIP_SOUND] = new GUIPanelOptionsSound();
  this->mPanels[GUIP_VIDEO] = new GUIPanelOptionsVideo();
  this->mPanels[GUIP_CONTROLS] = new GUIPanelControls();
  this->mPanels[GUIP_FRIENDLYSELECT] = new GUIPanelFriendly();
  this->mPanels[GUIP_WORLDLEAGUESELECT] = new GUIPanelWorldLeague();
  this->mPanels[GUIP_WORLDLEAGUEMAIN] = new GUIPanelWorldLadder();
  this->mPanels[GUIP_EUROLEAGUESELECT] = new GUIPanelEuroLeague();
  this->mPanels[GUIP_EUROLEAGUEMAIN] = new GUIPanelEuroLadder();
  this->mPanels[GUIP_GAMEPLAY] = new GUIPanelGamePlay();
  this->mPanels[GUIP_WORLDLEAGUEMATCHOVER] = new GUIPanelWorldLeagueStats();
  this->mPanels[GUIP_EUROLEAGUEMATCHOVER] = new GUIPanelEuroLeagueStats();
  this->mPanels[GUIP_WORLDLEAGUEFINAL] = new GUIPanelWorldFinal();
  this->mPanels[GUIP_INGAMEMENU] = new GUIPanelInGameMenu();
  this->mPanels[GUIP_SETOVER] = new GUIPanelSetOver();
  this->mPanels[GUIP_MATCHOVER] = new GUIPanelMatchOver();
  this->mPanels[GUIP_LEAGUEOVER] = new GUIPanelLeagueOver();
  this->mPanels[GUIP_STADIUMS]  = new GUIPanelStadium();
  this->mCursor = new GUICursor();
  this->mOverlay = new GUIPanelOverlay();

  this->mIntro = new GUIVideoQuad(0,0,1024,768,"IntroQuad.x","Video\\intro.avi",false,ET_GUI,GUIE_FINISH_INTRO,FALSE);
  this->mIntro->Show();
  this->mForceSliderVisible = false;
  this->mEscPressed = this->mYesPressed = this->mNoPressed = false;
}
void GUI::ReAddCursorToScene()
{
  mCursor->Hide();
  mCursor->Show();
}
GUI::~GUI()
{
  delete Loading;
  delete Bar;
  delete mOverlay;
  delete mCursor;
  for (int i = 0 ; i < GUIP_PANEL_COUNT ; i++)
  {
    if (mPanels[i]) delete mPanels[i];
  }
  
}

void GUI::Update()
{
  PROFILE(GUI_update);
  this->mPanels[mCurrentPanel]->Update();
  this->mCursor->Update();
  this->mOverlay->Update();
  this->mEscPressed = this->mYesPressed = this->mNoPressed = false;
  if (this->mMenuMusicPlaying)
  {
    if (CGame::Instance() || this->mIntro)
    {
      this->mMenuMusicPlaying = false;
      POST_EVENT2(ET_AUDIO, MUSIC_1,0, true, NULL);
    }
  }
  else
  {
    if (CGame::Instance() == NULL && this->mIntro == NULL)
    {
      this->mMenuMusicPlaying = true;
      POST_EVENT2(ET_AUDIO, MUSIC_1,1, true, NULL);
    }
  }
  this->loading_total_count = this->loading_count = 0;
}


void GUI::ProcessEvent(Event *event)
{

  switch (event->mID)
  {
  case GUIE_HIDE_GUI: 
    {
      mPanels[mCurrentPanel]->Hide();
      mOverlay->Hide();
      mCursor->Hide();
      break;
    }
  case GUIE_SHOW_PANEL_WITH_RELOAD:
  {
    GUIPanelID newPanel = (GUIPanelID)event->mID2;
    bool overlay = (OverlayStatus [newPanel] & OBS_OVERLAY ) != 0;
    int count = mPanels[newPanel]->GetReloadCount();      
    if(count > 0)
    {
      if (overlay) count += this->mOverlay->GetReloadCount();
      POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, count, true, NULL);
      if (overlay) this->mOverlay->Reload();
      mPanels[newPanel]->Reload();
    }
  }
  case GUIE_SHOW_PANEL:
    {
      mPanels[mCurrentPanel]->Hide();
      mCursor->Hide();
      mCurrentPanel = (GUIPanelID)event->mID2;
      if (event->mData) mPanels[mCurrentPanel]->GetPassedData(event->mData);

      this->mOverlay->SetButtons(OverlayStatus[mCurrentPanel]);
      if (this->mOverlay->IsVisible())
        this->mOverlay->Hide();

      if ((OverlayStatus [mCurrentPanel] & OBS_OVERLAY ) != 0)
        this->mOverlay->Show();
       mPanels[mCurrentPanel]->Show();
       if (mCurrentPanel != GUIP_GAMEPLAY) 
       {
         mCursor->Show();  
       }    
    }
  break;
  case GUIE_PREV_PRESSED:
    {
      mPanels[mCurrentPanel]->BackwardPressed();
      break;
    }
  case GUIE_NEXT_PRESSED:
    {
      mPanels[mCurrentPanel]->ForwardPressed();
      break;
    }
  case GUIE_FINISH_INTRO:
    {
     
     StopIntro();
     break;
    }
  case GUIE_ESC_PRESSED:
    {
      if (this->mIntro)
      {
        StopIntro();
      }
      this->mEscPressed = true;
      break;
    }
  case GUIE_YES_PRESSED:
    {
      this->mYesPressed = true;
      break;
    }
  case GUIE_NO_PRESSED:
    {
      this->mNoPressed = true;
      break;
    }
  case GUIE_PLAY_OUTRO:
    {
      this->PlayOutro();
      break;
    }
  case GUIE_SET_LOAD_COUNT:
    this->loading_count = 0;
    CMeshManager::Instance()->GetTextureHandlerLoad("GUI\\loading.png");
    CMeshManager::Instance()->GetTextureHandlerLoad("load_bar.png");
    CMeshManager::Instance()->GetMeshHandlerLoad("quad.x");
    
    //this->DisplayLoadingScreen();
    this->loading_count = event->mID2;
    this->loading_total_count = this->loading_count;
    break;
  case GUIE_DEC_LOAD_COUNT:
    {
      this->loading_count--;
      if(this->loading_count < 0)
      {
        this->loading_count = 0;
      }
      else
      {
        this->DisplayLoadingScreen();
      }
    }
    break;
  }
}

void GUI::SetGamePhase(int phase)
{
  mGamePhase = phase;
}

void GUI::StopIntro()
{
  this->mIntro->Hide();
  delete this->mIntro;
  this->mIntro = NULL;
  this->mPanels[mCurrentPanel]->Show();
  this->mCursor->Show();
  this->mOverlay->Show();
  this->mOverlay->SetButtons(OverlayStatus[mCurrentPanel]);
  POST_EVENT2(ET_AUDIO, MUSIC_1,1, false, NULL);
}



void GUI::ResetOverlay(unsigned char status)
{
  this->mOverlay->SetButtons(status);
}

void GUI::PlayOutro()
{
  POST_EVENT2(ET_AUDIO, MUSIC_1,0, false, NULL);
   mPanels[mCurrentPanel]->Hide();
   mOverlay->Hide();
   mCursor->Hide();
   if (this->mIntro)
   {
     delete this->mIntro;
   }
   this->mIntro = new GUIVideoQuad(0,0,1024,768,"CreditsQuad.x","Video\\credits.avi",false,ET_GUI,GUIE_FINISH_INTRO,FALSE);
   this->mIntro->SetLevel(-50);
   this->mIntro->Show();
}


void GUI::Reload()
{
 for (int i = 0 ; i < GUIP_PANEL_COUNT ; i++)
  {
    if (mPanels[i]) mPanels[i]->Reload();
  }

  this->mOverlay->Reload();
}
E:\Project\Kopia (5) VBEngine\Graphics\GUI.h
#ifndef _GUI
#define _GUI


class GUIVideoQuad;
enum PlayPhase
{
  PP_SERVING = 0,
  PP_PLAY,
  PP_ATTACK
};

// panele w grze
enum GUIPanelID
{
  GUIP_MAINMENU,
  GUIP_OPTIONS,
  GUIP_VIDEO,
  GUIP_SOUND,
  GUIP_CONTROLS,
  GUIP_SELECTGAME,
  GUIP_WORLDLEAGUESELECT,
  GUIP_WORLDLEAGUEMAIN,
  GUIP_EUROLEAGUESELECT,
  GUIP_EUROLEAGUEMAIN,
  GUIP_FRIENDLYSELECT,
  GUIP_STADIUMS,
  GUIP_GAMEPLAY,
  GUIP_WORLDLEAGUEMATCHOVER,
  GUIP_WORLDLEAGUEFINAL,
  GUIP_SETOVER,
  GUIP_MATCHOVER,
  GUIP_INGAMEMENU,
  GUIP_LEAGUEOVER,
  GUIP_EUROLEAGUEMATCHOVER,
  GUIP_PANEL_COUNT
};


enum GUIEvents
{
  GUIE_HIDE_GUI = 1,
  GUIE_SHOW_PANEL,
  GUIE_PREV_PRESSED,
  GUIE_NEXT_PRESSED,
  GUIE_FINISH_INTRO,
  GUIE_ESC_PRESSED,
  GUIE_YES_PRESSED,
  GUIE_NO_PRESSED,
  GUIE_PLAY_OUTRO,
  GUIE_SET_LOAD_COUNT,
  GUIE_DEC_LOAD_COUNT,
  GUIE_SHOW_PANEL_WITH_RELOAD
};

enum OverlayButtonStates
{ 
  OBS_BUTTON_F = BIT(0),
  OBS_BUTTON_B = BIT(1),
  OBS_OVERLAY  = BIT(2)
};




class GUIPanel;
class GUIObject;
class GUIPanelOverlay;
class GUIIcon;

class GUI : public Singleton<GUI>, EventHandler
{
  GUIPanel  *mPanels[GUIP_PANEL_COUNT];
  GUIPanelID mCurrentPanel;
  GUIObject *mCursor;
  GUIPanelOverlay *mOverlay;
  int mGamePhase;
  int loading_count, loading_total_count;
  GUIVideoQuad *mIntro;
  GUIIcon *Loading, *Bar;
  bool mMenuMusicPlaying;
public:
  float mBallForce;
  bool mForceSliderVisible;
  bool mEscPressed,mYesPressed,mNoPressed;
   GUI();
   ~GUI();
   int GetGamePhase() {return mGamePhase;}
   GUIPanelID GetCurrentPanel() {return mCurrentPanel;}
   void SetCurrentPanel(GUIPanelID panel); 

 //  void SetScoreVar(int team, unsigned char *score);
//   void ShowPowerBar();
   void HidePowerBar() {mForceSliderVisible = false;}
   void SetGamePhase(int phase);
   void SetBallForce(float force) {mForceSliderVisible = true; mBallForce = force;}
   void DisplayLoadingScreen();
 //  void ShowSetWinnerScreen(unsigned char winner, unsigned char score0, unsigned char score1);
 //  void ShowMatchWinnerScreen(unsigned char winner, unsigned char score0, unsigned char score1);
 //  void HideWinnerScreens();
   void ReAddCursorToScene();
   // update -> robi update aktualnego panela
   void Update();

   void ProcessEvent(Event *event);
   bool IsIntroRunning() { return mIntro != NULL;}
   void StopIntro();
   void ResetOverlay(unsigned char status);

   bool CanBrakeLights() {return GUIP_INGAMEMENU != this->mCurrentPanel;} 
   void PlayOutro();
   void Reload();
};


#endif /* _CMESH */
E:\Project\Kopia (5) VBEngine\Graphics\Material.cpp
#include "..\config.h"

//#include <d3d9.h>
#include <d3dx9effect.h>
#include <string.h>
#include <assert.h>

#include "..\utility\vbmath.h"
#include "..\utility\Defines.h"
#include "..\utility\tools.h"


#include "TextureManager.h"
#include "Shader.h"
#include "ShaderManager.h"

#include "Material.h"

/* Konstuktor */
CMaterial::CMaterial()
{
  this->name[0] = '\0';
  for(int i = 0; i < MAX_TEXTURES_IN_MATERIAL; i++)
  {
    this->pTextures[i] = DEFAULT_TEXTURE;
  }
  this->tex_stage_num = 1;
  this->Shader = SHADER_NONE;

#ifdef USE_MATERIAL

  this->Diffuse.Set(1.0f, 1.0f, 1.0f, 1.0f);

#ifdef USE_AMBIENT
  this->Ambient.Set(1.0f, 1.0f, 1.0f, 1.0f);
#endif

#ifdef USE_SPECULAR
  this->Specular.Set(1.0f, 1.0f, 1.0f, 1.0f);
#endif
#endif

} /* end of : Konstruktor */

/* Dekonstuktor */
CMaterial::~CMaterial()
{
  /* Pusty : Nie ma tu nic rezerwowanego dynamicznie */
} /* end of : DeKonstruktor */

/*
 * Prorwnaj zadan¹ nazwe z nazw¹ naszego materialu  (funkcja pomocnicza dla material menagera)
 * zwraza True jesli sa to te same nazwy.
 */
bool CMaterial::Cmp(const char *m_name)
{
  return (m_name && m_name[0] != '\0' && stricmp(this->name, m_name)==0);
}

/*
 * Inicjalizator
 * Skopiowanie nazwy do wlasnego buffora z nazwa (nazwa moze miec max MAX_FILE_NAME znaków)
 */
void CMaterial::Init(const char *m_name)
{
  my_snprintf(this->name, MAX_FILE_NAME, "%s", m_name);
} /* end of : Init */

/*
 * Dodanie grupy textur i ustawienie licznika stage-ow na wielkosc tej grupy.
 * Jesli podana ilosc stage-ow jest równa 0 to cala tablica jest ustawiana na DEFAULT_TEXTURE.
 */
void CMaterial::AddTextures(HTexture *pText, unsigned int stages)
{
  if(stages > MAX_TEXTURES_IN_MATERIAL)
  {
    stages = MAX_TEXTURES_IN_MATERIAL;
  }
  this->tex_stage_num = stages;
  if(stages)
  {
    memcpy(this->pTextures, pText, stages * sizeof(HTexture));
  }
  else
  {
    memset(this->pTextures, DEFAULT_TEXTURE, MAX_TEXTURES_IN_MATERIAL * sizeof(HTexture));
  }
} /* end of : Init */

/*
 * Dodanie nowej textury na koncu tablicy i zwiekrzenie licznika stage - ow.
 */
void CMaterial::AddTexture(HTexture Tex)
{
  if(this->tex_stage_num < MAX_TEXTURES_IN_MATERIAL)
  {
    this->pTextures[this->tex_stage_num++] = Tex;
  }
} /* end of : AddTexture */

/*
 * Ustawienie danego materialu jako obecnie obowiazujacego.
 * Czyli przekazanie wszystkich przechowywanych tu inforamcji do ustawionego shadera
 */
void CMaterial::SetMaterial(CTextureManager *pTM, CShaderManager *pSM)
{
  if(pTM && pSM && pSM->HasShader(this->Shader))
  {
    pSM->GetShader(this->Shader)->SetMaterial(this, pTM);
  }
} /* end of : SetMaterial */

E:\Project\Kopia (5) VBEngine\Graphics\Material.h
#ifndef _CMATERIAL_H
#define _CMATERIAL_H

/*
class       : CMaterial
description : Klasa Materialu obslugjaca podstawowe czynnosci przetwazajace materialy.
              Przechowujemy tutaj wiadomosci o shadeze renderujacym ,
              ilosci i rodzaju textur oraz paramateów koloru poszczegulnuch skladowych dla
              danego Materialu.               
methods     :
              CMaterial()    - konstruktor
              ~CMaterial()   - destruktor
              Cmp(...)  - porównanie szukaneej nazwy materialu z naszym bufforem nazwy.
              Init(...) - kopiuje nazwe materialu do wlasnego buffora
              AddTextures(...) - dodanie grupy textur i ustawienie licznika stage-ow na wielkosc tej grupy.
                                 jesli podana ilosc stage-ow jest równa 0 to cala tablica jest ustawiana na 
                                 DEFAULT_TEXTURE.
              AddTexture(...) - dodanie nowej textury na koncu tablicy i zwiekrzenie licznika stage - ow 
              SetMaterial(...) - ustawienie danego materialu jako obecnie obowiazujacego
*/

class CTextureManager;
class CShaderManager;

class CMaterial
{
  char name[MAX_FILE_NAME];         /* nazwa materialu */
  HTexture pTextures[MAX_TEXTURES_IN_MATERIAL]; /* tablica textur "stage-ow" (z TM) wykozystana w naszym Materiale */
  unsigned int tex_stage_num;                   /* ilosc "stage-ow" wykozystana w naszym materiale. */
  HShader Shader;                               /* handler shadera (z SM) renderujacego dany material */

#ifdef USE_MATERIAL
  CVector4 Diffuse;                             /* wartosc skladowej : Diffuse danego materialu */
#ifdef USE_AMBIENT
  CVector4 Ambient;                             /* wartosc skladowej : Ambient danego materialu */
#endif
#ifdef USE_SPECULAR
  CVector4 Specular;                            /* wartosc skladowej : Specular danego materialu */
#endif
#endif

public:
  CMaterial();
  ~CMaterial();
  bool Cmp(const char *m_name);

  void Init(const char *m_name);
  void SetShader(HShader hd) {this->Shader = hd;};
  HShader GetShader(void) {return this->Shader;};
  unsigned int GetStageNum(void) {return this->tex_stage_num;};
  void AddTextures(HTexture *pTexs, unsigned int stages_num);
  void AddTexture(HTexture pTexs);
  HTexture GetTexture(unsigned int tex)
  {
    if (tex < this->tex_stage_num)
      return this->pTextures[tex];
    return DEFAULT_TEXTURE;
  };
  void SetMaterial(CTextureManager *pTM, CShaderManager *pSM);
  void SetTextureStages(unsigned int stages) {this->tex_stage_num = stages;}
#ifdef USE_MATERIAL
  CVector4 * GetDiffuse(void) {return &this->Diffuse;};
  void SetDiffuse(CVector4 *dif) {this->Diffuse.Set(dif);};
  void SetDiffuse(float r, float g, float b, float a) {this->Diffuse.Set(r, g, b, a);};
#ifdef USE_AMBIENT
  CVector4 * GetAmbient(void) {return &this->Ambient;};
  void SetAmbient(CVector4 *amb) {this->Ambient.Set(amb);};
  void SetAmbient(float r, float g, float b, float a) {this->Ambient.Set(r, g, b, a);};
#endif
#ifdef USE_SPECULAR
  CVector4 * GetSpecular(void) {return &this->Specular;};
  void SetSpecular(CVector4 *spe) {this->Specular.Set(spe);};
  void SetSpecular(float r, float g, float b, float a) {this->Specular.Set(r, g, b, a);};
#endif
#endif
};


#endif /* _CMATERIAL_H */
E:\Project\Kopia (5) VBEngine\Graphics\MaterialManager.cpp
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>
#include <string.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\Utility\logger.h"
#include "..\Utility\misc.h"
#include "..\utility\vbmath.h"

#include "..\Utility\Singleton.h"
#include "..\FileSystem\FileNode.h"
#include "..\FileSystem\BranchNode.h"
#include "..\FileSystem\FileSystem.h"

#include "Renderer.h"
#include "Texture.h"
#include "TextureManager.h"
#include "Shader.h"
#include "ShaderManager.h"

#include "Material.h"
#include "MaterialManager.h"

/* format materialu jaki jest przechowywany w DataFile */
struct Material
{
  char name[MAX_FILE_NAME];
  char texture_files[MAX_TEXTURES_IN_MATERIAL][MAX_FILE_NAME];
  float ambient[4];
  float diffuse[4];
  char effect[MAX_FILE_NAME];
  unsigned char texture_stages;
  unsigned char padding[3];
};

/* Konstuktor */
CMaterialManager::CMaterialManager(CTextureManager *pTM, CShaderManager *pSM)
{
  char *data = (char*)FileSystem::Instance()->LoadFile(".\\_Materials_");
  if (data != NULL)
  {
    unsigned int count = (*(DWORD*)data);
    data +=4;
    Material *mattable = ((Material*)data);
    this->Max_Material_Count = count;
    this->pMaterialTab = (CMaterial **)calloc(this->Max_Material_Count, sizeof(CMaterial *));
    for (unsigned int i = 0; i < Max_Material_Count ; i++)
    {
      pMaterialTab[i] = new CMaterial();
      pMaterialTab[i]->Init(mattable[i].name); 
#ifdef USE_MATERIAL
      pMaterialTab[i]->SetDiffuse(mattable[i].diffuse[0], mattable[i].diffuse[1],mattable[i].diffuse[2],
                                  mattable[i].diffuse[3]);
#ifdef USE_AMBIENT
      pMaterialTab[i]->SetAmbient(mattable[i].ambient[0], mattable[i].ambient[1],mattable[i].ambient[2],
                                  mattable[i].ambient[3]);
#endif
#endif
      pMaterialTab[i]->SetTextureStages(0);/* Prepare to add New Stages */
      if (mattable[i].texture_stages != 0)
      {
        for( int j = 0 ; j < mattable[i].texture_stages; j++)
        {
          pMaterialTab[i]->AddTexture( pTM->GetTextureHandler(mattable[i].texture_files[j]) );  
        }
      }
      else
      {
        pMaterialTab[i]->AddTexture(DEFAULT_TEXTURE);
      }
      pMaterialTab[i]->SetShader(pSM->GetShaderHandler(mattable[i].effect)); 
    }
  }
  else
  {
    this->Max_Material_Count = 10;
    this->pMaterialTab = (CMaterial **)calloc(this->Max_Material_Count, sizeof(CMaterial *));
  }
} /* end of : Konstruktor */

/* Dekonstuktor: wyladowywuje Materialu z pamieci */
CMaterialManager::~CMaterialManager()
{
  HMaterial hd = 0;

  while(this->HasMaterial(hd))
  {
    delete this->pMaterialTab[hd];
    this->pMaterialTab[hd++] = NULL;
  }
  free(this->pMaterialTab);

} /* end of : DeKonstruktor */

/*
 * Pobranie (nowego) handlera do materialu o podanej nazwie
 * 
 * Jesli nie posiadamy jeszcze danego materialu to nowy element jest dodawany do tablicy Matrialow
  */
HMaterial CMaterialManager::GetMaterialHandler(const char *name)
{
  HMaterial hd = 0;

  /* szuka istniej¹cego effectu w tablicy */
  while(this->HasMaterial(hd))
  {
    if(this->pMaterialTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  /*
   * Sprawdza czy nie przekroczylismy dopuszczalnej wielkosci tablicy
   * Jesli tak to realocujemy cala tablice po czym czyscimy nowe ellementy.
   */
  if(hd >= this->Max_Material_Count)
  {
    unsigned int i = this->Max_Material_Count;
    this->Max_Material_Count += this->Max_Material_Count / 2;
    this->pMaterialTab = (CMaterial **)realloc(pMaterialTab,
                                        this->Max_Material_Count * sizeof(CMaterial *));
    /* czusci nowe elementy */
    while(i < this->Max_Material_Count)
    {
      pMaterialTab[i++] = NULL;
    }
  }
  
  /* dodanie nowego elementu do tablicy */
  this->pMaterialTab[hd] = new CMaterial();
  this->pMaterialTab[hd]->Init(name);
  
  return hd;
} /* end of : GetMaterialHandler */

/*
 * Ustawia shader renderujacy podany material.
 */
void CMaterialManager::SetShader(HMaterial mat, HShader hd)
{

  if(this->HasMaterial(mat))
  {
    this->pMaterialTab[mat]->SetShader(hd);
  }
} /* end of : SetShader */

/*
 * Pobiera shader renderujacy podany material.
 */
HShader CMaterialManager::GetShader(HMaterial mat)
{
  if(this->HasMaterial(mat))
  {
    return this->pMaterialTab[mat]->GetShader();
  }
  return SHADER_NONE;
} /* end of : GetShader */

/*
 * pobiera ilosc stagw-ow w podanym materiale.
 */
unsigned int CMaterialManager::GetStageNum(HMaterial mat)
{
  if(this->HasMaterial(mat))
  {
    return this->pMaterialTab[mat]->GetStageNum();
  }
  return 0;
} /* end of : GetStageNum */

/*
 * Ustawia ilosc stagw-ow oraz uzyte textury w podanym materiale.
 */
void CMaterialManager::SetTextures(HMaterial mat, HTexture *pTexs, unsigned int stages)
{
  if(this->HasMaterial(mat))
  {
    this->pMaterialTab[mat]->AddTextures(pTexs, stages);
  }
} /* end of : SetTextures */

/*
 * Pobiera texture na podanym stage - u z podanego materialu.
 */
HTexture CMaterialManager::GetTexture(HMaterial mat, unsigned int tex)
{
  if(this->HasMaterial(mat))
  {
    return this->pMaterialTab[mat]->GetTexture(tex);
  }
  return DEFAULT_TEXTURE;
} /* end of : GetTexture */

/*
 * Pobiera skladowa Diffuse z podanego materialu.
 */
CVector4 * CMaterialManager::GetDiffuse(HMaterial mat)
{
  if(this->HasMaterial(mat))
  {
    return this->pMaterialTab[mat]->GetDiffuse();
  }
  return NULL;
} /* end of : GetDiffuse */

/*
 * Ustawia skladowa Diffuse z podanego materialu.
 */
void CMaterialManager::SetDiffuse(HMaterial mat, CVector4 *dif)
{
  if(this->HasMaterial(mat))
  {
    this->pMaterialTab[mat]->SetDiffuse(dif);
  }
} /* end of : SetDiffuse */

/*
 * Ustawienie podanego materialu jako obecnie obowiazujacego.
 */
void CMaterialManager::SetMaterial(HMaterial mat, CTextureManager *pTM, CShaderManager *pSM)
{
  if(pTM && pSM && this->HasMaterial(mat))
  {
    this->pMaterialTab[mat]->SetMaterial(pTM, pSM);
  }
} /* end of : SetMaterial */
E:\Project\Kopia (5) VBEngine\Graphics\MaterialManager.h
#ifndef _CMATERIALMANAGER_H
#define _CMATERIALMANAGER_H

/*
class       : CMaterialManager
description : Zazadza Materialami poprzez tablice wskazników na classe CMaterial.
              Twozy tablice wskazników na Materialy i stopniowo zapełnia pola wraz z dodawaniem nowych
              elementów. Jesli ilosc ellemntów przekroczy "Max_Material_Count" do powiękrzamy
              rozmiar tablicy o 50%.

              Knif polega na tym ze wcalosci jest wczytywany z DataFile wienc wczytane meshe
              (tez z DataFile) posiadaja tylko handlery na juz zdefiniowane pelne materialy.

methods     :
              CMaterialManager(...) - konstruktor... Wczytuje dane materialów z DataFile
              ~CMaterialManager()   - destruktor
              GetMaterialHandler(...) - Szuka wpisu w tablicy i jesli nie znajdzie to
                                        allokuje nowy CMaterial w tablicy (jesli jest miesce) lub
                                        najpierw powieksza tablice.
              GetMaterial(...) - pobranie CMaterial (moze zwrucic NULL)
              SetShader(...)   - ustawia shader renderujacy podany material.
              GetShader(...)   - pobiera shader renderujacy podany material.
              GetStageNum(...) - pobiera ilosc stagw-ow w podanym materiale.
              SetTextures(...) - ustawia ilosc stagw-ow oraz uzyte textury w podanym materiale.
              GetTexture(...)  - pobiera texture na podanym stage - u z podanego materialu.
              GetDiffuse(...)  - pobiera skladowa Diffuse z podanego materialu.
              SetDiffuse(...)  - ustawia skladowa Diffuse z podanego materialu.
              SetMaterial(...) - ustawienie podanego materialu jako obecnie obowiazujacego.
*/


class CMaterial;

class CMaterialManager
{
  CMaterial  **pMaterialTab;              /* tablica shaderów */
  unsigned int  Max_Material_Count;       /* rozmiar tablicy (wraz z pustymi polami) */
  
public:
	CMaterialManager(CTextureManager *pTM, CShaderManager *pSM);
  ~CMaterialManager();
  
  bool HasMaterial(HMaterial hd) { return (hd < this->Max_Material_Count && this->pMaterialTab[hd]);};
  HMaterial GetMaterialHandler(const char *name);
  CMaterial  *GetMaterial(HMaterial hd) {return this->pMaterialTab[hd];};
  void SetShader(HMaterial mat, HShader hd);
  HShader GetShader(HMaterial mat);
  unsigned int GetStageNum(HMaterial mat);
  void SetTextures(HMaterial mat, HTexture *pTexs, unsigned int stages);
  HTexture GetTexture(HMaterial mat, unsigned int tex);
  CVector4 * GetDiffuse(HMaterial mat);
  void SetDiffuse(HMaterial mat, CVector4 *dif);

  void SetMaterial(HMaterial mat, CTextureManager *pTM, CShaderManager *pSM);
};

#endif /* _CMATERIALMANAGER_H */
E:\Project\Kopia (5) VBEngine\Graphics\mesh.cpp
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>
#include <string.h>
#include <crtdbg.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\Utility\logger.h"
#include "..\Utility\misc.h"
#include "..\utility\vbmath.h"
#include "..\Utility\Singleton.h"
#include "..\Utility\ctime.h"

#include "..\FileSystem\FileNode.h"
#include "..\FileSystem\BranchNode.h"
#include "..\FileSystem\FileSystem.h"

#include "Texture.h"
#include "TextureManager.h"
#include "Shader.h"
#include "ShaderManager.h"
#include "Material.h"
#include "MaterialManager.h"

#include "mesh.h"
#include "meshmanager.h"


#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"
#include "GUI.h"

/* Konstuktor */
CMesh::CMesh()
{
  this->is_cleanable = true;
  this->name[0] = '\0';
  this->pMaM = NULL;
  this->pSM = NULL;
  this->pTM = NULL;
  this->pVB = NULL;
  this->pIB  = NULL;
  this->MaterialTable = NULL;
  this->is_loaded = false;
  this->vertex_count = 0;
  this->vertex_size = 0;
  this->face_count = 0;
  this->num_materials = 0;
	this->pMaterials = NULL;
} /* end of : Konstruktor */

/* Dekonstuktor: wyladowywuje mesha z pamieci */
CMesh::~CMesh()
{
  if(this->pStreamDecl)
  {
    this->pStreamDecl->Release();
    this->pStreamDecl = NULL;
  }
  if(this->pVB)
  {
    this->pVB->Release();
    this->pVB = NULL;
  }
  if(this->pIB)
  {
    this->pIB->Release();
    this->pIB = NULL;
  }
  if(this->MaterialTable)
  {
    free(this->MaterialTable);
    this->MaterialTable = NULL;
  }
  if (this->pMaterials)
  {
	  free(this->pMaterials);
    this->pMaterials = NULL;
  }/* end of : material free */  
} /* end of : DeKonstruktor */

/*
 * Inicjalizator
 * Przekazanie pointerów do TM i SM.
 * Skopiowanie nazwy pliku do wlasnego buffora z nazwa (nazwa moze miec max MAX_FILE_NAME znaków)
 */
void CMesh::Init(CMaterialManager *_mam, CTextureManager *_tm, CShaderManager *_sm, char *filename)
{ 
  this->pMaM = _mam;
  this->pSM = _sm;
  this->pTM = _tm;
  my_snprintf(this->name, MAX_FILE_NAME, "%s", filename);
} /* end of : Init */

/*
 * Za³adowanie Mesza do pamiêci i zmiana go na zwykle buffory vertexów/indexów.
 *
 * Funkcjia dziala w 2 trybach.
 * 1. Parsuje dane vertexow zapisane w postaci binarnej w DataFile
 *     - Dobra obsulga materialów.  
 * 2. Parsuje Direxowego Mesza z plików X.
 *     - Skopana obsulga materialów.
 *
 * Priorytet ma pierwsza metoda i lepiej nie uzywac 2. Chyba ze wiesz co robisz !
 *
 * Funkcjia zwraca direxowy tryb blêdu HRESULT
 *  - S_OK jesli jest juz zaladowany.
 *  - Bl¹d kazdej funcji sk³adowej odpowiadaj¹cej za fizyczne zaladowanuie mesha do pamieci.
 */

struct MeshDefStruct
{
  bool SplitMesh;
  unsigned char material_count;
  unsigned short index_count;
  unsigned short vertex_count;
};

struct Subset
{
  unsigned short start,count,v_start,v_count;
  char MaterialName[MAX_FILE_NAME];
};


HRESULT CMesh::Load(LPDIRECT3DDEVICE9 pD3dDevice)
{
	if(!this->is_loaded)
	{
    char path[MAX_PATH];
    LPD3DXMESH pLocalMesh, pMesh;
		LPD3DXBUFFER pAdj, pMater;
    LPDIRECT3DVERTEXBUFFER9 pMeshSourceVB;
    LPDIRECT3DINDEXBUFFER9  pMeshSourceIB;
    void *pSrc;
    void *pDst;
    unsigned int size;
		DWORD numMater;
    HRESULT hr;

    my_snprintf(path, MAX_PATH, "%s%s", MeshDataPath , this->name);
    
    char *dot = strrchr(path,'.');
    if (dot == NULL || dot == path)
    {
      dot = path + strlen(path)+1;
      *dot = '.';
    }
    dot ++;
    *dot = 'm';
    *(dot+1) = 's';
    *(dot+2) = 'h';
    *(dot+3) = '\0';

    char *data = (char*)FileSystem::Instance()->LoadFile(path);
    if (data != NULL)
    {
      
      MeshDefStruct *md = (MeshDefStruct*)data;
      this->vertex_count  =    md->vertex_count;
      this->face_count    =    md->index_count/3; 
      this->num_materials =    md->material_count; 
      data += sizeof(MeshDefStruct);
      Subset *subsets = (Subset*)data;
      this->MaterialTable = (D3DXATTRIBUTERANGE *)calloc(num_materials, sizeof(D3DXATTRIBUTERANGE));
      this->pMaterials = (HMaterial *)calloc(this->num_materials, sizeof(HMaterial));
      for (unsigned int i = 0 ; i <  num_materials; i++)
      { 
        pMaterials[i] = this->pMaM->GetMaterialHandler(subsets[i].MaterialName);
        MaterialTable[i].FaceCount    = subsets[i].count;
        MaterialTable[i].FaceStart    = subsets[i].start;
        MaterialTable[i].VertexCount  = subsets[i].v_count;
        MaterialTable[i].VertexStart  = subsets[i].v_start;
       
      }
      data += num_materials *sizeof(Subset);

      D3DVERTEXELEMENT9 decl[] =
      {
          // First stream is first mesh
          { 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
          { 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
          { 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
        D3DDECL_END()
      };

      if( FAILED( hr = pD3dDevice->CreateVertexDeclaration( decl, &this->pStreamDecl ) ) )
      {
          LogError("Can't create Vertex stream decl. for file : %s", this->name);
          if(this->MaterialTable)
          {
            free(this->MaterialTable);
            this->MaterialTable = NULL;
          }
          if (this->pMaterials)
          {
	          free(this->pMaterials);
            this->pMaterials = NULL;
          }/* end of : material free */
          return hr;
      }


      DWORD size = sizeof(unsigned short) *md->index_count;
      hr = pD3dDevice->CreateIndexBuffer( size,
                                      D3DUSAGE_WRITEONLY,
                                      D3DFMT_INDEX16, D3DPOOL_MANAGED,
                                      &this->pIB, NULL );
      if (FAILED(hr))
      {
        pStreamDecl->Release();
        pStreamDecl = NULL;

        if(this->MaterialTable)
        {
          free(this->MaterialTable);
          this->MaterialTable = NULL;
        }
        if (this->pMaterials)
        {
	        free(this->pMaterials);
          this->pMaterials = NULL;
        }/* end of : material free */
        return hr;
      }
      if (SUCCEEDED(this->pIB->Lock( 0, size, &pDst, 0 )))
      {
        memcpy(pDst,data,size);
        pIB->Unlock();
      }
      
      data += size;  
      this->vertex_size = 8 * sizeof(float);
      size = this->vertex_size * this->vertex_count;
      hr = pD3dDevice->CreateVertexBuffer(size,
                                          D3DUSAGE_WRITEONLY, 0, D3DPOOL_MANAGED,
                                          &this->pVB, NULL );

      if (FAILED(hr))
      {
        pStreamDecl->Release();
        pStreamDecl = NULL;
        pIB->Release();
        pIB = NULL;
        if(this->MaterialTable)
        {
          free(this->MaterialTable);
          this->MaterialTable = NULL;
        }
        if (this->pMaterials)
        {
	        free(this->pMaterials);
          this->pMaterials = NULL;
        }/* end of : material free */
        return hr;
      }

      if (SUCCEEDED(this->pVB->Lock( 0, size, &pDst, 0 )))
      {
        memcpy(pDst,data,size);
        pVB->Unlock();
      }
      
      this->is_loaded = true;

      POST_EVENT(ET_GUI, GUIE_DEC_LOAD_COUNT, true, NULL);
  
      return S_OK;
    }

    *dot = 'x';
    dot++;
    *dot = '\0';
    
		if(FAILED( hr = D3DXLoadMeshFromX(
			path,
			D3DXMESH_SYSTEMMEM,
			pD3dDevice,
			&pAdj,
			&pMater,
			NULL,
			&numMater,
			&pLocalMesh) ))
    {
      LogError("Can't load Mesh file : %s", this->name);
      return hr;
    } /* end of : Failed load Mesh */

		if(FAILED( hr = pLocalMesh->OptimizeInplace(
			D3DXMESHOPT_COMPACT | D3DXMESHOPT_ATTRSORT | D3DXMESHOPT_VERTEXCACHE,
			(DWORD*) pAdj->GetBufferPointer(),
			0,0,0) ) )
    {
      LogError("Can't optimize Mesh file : %s", this->name);
      pLocalMesh->Release();
      return hr;
    } /* end of : Failed optimize Mesh */
    
    if(pAdj)
    {
      pAdj->Release();
    }

    D3DVERTEXELEMENT9 decl[] =
    {
        // First stream is first mesh
        { 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
        { 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
        { 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0}, 
      D3DDECL_END()
    };

    if( FAILED( hr = pD3dDevice->CreateVertexDeclaration( decl, &this->pStreamDecl ) ) )
    {
       LogError("Can't create Vertex stream decl. for file : %s", this->name);
       pLocalMesh->Release();
       return hr;
    } /* end of : Failded create stream decl. */
     
    if(FAILED( hr = pLocalMesh->CloneMesh(D3DXMESH_SYSTEMMEM, decl, pD3dDevice, &pMesh) ))
    {
      LogError("Can't Clone Mesh file : %s", this->name);
      this->pStreamDecl->Release();
      pLocalMesh->Release();
      return hr;
    } /* end of : Failed load Mesh */

    pLocalMesh->Release();
 
    this->vertex_count = pMesh->GetNumVertices();
    this->vertex_size = pMesh->GetNumBytesPerVertex();
    this->face_count = pMesh->GetNumFaces();
    
    size = this->vertex_count * this->vertex_size;
    hr = pD3dDevice->CreateVertexBuffer( size,
                                      D3DUSAGE_WRITEONLY, 0, D3DPOOL_MANAGED,
                                      &this->pVB, NULL );
    
    if(SUCCEEDED(hr) &&
       SUCCEEDED(pMesh->GetVertexBuffer( &pMeshSourceVB )) &&
       SUCCEEDED(this->pVB->Lock( 0, size, &pDst, 0 )) &&
       SUCCEEDED(pMeshSourceVB->Lock( 0, size, &pSrc, 0 )))
    {
      memcpy( pDst, pSrc, size );
      this->pVB->Unlock();
      pMeshSourceVB->Unlock();
    }
    
    size = this->face_count * 3 * sizeof(WORD);
    hr = pD3dDevice->CreateIndexBuffer( size,
                                      D3DUSAGE_WRITEONLY,
                                      D3DFMT_INDEX16, D3DPOOL_MANAGED,
                                      &this->pIB, NULL );


   
    if(SUCCEEDED(hr) &&
       SUCCEEDED(pMesh->GetIndexBuffer(&pMeshSourceIB)) &&
       SUCCEEDED(this->pIB->Lock( 0, size, &pDst, 0 )) &&
       SUCCEEDED(pMeshSourceIB->Lock( 0, size, &pSrc, 0 )))
    {
      memcpy( pDst, pSrc, size );
      this->pIB->Unlock();
      pMeshSourceIB->Unlock();
    }
        

     
		if(numMater>0)
		{
      char *tex_name;
      DWORD size;
      
      pMesh->GetAttributeTable(NULL, &size);
      DIE(size <= numMater && "Optymalizacjia Dodala Materia³y !?!");

#ifdef DEBUG
      if(size < numMater)
      {
        LogWarning("Optymalizacjia Zignorowala %d Materia³ów w pliku : ", numMater - size, this->name);
      }
#endif

      this->MaterialTable = (D3DXATTRIBUTERANGE *)calloc(size, sizeof(D3DXATTRIBUTERANGE));
      pMesh->GetAttributeTable(this->MaterialTable, &size);

      this->num_materials = size;

			D3DXMATERIAL *pMatp = (D3DXMATERIAL*)pMater->GetBufferPointer();

      this->pMaterials = (HMaterial *)calloc(this->num_materials, sizeof(HMaterial));
      
			for(DWORD m=0; m<this->num_materials; m++)
			{
        /* HACK ... May the CPU be with you ! */
        my_snprintf(path, MAX_PATH, "%s%d", this->name, m);
        this->pMaterials[m] = this->pMaM->GetMaterialHandler(path);

        {
          /* This should be only tmp solution */
          CMaterial *pMaterial;
          HTexture Text;

          pMaterial = this->pMaM->GetMaterial(this->pMaterials[m]);

  #ifdef USE_MATERIAL
          pMaterial->SetDiffuse(pMatp[this->MaterialTable[m].AttribId].MatD3D.Diffuse.r,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Diffuse.g,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Diffuse.b,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Diffuse.a);

  #ifdef USE_AMBIENT
          pMaterial->SetAmbient(pMatp[this->MaterialTable[m].AttribId].MatD3D.Ambient.r,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Ambient.g,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Ambient.b,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Ambient.a);
  #endif
  #ifdef USE_SPECULAR
          pMaterial->SetSpecular(pMatp[this->MaterialTable[m].AttribId].MatD3D.Specular.r,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Specular.g,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Specular.b,
                                pMatp[this->MaterialTable[m].AttribId].MatD3D.Specular.a);
  #endif
  #endif

          if(pMatp[m].pTextureFilename && pMatp[m].pTextureFilename[0] != '\0')
          {
            if ((tex_name = strrchr(pMatp[this->MaterialTable[m].AttribId].pTextureFilename, '/')))
            {
              tex_name++;
              Text = pTM->GetTextureHandler(tex_name);	
            }
            else
            {
              Text = pTM->GetTextureHandler(pMatp[this->MaterialTable[m].AttribId].pTextureFilename);
            }
          }
          else
          {
            Text = pTM->GetTextureHandler("whitetxr.png");
          }

          pMaterial->AddTextures(&Text, 1);
        }

			} /* end of : matert  and textues loop */
      pMater->Release();
		} /* end of : have matter and textures */
    
    pMesh->Release();
    
    LogMessage("Load Mesh file : %s", this->name);

    this->is_loaded = true;
    POST_EVENT(ET_GUI, GUIE_DEC_LOAD_COUNT, true, NULL);
	} /* end of : True Load Mesh */

  

  return S_OK;
} /* end of : Load Mesh */

/*
 * Ustaw Shader podanemu materialowi.
 */
void CMesh::SetShader(HShader _shader, unsigned int mat)
{
  if (mat < this->num_materials)
  {
    this->pMaM->GetMaterial(this->pMaterials[mat])->SetShader(_shader);
  }
} /* end of : SetShader */

/*
 * Pobiez Shader z podanego materialu.
 */
HShader CMesh::GetShader(unsigned int mat)
{
  return (mat < this->num_materials ? this->pMaM->GetMaterial(this->pMaterials[mat])->GetShader() : SHADER_NONE);
} /* end of : GetShader */

/*
 * Wy³adowanie buffory z pamiêci.
 *
 * Fizycznie usunie buffory vertexów/indexów , tablice materia³ów (jesli obsluzono)
 * wraz z tablica handlerów na textury ( same textury s¹ nie ruszone poniewaz to jest dzia³ka TM )
 */
bool CMesh::Unload()
{
  if(this->is_loaded && this->is_cleanable)
  {
    if(this->pStreamDecl)
    {
      this->pStreamDecl->Release();
      this->pStreamDecl = NULL;
    }
    if(this->pVB)
    {
      this->pVB->Release();
      this->pVB = NULL;
    }
    if(this->pIB)
    {
      this->pIB->Release();
      this->pIB = NULL;
    }
    if(this->MaterialTable)
    {
      free(this->MaterialTable);
      this->MaterialTable = NULL;
    }
    if (this->pMaterials)
    {
	    free(this->pMaterials);
      this->pMaterials = NULL;
    }/* end of : material free */
    this->is_loaded = false;
    LogMessage("Unload Mesh file : %s", this->name);
    return true;
  }
  return false;
} /* end of : Unload Mesh */

/*
 * SetBufferToStream.
 *
 * Funkcja ustawia domyslny buffor vertexow jako "n/stream_num" strumien.
 */
HRESULT CMesh::SetBufferToStream(LPDIRECT3DDEVICE9 pD3dDevice, int stream_num)
{
  return pD3dDevice->SetStreamSource( stream_num, this->pVB, 0, this->vertex_size );
}

/*
 * Prorwnaj zadan¹ nazwe z nazw¹ pliku naszego mesha  (funkcja pomocnicza dla mesz menagera)
 * zwraza True jesli sa to te same nazwy.
 */
bool CMesh::Cmp(const char *m_name)
{
	return (m_name && stricmp(this->name, m_name)==0);
} /* end of : Cmp(...) */

/*
 * Ustawia Jeden shader dla wszystkich materia³ów
 */
void CMesh::SetAllShaders(HShader _shader)
{
  for(unsigned int i = 0; i < this->num_materials; i++)
  {
    this->pMaM->SetShader(this->pMaterials[i], _shader);
  }
} /* end of : SetAllShaders(...) */

/*
 * Ustawia Jeden shader dla wszystkich materia³ów
 */
void CMesh::SetDataToAllShaders(LPDIRECT3DDEVICE9 pD3dDevice, const char *data, CVector4 *pDataVec)
{
  unsigned int i;
  D3DXVECTOR4 DATA;
  /* Konversja na vector z DX3D */
  for (i = 0; i < 4; i++)
  {
    DATA[i] = pDataVec->tab[i];
  }
  CShader *pShader;
  for(i = 0; i < this->num_materials; i++)
  {
    pShader = this->pSM->GetShader(this->pMaM->GetShader(this->pMaterials[i]));
    if(SUCCEEDED(pShader->Load(pD3dDevice, this->pSM->GetShaderLevel())))
    {
      pShader->GetEffect()->SetVector(data, &DATA);
    }
  }
} /* end of : SetAllShaders(...) */


/*
 * PreRendering.
 *
 * Funkcja ustawia domyslny buffor vertexow jako "0" strumien i wlancza domyslna deklaracjie strubienia "0"
 *
 * Jesli dana siatka nie zostala jeszcze zaladowana do pamieci to wywoluje sie funcjie Load()
 * jesli ta zwruci blad (nie zaladowanie) to funcjia (PreRender()) wychodzi nic nie robiac.
 */
void CMesh::PreRender(LPDIRECT3DDEVICE9 pD3dDevice)
{
  if (SUCCEEDED(this->Load(pD3dDevice)))
  {
    pD3dDevice->SetVertexDeclaration( this->pStreamDecl );
    pD3dDevice->SetStreamSource( 0, this->pVB, 0, this->vertex_size );
  }
};

/*
 * Rendering.
 *
 * Funcjia pobiera wskaznik na maiciez : WorldViewProjectioni.
 * Prerzekazuje go do szadera renderujacego, nastêpnie renderuje mesha
 * material po materiale.
 *
 * Kazdy Matrial to teoretycznie inny shader !
 *
 * Jesli dana siatka nie zostala jeszcze zaladowana do pamieci to wywoluje sie funcjie Load()
 * jesli ta zwruci blad (nie zaladowanie) to funcjia (Render()) wychodzi nic nie robiac.
 *
 */
void CMesh::Render(LPDIRECT3DDEVICE9 pD3dDevice, CMatrix4 *pMatWorldProjView)
{
  unsigned int max_passes;
  LPD3DXEFFECT m_pEffect;

  CMaterial *pMaterial;
  CShader *pShader;
  UINT i, numPasses;
  
  if (!(pMatWorldProjView))
  {
    LogError("Mesh %s can't be render becouse WorldProjView matrix is NULL !", this->name);
    return;
  }
  
  if(FAILED(this->Load(pD3dDevice)))
  {
    LogError("Mesh %s not loaded, can't render it !", this->name);
    return;
  }
  
	pD3dDevice->SetIndices(this->pIB);
  max_passes = CMeshManager::Instance()->GetMaxPases();
  for(i=0; i<this->num_materials; i++)
  {
    pMaterial = this->pMaM->GetMaterial(this->pMaterials[i]);
    if (SUCCEEDED(this->pSM->Load(pD3dDevice, pMaterial->GetShader())))
    {
      pShader = this->pSM->GetShader(pMaterial->GetShader());
      m_pEffect = pShader->GetEffect();

      pShader->SetWVP(pMatWorldProjView);
          
    	m_pEffect->Begin(&numPasses, 0);
      pShader->SetMaterial(pMaterial, this->pTM );  
      for( UINT iPass = 0; (iPass < numPasses && iPass < max_passes); iPass++ )
		  {
		     m_pEffect->Pass( iPass );
         pD3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0,
              this->MaterialTable[i].VertexStart, this->MaterialTable[i].VertexCount,
                (this->MaterialTable[i].FaceStart << 1) + this->MaterialTable[i].FaceStart,
                                                              this->MaterialTable[i].FaceCount);
      
      }/* end of : numPasses Loop */
      m_pEffect->End();
    }/* end of : Loaded shader */
    else
    {
      LogError("Mesh %s can't be render becouse his shader is not loaded !", this->name);
    } /* end of : hasn't shader */
  } /* end of : materrial loop */
  
  pD3dDevice->SetVertexDeclaration( NULL );
} /* end of : Render() */

#ifdef DEBUG
void CMesh::Printfinf(char *buffer, size_t size)
{
  cat_snprintf(buffer, size, "\nFrameName %s:", this->name);
}
#endif
E:\Project\Kopia (5) VBEngine\Graphics\mesh.h
#ifndef _CMESH
#define _CMESH

/*
class       : CMesh
description : Podstawowa klasa siatki 3D. Zawiera całš geometrie siatki (buffory vertexów i indexów),
              format strumienia, tablice materiałów.
methods     :
              CMesh()  - konstruktor
              ~CMesh() - destruktor   
              Cmp(...) - porównanie szukaneej nazwy pliku z grafika z naszym bufforem nazwy.
              IsLoaded() - zwraca status zaladowania geometri
              Init(...)  - podpina pointery SM i TM oraz kopiuje nazwe pliku z meshem do wlasnego buffora
              SetShader(...) - ustawia shader renderujacy dany materiał
              GetShader(...) - zwraca shader renderujacy dany materiał
              SetAllShaders(...) - ustawia jeden shader dla wszystkich materiałów
              GetMaterial(...)  - zwraca wskaznik dany material
              GetNumMaterials() - zwraca ilosc materiałów
              GetNumFaces() - zwraca ilosc tujkontów
              GetNumVertices() - zwraca ilosc vertexow
              GetNumBytesPerVertex() - zwraca rozmiar pojedynczego vertexa (w Bajtach)
              SetBufferToStream(...) - kieruje posiadany buffor vertexów do strumienia renderujacego
	            Load(...) - Ładuje geometrie z pliku (ustawionego przez Init(...))
	            Unload()  - wyładowywuje geometrie.
              PreRender(...) - ustawia posiadany formatstrumienia i kieruje posiadany buffor do 0(zerowego) strumienia renderujacego.
	            Render(...) - renderuje posiadany buffor vertexow przy pomocy ustawionego shadera.
              SetDataToAllShaders(...) - przekazuje CVector4 do shaderow wszystkich materialów
                                         z tablicy pMaterials pod poday identyfikator danych.
              IsClinable() - zwraca status blokady automatycznego wyladowywania.
              SetClinable(...) - ustawia/zwalnia blokade automatycznego wyladowywania.
#ifdef DEBUG
 	            Printfinf(...) - dana do wypisania na ekranie zwionzane z danym meszem
#endif
*/
class CMaterialManager;

class CMesh
{
  bool is_cleanable;                            /* status blokady mesha w MM (zapobiega automatycznemy wyładowaniu)*/
  bool is_loaded;                               /* Stan zaladowania Mesha do pamieci */
  char             name[MAX_FILE_NAME];         /* nazwa pliku z Meszem: obecnie nazwa X-a */

  CMaterialManager *pMaM;
  CShaderManager   *pSM;                        /* pointer na Shader Manager */
  CTextureManager  *pTM;                        /* pointer na Texture Manager */

  LPDIRECT3DVERTEXDECLARATION9 pStreamDecl;     /* Deklaracja strumienia dla vertex shadera */
  LPDIRECT3DVERTEXBUFFER9      pVB;             /* Buffor Vertexow */
  LPDIRECT3DINDEXBUFFER9       pIB;             /* Buffor Indexow */
  D3DXATTRIBUTERANGE           *MaterialTable;  /* Zakresy materialów w bufforach vertexow i indexow */

  int vertex_count;                             /* ilosc vertexow */
  int vertex_size;                              /* wielkosc vertexa */
  int face_count;                               /* ilosc polygonow */
  unsigned int num_materials;                   /* ilosc materałów (jesli obsluzone) i textur w naszej siatce */
   

  HMaterial *pMaterials;                         /* tablica handlerów materjałów (z MaM) wykozystana w naszym Meszu jako materiały */
  
public:
	CMesh();
  ~CMesh();
  bool Cmp(const char *m_name);
  bool IsLoaded(void) {return this->is_loaded;};
  void Init(CMaterialManager *mam, CTextureManager *tm, CShaderManager *sm, char *filename);
  void SetAllShaders(HShader _shader);
  void SetShader(HShader _shader, unsigned int mat);
  HShader GetShader(unsigned int mat);
  HMaterial GetMaterial(unsigned int mat) {return this->pMaterials[mat];}
  int GetNumFaces(void) {return this->face_count;};
  int GetNumVertices(void) {return this->vertex_count;};
  int GetNumBytesPerVertex(void) {return this->vertex_size;};
  int GetNumMaterials(void) {return this->num_materials;};
  HRESULT SetBufferToStream(LPDIRECT3DDEVICE9 pD3dDevice, int stream_num);
	HRESULT Load(LPDIRECT3DDEVICE9 pD3dDevice);
	bool Unload(void);
  void PreRender(LPDIRECT3DDEVICE9 pD3dDevice);
	void Render(LPDIRECT3DDEVICE9 pD3dDevice, CMatrix4 *pMatWorldProjView);
  void SetDataToAllShaders(LPDIRECT3DDEVICE9 pD3dDevice, const char *data, CVector4 *pDataVec);
  bool IsClinable(void) {return this->is_cleanable;}
  void SetClinable(bool cl) { this->is_cleanable = cl; }
#ifdef DEBUG
 	void Printfinf(char*, size_t);
#endif
};

#endif /* _CMESH */
E:\Project\Kopia (5) VBEngine\Graphics\MeshManager.cpp
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>
#include <crtdbg.h>
#include <string.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\Utility\logger.h"
#include "..\Utility\misc.h"
#include "..\utility\vbmath.h"

#include "Texture.h"
#include "TextureManager.h"
#include "Shader.h"
#include "ShaderManager.h"
#include "Material.h"
#include "MaterialManager.h"

#include "renderer.h"

#include "mesh.h"
#include "meshmanager.h"



/*
class       : CRealMeshManager
description : Wewnêtrzny za¿¹dca geometri, posiada wiedze o uzadzeniu renderujacym i zasobach DX.
              Potrafi renderowac zwylke siatki jak i Animacje na Meshach.
              Jest Dysponêtem ShaderManagera i TextureManagera jak i wskaznika do 3D Devia.
              Procedury Init i Deinit sa wywo³ywane podczas zmiany wskaznika na 3DDevica.
methods     :
              CMeshManager()  - konstruktor
	            ~CMeshManager() - destruktor
              Init(...)     - podpina wskaznik Device araz twozy SM i TM (jesli nie istnieja)
              DeInit()        - Wymusza wy³adowanie wszystkich Textur , Shaderów i Meshy
              GetSM()         - zwraca wskaznik do SM
              GetDev()        - Zwraca wskaznik do Device
              GetTM()         - Zwraca wskaznik do TM
              GetMesh(...)    - Dodaje nowego Mesha do listy (ale go nie ³aduje)
              GetMeshLoad(...) - Dodaje nowego Mesha do listy i ³aduje go
              Render(CMesh *pMesh, ...) - zwy³y render (zwy³ego mesha)
              Render(CMesh *pMesh0, CMesh *pMesh1, float alpha, ...) - Render Animacji
              UnloadMesh(...) - Wy³adu Mesha o podanej nazwie
              CleanList()     - Wy³aduj wszystkiw meshe z listy (tylko buffory vertexów)
              SetAllShaders(..., char *shfilename) -  dodaj shader do listy , zaladuj mesha i ustaw wszystkie materia³y na ten shader
              SetAllShaders(..., HSader shader) -  zaladuj mesha i ustaw wszystkie materia³y na ten "shader"
              HasMesh(...) - Handler nie przekracza wielkosci tablicy i podany Mesh istnieje
*/

class CRealMeshManager
{
	LPDIRECT3DDEVICE9 pDevice;    /* default D3D device */
  LPDIRECT3DVERTEXDECLARATION9 pMorphDeclaration; /* strumien uzyty do morphowania animacji */
  CShaderManager *pSM;          /* pointer to Shasder Manager */
  CTextureManager *pTM;          /* pointer to Texture Manager */
  CMaterialManager *pMaM;        /* Materials */
  CMesh **pMeshTab;               /* tablica dodanych siatek geometri */
  bool *NeedReload;
  unsigned int mesh_tab_size;     /* wielkos tablicy wskaznikó na Mesha */
public:	
  CRealMeshManager(void);
	~CRealMeshManager(void);
  bool Init(bool reload);
  int DeInit(void);
  bool HasMesh(HMesh hd) {return (hd < this->mesh_tab_size && this->pMeshTab[hd]);};
  CShaderManager *GetSM(void) {return this->pSM;};
  LPDIRECT3DDEVICE9 GetDev(void){return this->pDevice;};
  CTextureManager *GetTM(void) {return this->pTM;};
  HMesh GetMeshHandler(char *name);
  HMesh GetMeshHandlerLoad(char *name);
  void SetAllShaders(HMesh hd, HShader _shader);
  void SetAllShaders(HMesh hd, char *shfilename);
  void Render(HMesh hd, CMatrix4 *pMatWorldProjView);
  void Render(HMesh hd0, HMesh hd1, float alpha, CMatrix4 *pMatWorldProjView);
  void UnloadMesh(char *name);
  bool LoadMesh(HMesh hd);
  bool LoadMeshWithTextures(HMesh hd);
  void CleanList(void);
  void SetMeshClinable(HMesh handle, bool cl);
  void SetDataToAllShaders(HMesh hd, const char *pData, CVector4 *pDataVec);
  void OnLostDevice();
  void OnResetDevice();
  bool IsMeshLoaded(HMesh mesh);
  int GetReloadCount(HMesh hd);
};

/* ====================================================================================== */

/* Konstuktor */
CMeshManager::CMeshManager(void)
{
  this->max_pases = 0xFFFFFFFF;
  this->pMM = new CRealMeshManager();
}/* end of : Konstruktor */

/* Dekonstuktor: czysci pamieæ (nie wy³adowywuje Meshy gdyz zakladam wywolanie DeInit() wczesniej)*/
CMeshManager::~CMeshManager(void)
{
  delete this->pMM;
}/* end of : DeKonstruktor */

/* Podane nizej metody sa tylko wraperami na wlasciwego za¿¹dce */

bool CMeshManager::Init(bool reload)
{
  return this->pMM->Init(reload);
};

int CMeshManager::DeInit(void)
{
  return this->pMM->DeInit();
};

void CMeshManager::UnloadMesh(char *name)
{
  this->pMM->UnloadMesh(name);
};

bool CMeshManager::LoadMesh(HMesh hd)
{
  return this->pMM->LoadMesh(hd);
}

bool CMeshManager::LoadMeshWithTextures(HMesh hd)
{
  return this->pMM->LoadMeshWithTextures(hd);
}

void CMeshManager::CleanList(void)
{
  this->pMM->CleanList();
  this->pMM->GetTM()->CleanList();
};

void CMeshManager::OnLostDevice()
{
  this->pMM->OnLostDevice();
}

void CMeshManager::OnResetDevice()
{
  this->pMM->OnResetDevice();
}

void CMeshManager::ResetTM(int level)
{
  this->pMM->GetTM()->Reset(level);
}

void CMeshManager::ResetSM(int level)
{
  this->pMM->GetSM()->CleanList();
  this->pMM->GetSM()->SetShaderLevel((enum TechniqueType)level);
  this->pMM->GetSM()->Reload();
}

void CMeshManager::Reflection(bool r)
{
  if(r)
  {
    this->max_pases = 0xFFFFFFFF;
  }
  else
  {
    this->max_pases = 1;
  }
}

HTexture CMeshManager::GetTextureHandlerLoad(const char *src)
{
  HTexture tex = this->pMM->GetTM()->GetTextureHandler(src);
  this->pMM->GetTM()->GetTexture(tex)->Load(this->pMM->GetDev());
  return tex;
}

bool CMeshManager::IsMeshLoaded(HMesh mesh)
{
  return this->pMM->IsMeshLoaded(mesh);
}

HTexture CMeshManager::GetTextureHandler(const char *src)
{
  return this->pMM->GetTM()->GetTextureHandler(src);
}

HTexture CMeshManager::GetVideoTextureHandlerLoad(const char *src,bool silent, unsigned long stopEventTarget,unsigned long stopEventID ,bool looping)
{
  HTexture tex = this->pMM->GetTM()->GetVideoTextureHandler(src,silent,stopEventTarget,stopEventID,looping);
  this->pMM->GetTM()->GetTexture(tex)->Load(this->pMM->GetDev());
  return tex;
}

HTexture CMeshManager::GetVideoTextureHandler(const char *src,bool silent, unsigned long stopEventTarget,unsigned long stopEventID ,bool looping)
{
  return this->pMM->GetTM()->GetVideoTextureHandler(src,silent,stopEventTarget,stopEventID,looping);
}

CTexture * CMeshManager::GetTexture(HTexture handle)
{
  return this->pMM->GetTM()->GetTexture(handle);
}

void CMeshManager::SetTextureClinable(HTexture handle, bool cl)
{
  this->pMM->GetTM()->GetTexture(handle)->SetClinable(cl);
}


void CMeshManager::SetMeshClinable(HMesh handle, bool cl)
{
  this->pMM->SetMeshClinable(handle, cl);
}

/*
void CMeshManager::LinkTexture(const char *dst, const char *src)
{
  this->pMM->GetTM()->GetTexture(this->pMM->GetTM()->GetTextureHandler(dst)
             )->Link(this->pMM->GetTM()->GetTexture(this->pMM->GetTM()->GetTextureHandler(src)));
}
*/

void CMeshManager::LoadTexture(HTexture src)
{
  this->pMM->GetTM()->GetTexture(src)->Load(this->pMM->GetDev());
}

void CMeshManager::LinkTexture(HTexture dst, HTexture src)
{
  if (dst != src)
  {
     this->pMM->GetTM()->GetTexture(dst)->Link(this->pMM->GetTM()->GetTexture(src));
  }
}

HMesh CMeshManager::GetMeshHandler(char *name)
{
  return this->pMM->GetMeshHandler(name);
};

HMesh CMeshManager::GetMeshHandlerLoad(char *name)
{
  return this->pMM->GetMeshHandlerLoad(name);
};

void CMeshManager::SetAllShaders(HMesh mesh, char *shfilename)
{
  this->pMM->SetAllShaders(mesh, shfilename);
};

void CMeshManager::Render(HMesh mesh, CMatrix4 *pMatWorldProjView)
{
  this->pMM->Render(mesh, pMatWorldProjView);
};

void CMeshManager::Render(HMesh mesh0, HMesh mesh1, float alpha, CMatrix4 *pMatWorldProjView)
{
  this->pMM->Render(mesh0, mesh1, alpha, pMatWorldProjView);
};

void CMeshManager::SetVec4DataToAllShaders(HMesh mesh, const char *pData, CVector4 *pDataVec)
{
  this->pMM->SetDataToAllShaders(mesh, pData, pDataVec);
}

unsigned char CMeshManager::GetMaxShaderLevel()
{
  return this->pMM->GetSM()->GetMaxShaderLevel();  
}

int CMeshManager::GetReloadCount(HMesh hd)
{
  return this->pMM->GetReloadCount(hd);
}

/* ====================================================================================== */

/* Konstuktor */
CRealMeshManager::CRealMeshManager(void)
{
  this->pDevice = NULL;
  this->pSM = NULL;
  this->pTM = NULL;
  this->pMaM = NULL;
  this->pMorphDeclaration = NULL;
  this->mesh_tab_size = 30;
  this->pMeshTab = (CMesh **)calloc(this->mesh_tab_size, sizeof(CMesh *));
  this->NeedReload = (bool *)calloc(this->mesh_tab_size, sizeof(bool));
}/* end of : Konstruktor */

/* Dekonstuktor: czysci pamieæ (nie wy³adowywuje Meshy gdyz zakladam wywolanie DeInit() wczesniej)*/
CRealMeshManager::~CRealMeshManager(void)
{
  if (this->pMorphDeclaration)
  {
    this->pMorphDeclaration->Release();
  }
  for (unsigned int i = 0; i < mesh_tab_size; i++)
  {
    if (pMeshTab[i]) delete pMeshTab[i];
  }
  free(pMeshTab);
  free(NeedReload);
  delete this->pSM;
  delete this->pTM;
  delete this->pMaM;
}/* end of : DeKonstruktor */

/*
 * Inicjalizator
 *
 * Podpina wskaznik na "Device" , allocuje definicjie strumienia do interpolacji oraz
 * allocuje i inicjializuje SM wraz z TM.
 *
 * Zwraca E_FAIL gdy ...
 *  - Deficicja strumienia interpolujacego sie nie powiezie.
 *  - Inicjalizacja ShaderManegera pujdzie nie tak jak trzeba
 */
bool CRealMeshManager::Init(bool reload)
{
  this->pDevice = Renderer::Instance()->GetDevice();
  
  /* Strumien Interpoluj¹cy */
  if (!this->pMorphDeclaration)
  {
    D3DVERTEXELEMENT9 decl[] =
    {
      // First stream is first mesh
      { 0,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 0}, 
      { 0, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   0}, 
      { 0, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 0},
      // Second stream is second mesh
      { 1,  0, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_POSITION, 1}, 
      { 1, 12, D3DDECLTYPE_FLOAT3, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_NORMAL,   1}, 
      { 1, 24, D3DDECLTYPE_FLOAT2, D3DDECLMETHOD_DEFAULT,  D3DDECLUSAGE_TEXCOORD, 1},
      D3DDECL_END()
    };

    if(FAILED(this->pDevice->CreateVertexDeclaration( decl, &this->pMorphDeclaration)))
    {
      return false;
    }
  }

  /* Texture Manager */
  if(!this->pTM)
  {
    this->pTM = new CTextureManager();
  }
  else
  {
    this->pTM->Reload();
  }

  /* Shader Manager */
  if (!this->pSM)
  {
    this->pSM = new CShaderManager();
    if(!this->pSM->Init(this->pDevice, TECHNIQUE_DEFAULT))
    {
      /* Zwolnij Pozosta³e Moduly */
      delete this->pSM;
      if (this->pMorphDeclaration)
      {
        this->pMorphDeclaration->Release();
        this->pMorphDeclaration = NULL;
      }
      return false;
    }
  }
  else
  {
    this->pSM->Reload();
  }
    
  /* Texture Manager */
  if(!this->pMaM)
  {
    this->pMaM = new CMaterialManager(pTM,pSM);
  }
  
  if(reload)
  {
    HMesh hd = 0;
    while(this->HasMesh(hd))
    {
      if(this->NeedReload[hd])
      {
        this->pMeshTab[hd]->Load(this->pDevice);
      }
      hd++;
    }
  }

  return true;
}/* end of : Init(...) */

/*
 * Deinicjalizator
 *
 * Wy³adowywuje wszelakie przechowywane wiadomosci o Meshach , Texturach i Shaderach
 * zachowujac "uchwyty" na nie (do ponownego za³adowania)
 */
int CRealMeshManager::DeInit(void)
{
  int count;
  this->pSM->OnLostDevice();
  if (this->pMorphDeclaration)
  {
    this->pMorphDeclaration->Release();
    this->pMorphDeclaration = NULL;
  }

  this->pSM->CleanList();
  count = this->pTM->PreReload();
  
  {
    bool cl;
    HMesh hd = 0;
    while(this->HasMesh(hd))
    {
      this->NeedReload[hd] = false;
      cl = this->pMeshTab[hd]->IsClinable();
      this->pMeshTab[hd]->SetClinable(true);
      if(this->pMeshTab[hd]->Unload())
      {
        count++;
        this->NeedReload[hd] = true;
      }
      this->pMeshTab[hd++]->SetClinable(cl);
    }
  }
  
  return count;
}/* end of : DeInit() */

/*
 * Pobranie handlera do (nowej) classy CMesha (siatka geometri) o podanej nazwie pliku (obecnie w formacie *.X).
 * 
 * Jesli nie posiadamy jeszcze danego "Mesha" to nowy element jest dodawany (allocacja pamiêci) do tablicy
 * Meshy (ale nie laduje go) i zaincjalizowany.
 */
HMesh CRealMeshManager::GetMeshHandler(char *name)
{
  HMesh hd = 0;
  while(this->HasMesh(hd))
  {
    if(this->pMeshTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  if(hd == this->mesh_tab_size)
  {
    this->mesh_tab_size += this->mesh_tab_size / 2;
    this->pMeshTab = (CMesh **)realloc(this->pMeshTab, this->mesh_tab_size * sizeof(CMesh *));
    this->NeedReload = (bool *)realloc(this->NeedReload, this->mesh_tab_size * sizeof(bool));
    for(HMesh hd2 = hd; hd2 < this->mesh_tab_size; hd2++)
    {
      this->NeedReload[hd2] = false;
      this->pMeshTab[hd2] = NULL;
    }
  }

  this->pMeshTab[hd] = new CMesh();
  this->pMeshTab[hd]->Init(this->pMaM, this->pTM, this->pSM, name);

  return hd;
}/* end of : GetMesh(...) */

/*
 * Pobranie handlera do (nowej) classy CMesha (siatka geometri) o podanej nazwie pliku (obecnie w formacie *.X).
 * 
 * Jesli nie posiadamy jeszcze danego "Mesha" to nowy element jest dodawany (allocacja pamiêci) do tablicy
 * Meshy , zaincjalizowany oraz wymusza sie jego natychmiastowe za³adowanie.
 */
HMesh CRealMeshManager::GetMeshHandlerLoad(char *name)
{
  HMesh hd = this->GetMeshHandler(name);
  this->LoadMeshWithTextures(hd);
  //this->pMeshTab[hd]->Load(this->pDevice);
  return hd;
}/* end of : GetMeshLoad(...) */

/*
 * Render NieInterpolowanego Mesha.
 * 
 * Musimy podac macieze Swiata, Widoku i projecji w celu poprawnego usytuowanie modelu w swiecie.
 * Dodatkowo funkcjia dokonuje "auto za³adowania" brakujacych elemtów Renderingu (Mesha, textury, shadera).
 */
void CRealMeshManager::Render(HMesh hd, CMatrix4 *pMatWorldProjView)
{
  if(this->HasMesh(hd))
  {
    this->pMeshTab[hd]->PreRender(this->pDevice);
    this->pMeshTab[hd]->Render(this->pDevice, pMatWorldProjView);
  }
} /* end of : Render(...) */

/*
 * Render Interpolowanego Mesha z innym Meshaem.
 * 
 * Nalezy dodatkowo podac Kolejnego mesha (hd1) z którego beda brane wiezcho³ki, do kórych obecny
 * mesh (pMesh0) bedzie interpolowany (liniowo) z wspu³czynnikiem "alpha" <0.0 - 1.0>
 *
 * Musimy podac macieze Swiata, Widoku i projecji w celu poprawnego usytuowanie modelu w swiecie.
 * Dodatkowo funkcjia dokonuje "auto za³adowania" brakujacych elemtów Renderingu (Mesha, textury, shadera).
 */
void CRealMeshManager::Render(HMesh hd0, HMesh hd1, float alpha, CMatrix4 *pMatWorldProjView)
{
  if( this->HasMesh(hd0) && this->HasMesh(hd1) &&
      SUCCEEDED(this->pMeshTab[hd0]->Load(this->pDevice)) &&
      SUCCEEDED(this->pMeshTab[hd1]->Load(this->pDevice)))
  {
    this->pDevice->SetVertexDeclaration( this->pMorphDeclaration );
    this->pMeshTab[hd0]->SetBufferToStream(this->pDevice, 0);
    /* sprawdza czy oba mesha maja ta sama illosc wiezcho³ków (czy mozna interpolowac) */
    if(this->pMeshTab[hd0]->GetNumVertices() == this->pMeshTab[hd1]->GetNumVertices())
    {
      HShader sh;
      this->pMeshTab[hd1]->SetBufferToStream(this->pDevice, 1);
      /*
       * Wpish wspó³czynnik "alpha" do kazdego shadera materja³u.
       * KAZDY SHADER MATERIA£U TEGEJ SIATKI MUSI MIEC TEN WSPÓ£CZYNNIK MODYFIKOWALNY !!!! 
       */
      for(int i = 0; i < this->pMeshTab[hd0]->GetNumMaterials(); i++)
      {
        sh = this->pMeshTab[hd0]->GetShader(i);
        if (SUCCEEDED(this->pSM->Load(this->pDevice, sh)))
        {
          this->pSM->GetEffect(sh)->SetFloat("alpha", alpha);
        }
      }
    }
    else
    {
      /* interpoluj sam ze sob¹ - wy³¹cz interpolacjie (wredny hack) */
      this->pMeshTab[hd0]->SetBufferToStream(this->pDevice, 1);
    }
    this->pMeshTab[hd0]->Render(this->pDevice, pMatWorldProjView);
  }
}/* end of : Render(...) */

/*
 * Znajdz na liscie i wy³aduj Mesha o podanej Nazwie pliku z geometri¹.
 */
void CRealMeshManager::UnloadMesh(char *name)
{
  HMesh hd = 0;
  while(this->HasMesh(hd))
  {
    if(this->pMeshTab[hd]->Cmp(name))
    {
      this->pMeshTab[hd]->Unload();
      return;
    }
    hd++;
  }
}/* end of : UnloadMesh(...) */

bool CRealMeshManager::LoadMesh(HMesh hd)
{
  return (this->HasMesh(hd) && SUCCEEDED(this->pMeshTab[hd]->Load(this->pDevice)));
}

bool CRealMeshManager::LoadMeshWithTextures(HMesh hd)
{
  if (this->LoadMesh(hd))
  {
    HMaterial mat;
    CTexture *tex;
    for(int i = 0; i < this->pMeshTab[hd]->GetNumMaterials(); i++)
    {
      mat = this->pMeshTab[hd]->GetMaterial(i);
      if(!this->pMaM->HasMaterial(mat)) continue;
      for(unsigned int j = 0; j < this->pMaM->GetStageNum(mat); j++)
      {
        tex = this->pTM->GetTexture(this->pMaM->GetTexture(mat, j));
        if(tex) tex->Load(this->pDevice);
      }
    }
    return true;
  }
  return false;

}

int CRealMeshManager::GetReloadCount(HMesh hd)
{
  int count = 0;
  if (this->HasMesh(hd))
  {
    HMaterial mat;
    CTexture *tex;
    count = (this->pMeshTab[hd]->IsLoaded() ? 0 : 1);
    for(int i = 0; i < this->pMeshTab[hd]->GetNumMaterials(); i++)
    {
      mat = this->pMeshTab[hd]->GetMaterial(i);
      if(!this->pMaM->HasMaterial(mat)) continue;
      for(unsigned int j = 0; j < this->pMaM->GetStageNum(mat); j++)
      {
        tex = this->pTM->GetTexture(this->pMaM->GetTexture(mat, j));
        count += (tex && !tex->IsLoaded() ? 1 : 0);
      }
    }
  }
  return count;
}

void CRealMeshManager::SetMeshClinable(HMesh handle, bool cl)
{
  if(this->HasMesh(handle))
  {
    this->pMeshTab[handle]->SetClinable(cl);
  }
}

/*
 * Wy³aduj wszystkie Meshe z listy.
 */
void CRealMeshManager::CleanList(void)
{
  HMesh hd = 0;
  while(this->HasMesh(hd))
  {
    this->pMeshTab[hd++]->Unload();
  }
}/* end of : CleanList() */

/*
 * Za³aduj Mesha i ustaw wszystkie shadery materia³ów na dany "_shader".
 */
void CRealMeshManager::SetAllShaders(HMesh hd, HShader _shader)
{
  if(this->HasMesh(hd) && SUCCEEDED(this->pMeshTab[hd]->Load(this->pDevice)))
  {
    this->pMeshTab[hd]->SetAllShaders(_shader);
  }
} /* end of : SetAllShaders(...) */

/*
 * Za³aduj Mesha , dodaj shader z "shfilename" do listy w SM i ustaw wszystkie shadery materia³ów na dodany "shader".
 */
void CRealMeshManager::SetAllShaders(HMesh hd, char *shfilename)
{
  DIE(NULL != shfilename && "Podaj nazwe shadera idioto !!");
  this->SetAllShaders(hd, this->pSM->GetShaderHandler(shfilename));
} /* end of : SetAllShaders(...) */

void CRealMeshManager::SetDataToAllShaders(HMesh hd, const char *pData, CVector4 *pDataVec)
{
  if(this->HasMesh(hd) && SUCCEEDED(this->pMeshTab[hd]->Load(this->pDevice)))
  {
    this->pMeshTab[hd]->SetDataToAllShaders(this->pDevice, pData, pDataVec);
  }
}

void CRealMeshManager::OnLostDevice()
{
  this->pSM->OnLostDevice();
}

void CRealMeshManager::OnResetDevice()
{
  this->pSM->OnResetDevice();
}

bool CRealMeshManager::IsMeshLoaded(HMesh hd)
{
  return (this->HasMesh(hd) && this->pMeshTab[hd]->IsLoaded());
}
E:\Project\Kopia (5) VBEngine\Graphics\meshmanager.h
#ifndef _MESHMANAGER_H
#define _MESHMANAGER_H

/*
class       : CMeshManager
description : Domyslny za¿¹dca geometri, bedoncy tylko wraperem na wlasciwego za¿¹dce w *.cpp.
              Potrafi wieksoc zeczy co wlasciwy menadzer.
methods     :
              CMeshManager()  - konstruktor
	            ~CMeshManager() - destruktor
              Init(...)     - podpina wskaznik Device araz twozy SM i TM (jesli nie istnieja)
              DeInit()        - Wymusza wy³adowanie wszystkich Textur , Shaderów i Meshy
              GetMeshHandler(...)     - Zwraca istniejacy handler lub dodaje nowego Mesha do listy (ale go nie ³aduje)
              GetMeshHandlerLoad(...) - Zwraca istniejacy handler lub dodaje nowego Mesha do listy i ³aduje go
              Render(HMesh Mesh, ...) - zwy³y render (zwy³ego mesha)
              Render(HMesh Mesh0, HMesh Mesh1, float alpha, ...) - Render Animacji
              UnloadMesh(...) - Wy³adu Mesha o podanej nazwie
              CleanList()     - Wy³aduj wszystkiw meshe z listy (tylko buffory vertexów)
              SetAllShaders(..., char *shfilename) -  dodaj shader do listy , zaladuj mesha i
                                                      ustaw wszystkie jego materia³y na ten shader
              HasMesh(...) - Handler nie przekracza wielkosci tablicy i podany Mesh istnieje

              SetVec4DataToAllShaders(HMesh mesh, const char *pData, CVector4 *pDataVec)
              LoadMesh(HMesh hd);
              LoadMeshWithTextures(HMesh hd);

              GetTextureHandlerLoad(...)
              GetTextureHandler(...)
              GetVideoTextureHandlerLoad(...);
              GetVideoTextureHandler(...);
              GetMaxPases()
              GetTexture(HTexture handle);
              LinkTexture(HTexture dst, HTexture src);
              LoadTexture(HTexture hd);
              ResetTM(int level);
              ResetSM(int level);
              Reflection(bool r);
              OnLostDevice();
              OnResetDevice();
              SetTextureClinable(HTexture handle, bool cl);
              SetMeshClinable(HMesh handle, bool cl);
              GetMaxShaderLevel();
*/

class CTexture;
class CTextureManager;
class CRealMeshManager;

class CMeshManager :public Singleton<CMeshManager>
{
  unsigned int max_pases;
  CRealMeshManager *pMM;  /* wlasciwy zazadca */
public:	
  CMeshManager(void);
	~CMeshManager(void);
  bool Init(bool reload = false);
  int DeInit(void);
  HMesh GetMeshHandler(char *name);
  HMesh GetMeshHandlerLoad(char *name);
  void SetAllShaders(HMesh mesh, char *shfilename);
  HTexture GetTextureHandlerLoad(const char *src);
  HTexture GetTextureHandler(const char *src);
  HTexture GetVideoTextureHandlerLoad(const char *src,bool silent = true, unsigned long stopEventTarget = 0,unsigned long stopEventID = 0,bool looping = true);
  HTexture GetVideoTextureHandler(const char *src,bool silent = true, unsigned long stopEventTarget = 0,unsigned long stopEventID = 0,bool looping = true);
  unsigned int GetMaxPases(void) {return this->max_pases;};
  CTexture * GetTexture(HTexture handle);
  void LinkTexture(HTexture dst, HTexture src);
  void LoadTexture(HTexture hd);
  void SetVec4DataToAllShaders(HMesh mesh, const char *pData, CVector4 *pDataVec);
  bool IsMeshLoaded(HMesh mesh);
  int GetReloadCount(HMesh hd);
  void Render(HMesh mesh, CMatrix4 *pMatWorldProjView);
  void Render(HMesh mesh0, HMesh mesh1, float alpha, CMatrix4 *pMatWorldProjView);
  void UnloadMesh(char *name);
  bool LoadMesh(HMesh hd);
  bool LoadMeshWithTextures(HMesh hd);
  void CleanList(void);
  void ResetTM(int level);
  void ResetSM(int level);
  void Reflection(bool r);
  void OnLostDevice();
  void OnResetDevice();
  void SetTextureClinable(HTexture handle, bool cl);
  void SetMeshClinable(HMesh handle, bool cl);
  unsigned char GetMaxShaderLevel();
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\Renderer.cpp
#include "..\config.h"

#include <assert.h>
#include <d3d9.h>
#include <dinput.h>
#include <d3dx9effect.h>


#include "..\utility\Misc.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"

#include "..\utility\logger.h"
#include "..\utility\profile.h"
#include "..\utility\tools.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"

#include "..\VStudio\resource.h"
#include "..\utility\CTime.h"

#include "..\Core\User.h"
#include "..\Core\usermanager.h"
#include "..\Core\Setupmanager.h"
#include "..\input\Mapper.h"
#include "..\input\input.h"

#include "..\utility\vbmath.h"

#ifdef DEBUG
#include ".\Debuging\d3dfont.h"
#endif

#include "..\Utility\EventHandler.h"

#include "..\Audio\Audio.h"
#include "..\Audio\AudioManager.h"


#include "Shader.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "MaterialManager.h"
#include "mesh.h"
#include "meshmanager.h"
#include "GUI.h"

#include "renderer.h"

Renderer::Renderer()
{
    pD3DInterface  = NULL;
    pCurrentDevice = NULL;
    mClassAtom     = NULL;
    hCurrentWindow = NULL;
    this->screen_w = SetupManager::Instance()->GetW();
    this->screen_h = SetupManager::Instance()->GetH();
    this->windowed = //true;
                     false; 
#ifdef DEBUG
    this->status[0] = '\0';
#endif

    CoInitialize(NULL);
}


Renderer::~Renderer()
{
  //  DIE(pCurrentDevice == NULL && "Renderer was not DeInitialised!");
  if (CMeshManager::Instance())
     delete CMeshManager::Instance();
  if (pCurrentDevice) pCurrentDevice->Release();
  if (pD3DInterface) pD3DInterface->Release();
  if(hCurrentWindow != NULL)
  {
    DestroyWindow(hCurrentWindow);
  }
  hCurrentWindow = NULL;
  CoUninitialize();
}

#ifdef DEBUG

void Renderer::AddText(const char *str)
{
  cat_snprintf(this->status, sizeof(this->status), str);
}

void Renderer::RenderDebugText()
{
  if (this->status[0] != '\0')
  {
     f1->DrawText( 10, 10, D3DCOLOR_ARGB(255,250,250,250), this->status, D3DFONT_FILTERED );
     this->status[0] = '\0';
  }
}
#endif

bool Renderer::BeginRender()
{
  pCurrentDevice->Clear(0,0,D3DCLEAR_TARGET | D3DCLEAR_STENCIL |D3DCLEAR_ZBUFFER,0,1.0f,0);
  if(FAILED(pCurrentDevice->BeginScene()))
  {
    return false;
  }
  return true;
}

bool Renderer::EndRender()
{
 
#ifdef DEBUG
//  this->RenderDebugText();
#endif
  if (FAILED(pCurrentDevice->EndScene()))
  {
    return false;
  }
  pCurrentDevice->Present(NULL,NULL,NULL,NULL);
  return true;
}

bool Renderer::Init(bool reload)
{
   
  if (pD3DInterface == NULL)

  {
    pD3DInterface = Direct3DCreate9(D3D_SDK_VERSION);
    if (pD3DInterface == NULL)
    {
      LogCritical("Direct3D interface not initialised!\n");
      return false;
    }
  }
  if(hCurrentWindow == NULL)
    if (!custCreateWindow()) 
      return false;
  if (pCurrentDevice == NULL)
  {
    D3DPRESENT_PARAMETERS PP;
    memset(&PP,0,sizeof(PP));

    PP.Windowed				         = this->windowed;
    PP.BackBufferCount		     = 1;
    PP.SwapEffect			         = D3DSWAPEFFECT_DISCARD;

    PP.EnableAutoDepthStencil  = TRUE;
    PP.AutoDepthStencilFormat  = D3DFMT_D24S8;
    PP.hDeviceWindow		       = hCurrentWindow;
    PP.PresentationInterval    = D3DPRESENT_INTERVAL_ONE;//DEFAULT;
    PP.BackBufferWidth         = this->screen_w; 

    PP.BackBufferHeight        = this->screen_h;
    PP.BackBufferFormat        = D3DFMT_A8R8G8B8;
    PP.MultiSampleType = D3DMULTISAMPLE_NONE;//D3DMULTISAMPLE_4_SAMPLES;
    if (FAILED(pD3DInterface->CreateDevice(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
      hCurrentWindow,    
      D3DCREATE_HARDWARE_VERTEXPROCESSING |D3DCREATE_MULTITHREADED,
      &PP ,&pCurrentDevice)))
    {
      LogCritical("Failed to create device!");
      return false;
    }
  }


  if (!CMeshManager::Instance())
    new CMeshManager;
  
  if(!CMeshManager::Instance()->Init(reload))
    return false;

  if (!Input::Instance()->Init(GetModuleHandle(0),hCurrentWindow))
    return false;

  CAudio::Instance()->InitDirectSound( DEFAULT_AUDIO_CHANNELS,
                                           DEFAULT_AUDIO_FREQUENCY,
									                         DEFAULT_AUDIO_BITRATE );

  CAudioManager::Instance()->Init();/**/
    
  this->active = true;

#ifdef DEBUG	

  f1 = new CD3DFont( _T("Arial"), 10, D3DFONT_BOLD );
  if( f1 == NULL )
  {
    return false;
  }

	f1->InitDeviceObjects(this->pCurrentDevice);
	f1->RestoreDeviceObjects();
	
#endif
  bool retval;
  if (!this->windowed ) 
  {
    retval = true;
  }
  else
  {
    retval = (ShowWindow(hCurrentWindow,SW_SHOW) == 0);
  }


  return retval;
}


int Renderer::DeInit()
{
  int count = 0;
#ifdef DEBUG
  if(f1)
  {
	  delete f1;
  }
#endif

  if(CAudioManager::Instance())
  {
    CAudioManager::Instance()->DeInit();
  }
  if(CAudio::Instance())
  {
    CAudio::Instance()->DeInitDirectSound();
  }
  if(CMeshManager::Instance())
  {
    count = CMeshManager::Instance()->DeInit();
  }
  /*
  if (Input::Instance())
  {
    Input::Instance()->DeInit();
  }
  */


 /* pCurrentDevice = NULL;
  DestroyWindow(hCurrentWindow);
  hCurrentWindow = NULL;*/
  return count;
}

bool Renderer::custDestroyWindow()
{
  DestroyWindow(hCurrentWindow);
  hCurrentWindow = NULL;
  return true;
}


void Renderer::ProcessWindowMessages()
{
    MSG msg;
    
    
    while ( PeekMessage(&msg,NULL,0,0,PM_REMOVE))   
    {
        if (msg.message == WM_QUIT)
        {
            POST_EVENT(ET_GLOBAL, GEID_QUIT, true, NULL);
            return;
        }
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

bool Renderer::custCreateWindow()
{
    HINSTANCE hInst = GetModuleHandle(0);
    
    if( mClassAtom == NULL )
        if ( !custRegisterClass() )
            return false;
    hCurrentWindow = CreateWindow("Volleyball04", "Volleyball 04",
                     WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT,  
                     this->screen_w, this->screen_h, (HWND) NULL, (HMENU) NULL, GetModuleHandle(0),
                     (LPVOID) NULL);
    return ( hCurrentWindow != NULL );    
    
}

bool Renderer::Validate()
{
  HRESULT res;
  res = pCurrentDevice->TestCooperativeLevel();
  if (res == D3DERR_DEVICELOST)
    return false;
  if (res == D3DERR_DEVICENOTRESET)
  {
     return Reset();
  }
  if (FAILED(res)) return false;
  return true;
}
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


bool Renderer::custRegisterClass()
{
    HINSTANCE hInstance = GetModuleHandle(0);
    WNDCLASSEX wcx; 
 
    wcx.cbSize = sizeof(wcx);          
    wcx.style = CS_HREDRAW | CS_VREDRAW; 
    wcx.lpfnWndProc = WindowProc;    
    wcx.cbClsExtra = 0;     
    wcx.cbWndExtra = 0;     
    wcx.hInstance = GetModuleHandle(0);
    wcx.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON));
    wcx.hCursor = LoadCursor(NULL,IDC_ARROW);                
    wcx.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);              
    wcx.lpszMenuName = NULL;
    wcx.lpszClassName = "Volleyball04";
    wcx.hIconSm = (HICON)LoadImage(hInstance, MAKEINTRESOURCE(IDI_ICON), IMAGE_ICON, 
        GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR);
 
    // Register the window class. 
    mClassAtom =  RegisterClassEx(&wcx);
    return (mClassAtom != 0); 


}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_CLOSE  : 
	        PostQuitMessage(0);
	        break;
        case WM_DESTROY:
	        PostQuitMessage(0);
	        break;
        
        case WM_ACTIVATE:
          if(wParam==WA_ACTIVE||wParam==WA_CLICKACTIVE)
          {
            Input::Instance()->SetAquire(true);
            break;
          }
          if(wParam==WA_INACTIVE)
          {								
            Input::Instance()->SetAquire(false);
            break;
          }
        break;
        default:  return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return 0;
}



bool Renderer::Reset()
{
   
    int count = this->DeInit();
    ShowWindow(hCurrentWindow,SW_RESTORE);
    D3DPRESENT_PARAMETERS PP;
    memset(&PP,0,sizeof(PP));
    PP.Windowed				         = this->windowed;
    PP.BackBufferCount		     = 1;
    PP.SwapEffect			         = D3DSWAPEFFECT_DISCARD;
    PP.EnableAutoDepthStencil  = TRUE;
    PP.AutoDepthStencilFormat  = D3DFMT_D24S8;
    PP.hDeviceWindow		       = hCurrentWindow;
    PP.PresentationInterval    = D3DPRESENT_INTERVAL_ONE;//DEFAULT;
    PP.BackBufferWidth         = this->screen_w; 
    PP.BackBufferHeight        = this->screen_h;
    PP.BackBufferFormat        = D3DFMT_A8R8G8B8;
    //PP.MultiSampleType = D3DMULTISAMPLE_4_SAMPLES;
    HRESULT hr =this->pCurrentDevice->Reset(&PP);
    if (FAILED(hr))
    {
      return false;
    }
    //GUI::Instance()->DisplayLoadingScreen();
    POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, count, true, NULL);
    
    this->Init(true);
    HRESULT res = pCurrentDevice->TestCooperativeLevel();
    if (SUCCEEDED(S_OK))
    {
      SetupManager::Instance()->UpdateSound(NULL);
      return true;
    }
    else return false;
}
E:\Project\Kopia (5) VBEngine\Graphics\renderer.h
#ifndef _RENDERER_H
#define _RENDERER_H

/*
class       : Renderer
description : Zarzadzanie oknami, interface'ami D3D, Walidacja Device itp.

methods     : Init                  - tworzenie okna, rejestrowanie klasy jesli potrzebna
                                      tworzenie interface'u D3D i urzadzenia
              DeInit                - usuwanie urzadzenia, niszczenie okna
              Validate              - sprawdzanie utracenia device'a
              ProcessWindowMessages - sprawdzanie wiadomosci przychodzacych do okna;
              custRegisterClass     - tworzy nowa klase okna
              custCreateWindow      - tworzy okno 
              custDestroyWindow     - niszczy okno             
*/
class CD3DFont;

class Renderer : public Singleton<Renderer>
{
    LPDIRECT3D9        pD3DInterface;

    LPDIRECT3DDEVICE9  pCurrentDevice;
    HWND               hCurrentWindow;
    ATOM               mClassAtom;
    bool               active;
    bool custCreateWindow();
    
    bool custRegisterClass();
    
    bool windowed;
#ifdef DEBUG
	char status[2048];
	CD3DFont*     f1;
  void RenderDebugText();
#endif

public:
  int screen_w, screen_h;
#ifdef DEBUG
	void AddText(const char *str);
#endif

  bool custDestroyWindow();
    Renderer();
    ~Renderer();
    bool Init(bool reload = false);
    int DeInit();
    bool Validate();
    bool Reset();
    void ProcessWindowMessages();
    bool BeginRender();
    bool EndRender();    
    LPDIRECT3DDEVICE9 GetDevice() {return pCurrentDevice;}
    HWND GetWindowHandle() {return hCurrentWindow;}

    int GetScreenWidth() { return this->screen_w; }
    int GetScreenHeight() { return this->screen_h; }
};

#endif 
E:\Project\Kopia (5) VBEngine\Graphics\SceneManager.cpp
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>

#include "..\utility\VBmath.h"
#include "..\utility\defines.h"
#include "..\utility\misc.h"
#include "..\utility\singleton.h"
#include "..\utility\ctime.h"

#include "Shader.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "MaterialManager.h"
#include "mesh.h"
#include "meshmanager.h"

#include "renderer.h"

#include "Camera.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"

#include "..\Core\User.h"
#include "..\Core\UserManager.h"

// hak dla kamer
#include "..\Core\Team.h"
#include "..\Core\Game.h"

#include "SceneObject.h"
#include "SceneManager.h"

SceneManager::SceneManager(): EventHandler(ET_SCENE), root(NULL)
{
  mCameraType = 0;
  this->camera.Init();
}

SceneManager::~SceneManager()
{
  this->camera.DeInit();
}

void SceneManager::Render()
{
  if(Renderer::Instance()->Validate())
  {
    if(Renderer::Instance()->BeginRender())
    {
      SceneObject *pCurrentObj;
      ListNode *current = root;
      camera.Update();
      while(current && (pCurrentObj = current->GetItem(&current)))
      {
        pCurrentObj->Render(this->camera.GetViewProjMatrix());
      }
         Renderer::Instance()->EndRender();
    }
  }

}

void SceneManager::ProcessEvent(Event *event)
{
  

  switch(event->mID)
  {
  case VBKEY_PRIOR:
    {
       camera.zoom+=0.01f;
		   if (camera.zoom > 1.1) camera.zoom = 1.1f;
       camera.AxisRotation(CVector3(0,0,1), CVector3(0,0,0), 0.0f);
       break;
    }

  case VBKEY_INSERT:
    {
      camera.zoom-=0.01f;
		  if (camera.zoom < 0.7) camera.zoom = 0.7f;
      camera.AxisRotation(CVector3(0,0,1), CVector3(0,0,0), 0.0f);
      break;
    }

  case VBKEY_END:
    {
      camera.AxisRotation(camera.GetCross(), CVector3(0,0,0), -0.01f);
      break;
    }

  case VBKEY_F1:
    {
      if (CGame::Instance() && CGame::Instance()->GetRotatedTeam())
      {
        mCameraType = 0;
        this->camera.ChangeCamera(0);
        return;
      }
      else
      {
        mCameraType = 1;
        this->camera.ChangeCamera(1);
        return;
      }
    }

  case VBKEY_F2:
    {
      if (CGame::Instance() && CGame::Instance()->GetRotatedTeam())
      {
        mCameraType = 1;
        this->camera.ChangeCamera(1);
        return;
      }
      else
      {
        mCameraType = 0;
        this->camera.ChangeCamera(0);
        return;
      }

    }

  case VBKEY_F3:
    {
      if (CGame::Instance() && CGame::Instance()->GetRotatedTeam())
      {
        mCameraType = 2;
        this->camera.ChangeCamera(2);
        return;
      }
      else
      {
        mCameraType = 3;
        this->camera.ChangeCamera(3);
        return;
      }
    }

  case VBKEY_F4:
    {
      if (CGame::Instance() && CGame::Instance()->GetRotatedTeam())
      {
        mCameraType = 3;
        this->camera.ChangeCamera(3);
        return;
      }
      else
      {
        mCameraType = 2;
        this->camera.ChangeCamera(2);
        return;
      }
    }

  case VBKEY_NEXT:
    {
      this->camera.AxisRotation(CVector3(0,0,1), CVector3(0,0,0), -0.01f);
      return;
    }

  case VBKEY_DELETE:
    {
      this->camera.AxisRotation(CVector3(0,0,1), CVector3(0,0,0), 0.01f);
      return;
    }

  case VBKEY_HOME:
    {
      this->camera.AxisRotation(camera.GetCross(), CVector3(0,0,0), 0.01f);
      return;
    }
#ifdef DEBUG
  case VBKEY_C:
    {
      this->camera.Move(-0.3f);
      break;
    }
    case VBKEY_X:
    {
      this->camera.Move(0.3f);
      break;
    }
    case VBKEY_W:
      {
        this->camera.StrafeUD(-0.3f);
        break;
      }
    case VBKEY_S:
      {
        this->camera.StrafeUD(0.3f);
        break;
      }
    case VBKEY_D:
      {
        this->camera.StrafeRL(-0.3f);
       break;
      }
    case VBKEY_A:
      {
        this->camera.StrafeRL(0.3f);
        break;
      }
#endif
  }

}

void SceneManager::AddObject(SceneObject *object)


/*
class       :
description :

methods     :

*/


class Default
{






};
E:\Project\Kopia (5) VBEngine\Win32\window.h
#include "..\config.h"

#include <assert.h>
#include <time.h>
#include <direct.h>

#ifndef DEBUG
#include <windows.h>
#endif

#include "..\utility\defines.h"
#include "..\utility\Singleton.h"
#include "..\utility\Logger.h"
#include "..\utility\Profile.h"
#include "..\utility\Misc.h"

#include "..\utility\tools.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"


#include "app.h"

// odkomentowac zeby windows wurzucil na koncu wszystkie memory leaki na output.
//#define FIND_MEMORY_LEAKS
#include <crtdbg.h>
#ifdef DEBUG
int main(int argc, char *argv[])
#else
/**/ int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,int nCmdShow)
#endif
{
#ifdef  FIND_MEMORY_LEAKS  
  //  _CrtSetBreakAlloc(34499); 
    //int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
    //tmpFlag |= _CRTDBG_LEAK_CHECK_DF;    
    //tmpFlag |= _CRTDBG_CHECK_ALWAYS_DF;
    //tmpFlag |= _CRTDBG_CHECK_CRT_DF;    
    //_CrtSetDbgFlag( tmpFlag );

  // _CrtSetBreakAlloc(53); 
   //_CrtSetBreakAlloc(54); 
   //_CrtSetBreakAlloc(55); 

    int tmpDbgFlag;
    tmpDbgFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    tmpDbgFlag |= _CRTDBG_DELAY_FREE_MEM_DF;
    tmpDbgFlag |= _CRTDBG_LEAK_CHECK_DF;
    _CrtSetDbgFlag(tmpDbgFlag);
#endif 

#ifdef DO_PROFILE

  char buffer[MAX_FILE_NAME]={0};
  time_t timet;
  time(&timet);
  tm *tim = localtime(&timet);
  mkdir("log");
  my_snprintf(buffer, MAX_FILE_NAME, "log/%d%d%d%d%d.txt", tim->tm_mon+1, tim->tm_mday, tim->tm_hour, 
                                                        tim->tm_min, tim->tm_sec);  
  Logger(LL_MESSAGE,true,buffer);

  Profiler p;
  PROFILE(App);
#endif
  App app;
  if(app.Init())
  {
    app.Run();
  }
  app.Shutdown();

 return 0;
}
E:\Project\Kopia (5) VBEngine\Win32\main.cpp
#ifndef _APP_H
#define _APP_H

/*
class       : App
description : Rdzen aplikacji - podstawowa klasa w ktorej wykonywana jest petla glowna gry

methods     : Init            - inicjalizacja podstawowych modulow gry
              Shutdown        - zamknienie modulow utworzonych w Init
*/


class App :public EventHandler
{
    bool mQuitting;
    virtual void ProcessEvent(Event *event);
public:
    App();
    ~App();
    bool Init();
    void Run();
    void Shutdown();
    void StartNewGame();
    void EndGame();
};

#endif
E:\Project\Kopia (5) VBEngine\Win32\App.h
#include "..\config.h"
#include <crtdbg.h>
#include <assert.h>
#include <d3d9.h>
#include <dinput.h>

#include <stdio.h>
#include <string.h>
#include <direct.h>
#include <time.h>
#include <io.h>
#include <stdlib.h>
#include <search.h>


#include "..\utility\Misc.h"
#include "..\utility\Profile.h"
#include "..\utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\Logger.h"
#include "..\utility\tools.h"
#include "..\utility\VBmath.h"

#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\utility\CTime.h"

#include "..\input\Mapper.h"
#include "..\input\input.h"

#include "..\FileSystem\FileNode.h"
#include "..\FileSystem\BranchNode.h"
#include "..\FileSystem\FileSystem.h"


#include "..\graphics\renderer.h"
#include "..\graphics\Texture.h"
#include "..\graphics\TextureManager.h"
#include "..\graphics\meshmanager.h"

#include "..\graphics\animation.h"
#include "..\graphics\animationmanager.h"
#include "..\graphics\SceneObject.h"
#include "..\graphics\Camera.h"
#include "..\graphics\SceneManager.h"
#include "..\graphics\Stadion.h"
#include "..\graphics\GUI.h"


#include "..\Ai\state.h"
#include "..\Ai\States\StateIdle.h"

#include "..\Ai\TacticManager.h"

#include "..\Audio\Audio.h"
#include "..\Audio\AudioManager.h"

#include "..\Core\User.h"
#include "..\Core\usermanager.h"
#include "..\Core\SetupManager.h"
#include "..\Core\zawodnik.h"

#include "..\Core\Team.h"
#include "..\Core\Ball.h"
#include "..\Core\game.h"

#include "..\Core\worldLeague.h"
#include "..\Core\EuroLeague.h"

#include "App.h"


char *teamDatafiles[] = 
{
  "bra.dat",
  "gre.dat",
  "esp.dat",
  "por.dat",
  "fra.dat",
  "bul.dat",
  "jpn.dat",
  "pol.dat",
  "ita.dat",
  "chn.dat",
  "scg.dat",
  "cub.dat",
  "rus.dat",
  "cze.dat",
  "cro.dat",
  "tur.dat",
  "ger.dat",
  "ned.dat",
  "fin.dat",
  "svk.dat"
};
char *teamNames[] = 
{
  "Brazil",
  "Greece",
  "Spain",
  "Portugal",
  "France",
  "Bulgaria",
  "Japan",
  "Poland",
  "Italia",
  "China",
  "Serbia and Montenegro",
  "Cuba",
  "Russia",
  "Czech republic",
  "Croatia",
  "Turkey",
  "Germany",
  "The Netherlands",
  "Finland",
  "Slovenia"
};

char *team3let[] = 
{
  "BRA",
  "GRE",
  "ESP",
  "POR",
  "FRA",
  "BUL",
  "JPN",
  "POL",
  "ITA",
  "CHN",
  "SCG",
  "CUB",
  "RUS",
  "CZE",
  "CRO",
  "TUR",
  "GER",
  "NED",
  "FIN",
  "SVK"
};
App::App() : EventHandler(ET_GLOBAL),
             mQuitting(false)
{
}

App::~App()
{
}
// Eventy - odziedziczone z EventHandler
void App::ProcessEvent(Event *event)
{
  int id = event->mID; 
    switch (id)
    {// event wychodzenia - w nastêpnej iteracji przewie pêtle
    case GEID_QUIT: mQuitting = true;return;
    // koniec meczu
    case GEID_END_GAME:
            if (CGame::Instance() && CGame::Instance()->IsMatchOver()) // ignoruj jeœli nie ma gry, albo nie ma koñca meczu
            {
              if (WorldLeague::Instance()) // jest liga œwiatowa 
              {
                // zapisz wyniki w lidze œwiatowej
                WorldLeague::Instance()->MatchOver(CGame::Instance()->GetCurrentSet(),
                                                  CGame::Instance()->GetSetScores());
                bool revange = WorldLeague::Instance()->GetCurrentMatch() < 2; // poprzedni mecz by³ zwyk³y wiêc teraz jest rewan¿
                WorldLeague::Instance()->GetNextMatch(); //hack - pobiera mecz fina³owy po koñcu pó³fina³u
                if (WorldLeague::Instance()->GetCurrentWeekend() < 6) // jest ju¿ fina³
                {//nie 
                  if (!revange) //jest rewan¿
                  { // nie - poka¿ drabinke
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_WORLDLEAGUEMAIN,false,NULL);
                  }
                  else
                  {// tak - zacznij mecz rewan¿owy
                    POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,0,false,NULL);
                  }
                }
                else
                {// tak jest fina³
                  if (WorldLeague::Instance()->GetNextMatch() == NULL) // nie ma meczu ju¿
                  {// poka¿ panel zwyciêstwa
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_LEAGUEOVER,false,NULL);
                  }
                  else
                  {// s¹ jeszcze - poka¿ drabinke fina³u
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_WORLDLEAGUEFINAL,false,NULL);
                  } 
                }
              }else

              if (EuroLeague::Instance()) // to samo co powy¿ej dla euroligi
              {
                
                EuroLeague::Instance()->MatchOver(CGame::Instance()->GetCurrentSet(),
                                                  CGame::Instance()->GetSetScores());
                bool revange = EuroLeague::Instance()->GetCurrentMatch() < 2;
                EuroLeague::Instance()->GetNextMatch(); //hack
                if (EuroLeague::Instance()->GetCurrentWeekend() < 6)
                {
                  if (!revange)
                  {
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_EUROLEAGUEMAIN,false,NULL);
                  }
                  else
                  {
                    POST_EVENT2(ET_GLOBAL,GEID_NEW_GAME,0,false,NULL);
                  }
                }
                else
                {
                  if (EuroLeague::Instance()->GetNextMatch() == NULL)
                  {
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_LEAGUEOVER,false,NULL);
                  }
                  else
                  {
                    POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_WORLDLEAGUEFINAL,false,NULL);
                  } 
                }
              }else
              { // nie ma ani tej ani tej, znaczy sie mecz towarzyski by³ - wychodzimy do menu
                POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_SELECTGAME,false,NULL);
              }// kasujemy gre - ju¿ nam nie potrzebna
              delete CGame::Instance();
              // wy³adowujemy obiekty z gry
              CMeshManager::Instance()->CleanList();

              POST_EVENT(ET_AUDIO, LAST_AUDIO, true, NULL);
              POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, 0, true, NULL);
              return;
            }
            break;
    case GEID_NEW_GAME: // nowa gra
      if (!CGame::Instance()) // zaczynamy now¹ gre tylko jeœli nie ma ju¿ jakiejœæ
      {
        char *team0dat, *team1dat;
        bool ai,swapped = false;
        int stadium = -1;
        if (WorldLeague::Instance()) // jest liga œwiatowa wiêc z niej pobieramy
        {
          ai = true; // pobieramy mecz, przeciwnik napewno jest ai
          match *m = WorldLeague::Instance()->GetNextMatch();
          if (WorldLeague::Instance()->IsMatchSwapped()) // mecz jest obrócony
          {
            // jeœli jest pólfina³ stadion bierzemy z drugiego zespo³u, jeœli nie gramy na stadionie team 0
            if (WorldLeague::Instance()->GetCurrentWeekend() < 6) swapped = true; 
              team0dat = teamDatafiles[m->teams[1]];  // pobieranie datów
              team1dat = teamDatafiles[m->teams[0]];  // pobieranie datów
          }
          else
          {
              team0dat = teamDatafiles[m->teams[0]]; //pobieranie datów
              team1dat = teamDatafiles[m->teams[1]]; //pobieranie datów
          }
        }else
        if (EuroLeague::Instance()) // to samo co powy¿ej tylko dla euroligi
        {
          ai = true;
          match *m = EuroLeague::Instance()->GetNextMatch();
          if (EuroLeague::Instance()->IsMatchSwapped())
          {
              if (EuroLeague::Instance()->GetCurrentWeekend() < 6) swapped = true;
              team0dat = teamDatafiles[m->teams[1]]; 
              team1dat = teamDatafiles[m->teams[0]];
          }
          else
          {
              team0dat = teamDatafiles[m->teams[0]]; 
              team1dat = teamDatafiles[m->teams[1]];
          }
        }
        else
        { // mecz towarzyski
          union _u
          {
            char c[4];
            unsigned long l;
          }u;
          u.l = event->mID2; // spakowana unia wys³ana z gui
          team0dat = teamDatafiles[u.c[0]]; // id zespo³ów 
          team1dat = teamDatafiles[u.c[1]]; // id zespo³ów 
          ai = u.c[2] == 1; // wybrana opcja sztucznej g³upoty
          stadium = u.c[3]; // stadion na którym gramy
        }

        // wyczyœæ liste GUI
        CMeshManager::Instance()->CleanList();
        // ustaw pasek na wczytywanie 474 elementów
        POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, 474, true, NULL);
        // stwórz now¹ gre - tu sie wszystko wczyta
        new CGame(team0dat,team1dat, ai,stadium, swapped);
        // ukryj ca³e GUI 
        POST_EVENT2(ET_GUI,GUIE_HIDE_GUI,GUIP_GAMEPLAY,false,NULL);
        // poka¿ panel z gejmpleju
        POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL,GUIP_GAMEPLAY,false,NULL);
        return;
      }
      break;
    case GEID_FORCE_END_GAME:
      { // wybraliœmy exit z menu w czasie gry
        if (CGame::Instance()) // gra jakaœ jest w ogóle
        {// to j¹ kasujemy
          delete CGame::Instance();
          CMeshManager::Instance()->CleanList();
          POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, 0, true, NULL);
        }// jak jest liga to ona tez sie idzie kochaæ
        if (WorldLeague::Instance())
        {
          delete WorldLeague::Instance();
        }// to samo z eurolig¹
        if (EuroLeague::Instance())
        {
        delete EuroLeague::Instance();
        }// poka¿ g³ówne menu
        POST_EVENT(ET_AUDIO, LAST_AUDIO, true, NULL);
        POST_EVENT2(ET_GUI,GUIE_SHOW_PANEL_WITH_RELOAD,GUIP_MAINMENU,false,NULL);
        return;
      }
   }
}

// g³ówna pêtla gry - dzia³a dopóki mQuitting nie zostanie ustawione
void App::Run() 
{
  while(!mQuitting )
  {
    PROFILE(App_run);
    CTime::Instance()->SnapShot();           // pobierz czas aktualnej klatki
    Input::Instance()->GetAllDataToObject(); // pobierz dane z inputa
    UserManager::Instance()->Update();       // sprawdŸ input userów
    EventManager::Instance()->Loop();        // sprawdŸ wszystkie ewenty z danej klatki
    if (CGame::Instance())                   // jeœli jest gra
    {
      CGame::Instance()->Update();            // to j¹ zupdate'uj
    }
    GUI::Instance()->Update();                // GUI - sprawdzanie inputu, animacji itp.
    CAudioManager::Instance()->Update();      // popchnij dŸwiêk do przodu
    SceneManager::Instance()->Render();       // wyrenderuj scene
  }
}



bool App::Init()
{
  PROFILE(App_Init); // zprofiluj APP
  randinit();        // zainicjalizuj generator liczb losowych
  
#if 1
  char ldataFile[] = "\0:\\Config.Dat";
  for(int i=0; i<26; i++)
  {
	  ldataFile[0] = 'A'+ i; 
    ldataFile[3] = 0;
    if(GetDriveType(ldataFile) == DRIVE_CDROM) // czy dany drive jest cdromem
    {// jeœli jest 
      ldataFile[3] = 'C';
      _finddata_t curr_desc;
      intptr_t handle;
      handle = _findfirst(ldataFile, &curr_desc); // czy jest na nim datafile
      if (handle == -1) continue; // jeœli nie ma - idziemy dalej
      _findclose(handle);
      break; // jest - wychodzimy 
    }
	}
  if (i == 26) // jeœli pêtla skoñæzy³a sie sama - wywal b³¹d braku p³ytki
  {
#if ENGLISH
    MessageBox(NULL,"Please insert the Volleyball 2004 Play Disk into any CD-ROM Drive and restart the application","Error",MB_OK);
#elif GERMAN
    MessageBox(NULL,"Bitte Legen Sie die Volleyball 2004 Play Disk ins CD Laufwerk, und starten Sie die Spiel noch mal","Fehler",MB_OK);
#elif FRENCH
    MessageBox(NULL,"Mettre le disque Volleyball 2004 Play Disk au lecteur disque et relance un jeu.","Erreur",MB_OK);
#else
    MessageBox(NULL,"Prosze w³o¿yæ dysk Volleyball 2004 Play Disk do napêdu CD i uruchomiæ ponownie aplikacje.","Error",MB_OK);
#endif
    return false; // i wyjdŸ z gry
  }
  new FileSystem(ldataFile); // stwórz filesystem z datów na cdku
  FileSystem::Instance()->FindDataFiles(); // znajdŸ datafile w katalogu z gr¹
#else
char ldataFile[] = "Datafile.srt";
  new FileSystem(ldataFile); 
#endif
  new CTime;  // rozpocznij bieg czasu
#if 1
  if ( Logger::Instance() == NULL ) // jeœli w mainie nie stworzy³o loggera, stwórz tutaj
  {
     new Logger(LL_CRITICAL,false,NULL);
  }
#endif
  // te obiekty poni¿ej to singletony - one same pamiêtaj¹ o pointerach do siebie :D
  new SetupManager;  
  new Input;
  new Renderer;    
  new SceneManager;
  new AnimationManager;
  new UserManager;
  new CAudio;
  new CAudioManager;

  CTime::Instance()->SnapShot(); // pobierz czas klatki zerowej
  SetupManager::Instance()->Init();  // zainicjalizuj setup
  if (!Renderer::Instance()->Init()) return false; // zainicjalizuj renderera - jak nie da sie to wyjdŸ
  
  new GUI(); // stwórz GUI

  new CTacticManager(); // stwórz taktyki
  if (!CTacticManager::Instance()->LoadSetups("pozycje.dat")) return false;
  if (!CTacticManager::Instance()->LoadPhases("phases.dat")) return false;
  
  
  UserManager::Instance()->AddUser(); // stwórz dwóch userów
  UserManager::Instance()->AddUser();

  FileSystem::Instance()->Flush(); // wy¹duj œmieci z datafile'a
  return true;
}

// shutdown - deinituje ca³¹ gre
void App::Shutdown()
{ 
  PROFILE(App_shutdown);
  if (CGame::Instance())
  {
    delete CGame::Instance();
  }
  if (CAudioManager::Instance())
  {
    CAudioManager::Instance()->DeInit();
    delete CAudioManager::Instance();
  }
  if (CAudio::Instance())
  {
    CAudio::Instance()->DeInitDirectSound();
    delete CAudio::Instance();
  }/**/
  if (UserManager::Instance())
  {
    delete UserManager::Instance();
  }
  if (AnimationManager::Instance())
  {
    delete AnimationManager::Instance();
  }
  if( GUI::Instance() )
  {
    delete GUI::Instance();
  } 
  if (SceneManager::Instance())
  {
    delete SceneManager::Instance();
  }

  if( Renderer::Instance() )
  {
    Renderer::Instance()->DeInit();
    delete Renderer::Instance();
  }
/* if( Logger::Instance() )
  {
    delete Logger::Instance();
  }*/
  if (CTime::Instance())
  {
    delete CTime::Instance();
  }
  if (Input::Instance())
  {
    Input::Instance()->DeInit();
    delete Input::Instance();
  }	
  if (FileSystem::Instance())
  {
    delete FileSystem::Instance();
  }
  if (CTacticManager::Instance())
  {
    delete CTacticManager::Instance();
  }
  if (SetupManager::Instance())
  {
    delete SetupManager::Instance();
  }
}


void App::StartNewGame()
{
}
E:\Project\Kopia (5) VBEngine\Win32\App.cpp
#ifndef VBMATH_H
#define VBMATH_H

#include "..\config.h"

#include <assert.h>
#include "..\utility\defines.h"
#include "..\Utility\Singleton.h"
#include <math.h>
#include "..\utility\misc.h"
#include "..\utility\logger.h"

#define NORMAL_MAXX 1
#define NORMAL_MAXY 2
#define NORMAL_MAXZ 3

#define PI 3.14159265358979323846f
#define UNIROOT(a,r)(exp(log(a)/(r)))
#define UNIROOT2(a)(expf(logf(a)*(0.5f)))
#define SGN(a)(((a)<0.0f) ? -1.0f : 1.0f)
#define A2RAD(alpha) (((alpha)*PI)/180.0f)
#define RAD2A(rad) (((rad)*180.0f)/PI)
#define EPSILON (1e-3)
#define ROUND(x) ((int)(x+0.5f))
#define sin45  0.70710678118f
#define cos45  0.70710678118f
#define sin135 0.70710678118f
#define cos135 -0.70710678118f
#define sin225 -0.70710678118f
#define cos225 -0.70710678118f
#define sin315 -0.70710678118f
#define cos315 0.70710678118f

#define isnan(x) ((x) != (x))

class CVector4;
class CVector3;
class CMatrix3;
class CMatrix4;

bool testAllVBMath();

static inline float safeacosf(float rad_angle)
{
  if ( rad_angle > 0.0f && rad_angle-1.0f > 0.0f ||  
       rad_angle < 0.0f && rad_angle+1.0f < 0.0f )
  {    
    rad_angle = SGN(rad_angle) * 1.0f;
  }
  return acosf(rad_angle);
}

/*
  
*/
static inline float *Vector3Add(float *outvec, const float *vec1, const float *vec2)
{
  outvec[0] = vec1[0]+vec2[0];
  outvec[1] = vec1[1]+vec2[1];
  outvec[2] = vec1[2]+vec2[2];
  return outvec;
}

static inline float *Vector3Subtract(float *outvec, const float *vec1, const float *vec2)
{
  outvec[0] = vec1[0]-vec2[0];
  outvec[1] = vec1[1]-vec2[1];
  outvec[2] = vec1[2]-vec2[2];
  return outvec;
}

static inline float *Vector3Multiply(float *out, const float *vec1, float value)
{
  out[0] = vec1[0] * value;
  out[1] = vec1[1] * value;
  out[2] = vec1[2] * value;
  return out;
}

static inline float *VecVec3Multiply(float *out, const float *vec1, const float *vec2)
{
  out[0] = vec1[0] * vec2[0];
  out[1] = vec1[1] * vec2[1];
  out[2] = vec1[2] * vec2[2];
  return out;
}

static inline float *Vector3Divide(float *out, const float *vec1, float value)
{
  out[0] = vec1[0] / value;
  out[1] = vec1[1] / value;
  out[2] = vec1[2] / value;
  return out;
}

static inline float Vector3Dot(const float *vec1,const float *vec2)
{
  return ((vec1[0] * vec2[0]) + (vec1[1] * vec2[1]) + (vec1[2] * vec2[2]));
}

static inline float *Vector3Cross(float *result, const float *vec1, const float *vec2)
{
   result[0] = (vec1[1] * vec2[2]) - (vec1[2] * vec2[1]);
   result[1] = (vec1[2] * vec2[0]) - (vec1[0] * vec2[2]);
   result[2] = (vec1[0] * vec2[1]) - (vec1[1] * vec2[0]);
   return result;
}

static inline float Vector3Length(const float *vec)
{
  return sqrtf(Vector3Dot(vec, vec));
}

static inline float *Vector3Normalize(float *result, const float *vec)
{
  return Vector3Divide(result, vec, Vector3Length(vec) );	  
}

class CVector3 {
   public:
      union {         
         struct {
            float x, y, z;
         };
         float tab [ 3 ];
      };

    CVector3() : x(0),y(0),z(0) {};
    CVector3(float ix, float iy, float iz) : x(ix),y(iy),z(iz){};
    CVector3(CVector3 &v) {this->x = v.x;this->y = v.y;this->z = v.z;}

    void Set(float ix, float iy, float iz) { x=ix; y=iy; z=iz;  }
    void Set(CVector3 *ptr) { if(ptr) { x = ptr->x; y = ptr->y; z = ptr->z; } }

	  CVector3 operator -(); 
    CVector3 operator +(){ return *this; } 

    CVector3 operator  +  ( const CVector3 &V );
    CVector3 &operator += ( CVector3 &V ) { Vector3Add(this->tab, this->tab, V.tab); return *this; }

    CVector3 operator  -  ( const CVector3 &V );      
    CVector3 &operator -= ( CVector3 &V ) { Vector3Subtract(this->tab, this->tab, V.tab); return *this; }

    CVector3 operator  *  ( float scalar ) ;      
    CVector3 &operator *= ( float scalar ) { Vector3Multiply(this->tab, this->tab, scalar); return *this; }

    CVector3 operator  /  ( float scalar );      
    CVector3 &operator /= ( float scalar ) { Vector3Divide(this->tab, this->tab, scalar); return *this; }
      
    CVector3 operator  * ( const CVector3 &V );	  

    operator float* ()
    {
      return tab;
    }
    operator const float* () const 
    {
      return tab;
    }
     
    float Dot (const CVector3 *V ) { return Vector3Dot(this->tab, V->tab); }
    
    CVector3 *Cross (CVector3 *out, const CVector3 *vec2 ) { Vector3Cross(out->tab, this->tab, vec2->tab); return out; }
    CVector3 Cross ( const CVector3 *vec2 ) 
    { 
      CVector3 out;
      Vector3Cross(out.tab, this->tab, vec2->tab);
      return out;
    }

    CVector3 ProjectOnto ( CVector3 &V );
    void Normalize () { Vector3Normalize(this->tab,this->tab);  }    
	  CVector3 &RotateBy(CVector3 xyz);
    CVector3 &ArbitraryRotate(float theta,CVector3 rot_vec);
    
    float Length () { return Vector3Length(this->tab); };
    float LengthSq () { return Vector3Dot(this->tab, this->tab); }

	  void SetLength( float ln );
	      
    friend CVector3 operator * ( float scalar, const CVector3 &V );  
    
};

static inline float *Vector4Add(float *outvec, const float *vec1, const float *vec2)
{
  outvec[0] = vec1[0] + vec2[0];
  outvec[1] = vec1[1] + vec2[1];
  outvec[2] = vec1[2] + vec2[2];
  outvec[3] = vec1[3] + vec2[3];
  return outvec;
}

static inline float *Vector4Subtract(float* outvec, const float *vec1, const float *vec2)
{
  outvec[0] = vec1[0] - vec2[0];
  outvec[1] = vec1[1] - vec2[1];
  outvec[2] = vec1[2] - vec2[2];
  outvec[3] = vec1[3] - vec2[3];  
  return outvec;
}

static inline float *Vector4Multiply(float *outvec, const float *vec1, float value)
{
  outvec[0] = vec1[0] * value;
  outvec[1] = vec1[1] * value;
  outvec[2] = vec1[2] * value;
  outvec[3] = vec1[3] * value;
  return outvec;
}


static inline float *VecVec4Multiply(float *outvec, const float *vec1, const float *vec2)
{
  outvec[0] = vec1[0] * vec2[0];
  outvec[1] = vec1[1] * vec2[1];
  outvec[2] = vec1[2] * vec2[2];
  outvec[3] = vec1[3] * vec2[3];
  return outvec;
}


static inline float *Vector4Divide(float * outvec, const float *vec1, const float value)
{
  outvec[0] = vec1[0] / value;
  outvec[1] = vec1[1] / value;
  outvec[2] = vec1[2] / value;
  outvec[3] = vec1[3] / value;
  return outvec;
}

static inline float Vector4Dot(const float *vec1,const float *vec2)
{
  return ((vec1[0] * vec2[0]) + (vec1[1] * vec2[1]) + (vec1[2] * vec2[2]) + (vec1[3] * vec2[3]));
}

static inline float Vector4Length(const float *vec)
{
  return sqrtf(Vector4Dot(vec, vec));
}

static inline float *Vector4Normalize(float *result, const float *vec)
{
  return Vector4Divide(result, vec, Vector4Length(vec) );	  
}

class CVector4 {
   public:
       
       union {           
           struct {
               float x, y, z, w;
           };
           float tab [ 4 ];
       };

	  CVector4( );
	  CVector4(float ix, float iy, float iz, float iw) { x=ix; y=iy; z=iz; w=iw;  }
    CVector4(CVector4 &v) {this->x = v.x;this->y = v.y;this->z = v.z;this->w = v.w;}

    operator float* ()
    {
      return tab;
    }
    operator const float* () const 
    {
      return tab;
    }

    void Set(float ix, float iy, float iz,float iw) { x=ix; y=iy; z=iz; w=iw;  }
    void Set(CVector4 *ptr) { if(ptr) { x = ptr->x; y = ptr->y; z = ptr->z; w = ptr->w; } }

      CVector4 operator  +  ( CVector4 &V );
      CVector4 &operator += ( CVector4 &V ) { Vector4Add(this->tab, this->tab, V.tab); return *this; }

      CVector4 operator  -  ( CVector4 &V );      
      CVector4 &operator -= ( CVector4 &V ) { Vector4Subtract(this->tab, this->tab, V.tab); return *this; }

      CVector4 operator  *  ( float scalar );      
      CVector4 &operator *= ( float scalar ) { Vector4Multiply(this->tab, this->tab, scalar); return *this; }

      CVector4 operator  /  ( float scalar );      
      CVector4 &operator /= ( float scalar ) { Vector4Divide(this->tab, this->tab, scalar); return *this; }

      CVector4 operator  *  ( CVector4 &V );
      
      float Dot ( CVector4 *V ) { return Vector4Dot(this->tab, V->tab); };

      void Normalize () { Vector4Normalize(this->tab, this->tab); };

      float Length () { return Vector4Length(this->tab); };
      float LengthSq () { return Vector4Dot(this->tab, this->tab); };

      friend CVector4 operator * ( float scalar, const CVector4 &V );
};


#define _M11 0
#define _M12 1
#define _M13 2
#define _M21 3
#define _M22 4
#define _M23 5
#define _M31 6
#define _M32 7
#define _M33 8

//float *Matrix3Multiply(float * outmat, const float *mat1, const float *mat2);
static inline float *Matrix3Transpose(float * inoutmat)
{
  float tmp;

  tmp = inoutmat[_M12];
  inoutmat[_M12] = inoutmat[_M21];
  inoutmat[_M21] = tmp;

  tmp = inoutmat[_M13];
  inoutmat[_M13] = inoutmat[_M31];
  inoutmat[_M31] = tmp;

  tmp = inoutmat[_M23];
  inoutmat[_M23] = inoutmat[_M32];
  inoutmat[_M32] = tmp;

  return inoutmat;
}

static inline float Matrix3Det(const float *mat) {
   return -mat[_M13] * mat[_M22] * mat[_M31] + 
           mat[_M12] * mat[_M23] * mat[_M31] + 
           mat[_M13] * mat[_M21] * mat[_M32] - 
           mat[_M11] * mat[_M23] * mat[_M32] - 
           mat[_M12] * mat[_M21] * mat[_M33] + 
           mat[_M11] * mat[_M22] * mat[_M33];
}


static inline float *MatMat3Multiply(float *outmat, const float* mat1, const float* mat2)
{
   outmat[_M11] = mat1[_M11] * mat2[_M11] + mat1[_M12] * mat2[_M21] + mat1[_M13] * mat2[_M31];
   outmat[_M12] = mat1[_M11] * mat2[_M12] + mat1[_M12] * mat2[_M22] + mat1[_M13] * mat2[_M32];
   outmat[_M13] = mat1[_M11] * mat2[_M13] + mat1[_M12] * mat2[_M23] + mat1[_M13] * mat2[_M33];

   outmat[_M21] = mat1[_M21] * mat2[_M11] + mat1[_M22] * mat2[_M21] + mat1[_M23] * mat2[_M31];
   outmat[_M22] = mat1[_M21] * mat2[_M12] + mat1[_M22] * mat2[_M22] + mat1[_M23] * mat2[_M32];
   outmat[_M23] = mat1[_M21] * mat2[_M13] + mat1[_M22] * mat2[_M23] + mat1[_M23] * mat2[_M33];

   outmat[_M31] = mat1[_M31] * mat2[_M11] + mat1[_M32] * mat2[_M21] + mat1[_M33] * mat2[_M31];
   outmat[_M32] = mat1[_M31] * mat2[_M12] + mat1[_M32] * mat2[_M22] + mat1[_M33] * mat2[_M32];
   outmat[_M33] = mat1[_M31] * mat2[_M13] + mat1[_M32] * mat2[_M23] + mat1[_M33] * mat2[_M33];

   return outmat;
}

static inline float* Matrix3Invert (float * outmat, const float* inmat) 
{   
   float D = Matrix3Det(inmat);

   // macierz jest odwracalne jesli D!=0

   outmat[_M11] = ( -inmat[_M23] * inmat[_M32] + inmat[_M22] * inmat[_M33] ) / D;
   outmat[_M12] = (  inmat[_M13] * inmat[_M32] - inmat[_M12] * inmat[_M33] ) / D;
   outmat[_M13] = ( -inmat[_M13] * inmat[_M22] + inmat[_M12] * inmat[_M23] ) / D;

                                                                             
   outmat[_M21] = (  inmat[_M23] * inmat[_M31] - inmat[_M21] * inmat[_M33] ) / D;
   outmat[_M22] = ( -inmat[_M13] * inmat[_M31] + inmat[_M11] * inmat[_M33] ) / D;
   outmat[_M23] = (  inmat[_M13] * inmat[_M21] - inmat[_M11] * inmat[_M23] ) / D;
                                                                             
   outmat[_M31] = ( -inmat[_M22] * inmat[_M31] + inmat[_M21] * inmat[_M32] ) / D;
   outmat[_M32] = (  inmat[_M12] * inmat[_M31] - inmat[_M11] * inmat[_M32] ) / D;
   outmat[_M33] = ( -inmat[_M12] * inmat[_M21] + inmat[_M11] * inmat[_M22] ) / D;

   return outmat;
}



static inline float *Matrix3Identity(float *mat)
{
  mat[_M11] = 1.0f;
  mat[_M12] = 0.0f;
  mat[_M13] = 0.0f;
  mat[_M21] = 0.0f;
  mat[_M22] = 1.0f;
  mat[_M23] = 0.0f;
  mat[_M31] = 0.0f;
  mat[_M32] = 0.0f;
  mat[_M33] = 1.0f;

  return mat;
}

class CMatrix3 {
   public:
      union {
         struct {
            float        _11, _12, _13;
            float        _21, _22, _23;
            float        _31, _32, _33;
        };

        float M [ 9 ];

        struct {
           CVector3 Row1, Row2, Row3;
        };
        
      };

      CMatrix3 operator  +  ( CMatrix3 &Mat );
      CMatrix3 &operator += ( CMatrix3 &Mat );
      CMatrix3 operator  -  ( CMatrix3 &Mat );
      CMatrix3 &operator -= ( CMatrix3 &Mat );
      CMatrix3 operator  *  ( CMatrix3 &Mat );
      CMatrix3 &operator *= ( CMatrix3 &Mat );

      CMatrix3 operator  *  ( float scalar );
      CMatrix3 &operator *= ( float scalar );

      CMatrix3 operator  /  ( float scalar );
      CMatrix3 &operator /= ( float scalar );

      CVector3  operator  *  ( CVector3 &V );
      
      float *SetIdentity() { return Matrix3Identity(M); }
      float Det () { return Matrix3Det(this->M); }

      operator float* ()
      {
        return M;
      }
      operator const float* () const 
      {
        return M;
      }

      /*
        Znajduje macierz odwrotna
      */
      void Invert () { CMatrix3 mat; Matrix3Invert(mat.M, this->M); *this=mat; }
      CMatrix3 *Transpose ();

      friend CVector3 operator * ( CVector3 &V, CMatrix3 &M );
};

#define _MM11 0
#define _MM12 1
#define _MM13 2
#define _MM14 3

#define _MM21 4
#define _MM22 5
#define _MM23 6
#define _MM24 7

#define _MM31 8
#define _MM32 9
#define _MM33 10
#define _MM34 11

#define _MM41 12
#define _MM42 13
#define _MM43 14
#define _MM44 15

static inline float * Matrix4Vec4Multiply(float *outVec, const float *mat, const float *vec)
{
  outVec[0] = mat[_MM11] * vec[0] + mat[_MM21] * vec[1] + mat[_MM31] * vec[2] + mat[_MM41] * vec[3];
  outVec[1] = mat[_MM12] * vec[0] + mat[_MM22] * vec[1] + mat[_MM32] * vec[2] + mat[_MM42] * vec[3];
  outVec[2] = mat[_MM13] * vec[0] + mat[_MM23] * vec[1] + mat[_MM33] * vec[2] + mat[_MM43] * vec[3];
  outVec[3] = mat[_MM14] * vec[0] + mat[_MM24] * vec[1] + mat[_MM34] * vec[2] + mat[_MM44] * vec[3];
  return outVec;
}

static inline float * MatMat4Multiply(float *outmat, const float *mat1, const float *mat2)
{
   outmat[_MM11] = mat1[_MM11] * mat2[_MM11] + mat1[_MM12] * mat2[_MM21] + mat1[_MM13] * mat2[_MM31] + mat1[_MM14] * mat2[_MM41];
   outmat[_MM12] = mat1[_MM11] * mat2[_MM12] + mat1[_MM12] * mat2[_MM22] + mat1[_MM13] * mat2[_MM32] + mat1[_MM14] * mat2[_MM42];
   outmat[_MM13] = mat1[_MM11] * mat2[_MM13] + mat1[_MM12] * mat2[_MM23] + mat1[_MM13] * mat2[_MM33] + mat1[_MM14] * mat2[_MM43];
   outmat[_MM14] = mat1[_MM11] * mat2[_MM14] + mat1[_MM12] * mat2[_MM24] + mat1[_MM13] * mat2[_MM34] + mat1[_MM14] * mat2[_MM44];
                                                                                                                               
   outmat[_MM21] = mat1[_MM21] * mat2[_MM11] + mat1[_MM22] * mat2[_MM21] + mat1[_MM23] * mat2[_MM31] + mat1[_MM24] * mat2[_MM41];
   outmat[_MM22] = mat1[_MM21] * mat2[_MM12] + mat1[_MM22] * mat2[_MM22] + mat1[_MM23] * mat2[_MM32] + mat1[_MM24] * mat2[_MM42];
   outmat[_MM23] = mat1[_MM21] * mat2[_MM13] + mat1[_MM22] * mat2[_MM23] + mat1[_MM23] * mat2[_MM33] + mat1[_MM24] * mat2[_MM43];
   outmat[_MM24] = mat1[_MM21] * mat2[_MM14] + mat1[_MM22] * mat2[_MM24] + mat1[_MM23] * mat2[_MM34] + mat1[_MM24] * mat2[_MM44];
                                                                                                                               
   outmat[_MM31] = mat1[_MM31] * mat2[_MM11] + mat1[_MM32] * mat2[_MM21] + mat1[_MM33] * mat2[_MM31] + mat1[_MM34] * mat2[_MM41];
   outmat[_MM32] = mat1[_MM31] * mat2[_MM12] + mat1[_MM32] * mat2[_MM22] + mat1[_MM33] * mat2[_MM32] + mat1[_MM34] * mat2[_MM42];
   outmat[_MM33] = mat1[_MM31] * mat2[_MM13] + mat1[_MM32] * mat2[_MM23] + mat1[_MM33] * mat2[_MM33] + mat1[_MM34] * mat2[_MM43];
   outmat[_MM34] = mat1[_MM31] * mat2[_MM14] + mat1[_MM32] * mat2[_MM24] + mat1[_MM33] * mat2[_MM34] + mat1[_MM34] * mat2[_MM44];
                                                                                                                               
   outmat[_MM41] = mat1[_MM41] * mat2[_MM11] + mat1[_MM42] * mat2[_MM21] + mat1[_MM43] * mat2[_MM31] + mat1[_MM44] * mat2[_MM41];
   outmat[_MM42] = mat1[_MM41] * mat2[_MM12] + mat1[_MM42] * mat2[_MM22] + mat1[_MM43] * mat2[_MM32] + mat1[_MM44] * mat2[_MM42];
   outmat[_MM43] = mat1[_MM41] * mat2[_MM13] + mat1[_MM42] * mat2[_MM23] + mat1[_MM43] * mat2[_MM33] + mat1[_MM44] * mat2[_MM43];
   outmat[_MM44] = mat1[_MM41] * mat2[_MM14] + mat1[_MM42] * mat2[_MM24] + mat1[_MM43] * mat2[_MM34] + mat1[_MM44] * mat2[_MM44];

   return outmat;
}

static inline float *Matrix4Transpose(float * inoutmat)
{
  float tmp;

  #define MYSWAP(a,b) tmp = a; a = b; b = tmp;

  MYSWAP( inoutmat[_MM12], inoutmat[_MM12] )
  MYSWAP( inoutmat[_MM13], inoutmat[_MM13] )
  MYSWAP( inoutmat[_MM14], inoutmat[_MM14] )
  MYSWAP( inoutmat[_MM23], inoutmat[_MM23] )
  MYSWAP( inoutmat[_MM24], inoutmat[_MM24] )
  MYSWAP( inoutmat[_MM34], inoutmat[_MM34] )
  
  
  #undef MYSWAP


  return inoutmat;
}

static inline float Matrix4Det(const float *mat)
{
  return  mat[_MM12] * mat[_MM24] * mat[_MM33] * mat[_MM41] -           
          mat[_MM12] * mat[_MM23] * mat[_MM34] * mat[_MM41] -           
          mat[_MM11] * mat[_MM24] * mat[_MM33] * mat[_MM42] +           
          mat[_MM11] * mat[_MM23] * mat[_MM34] * mat[_MM42] -           
          mat[_MM12] * mat[_MM24] * mat[_MM31] * mat[_MM43] +           
          mat[_MM11] * mat[_MM24] * mat[_MM32] * mat[_MM43] +           
          mat[_MM12] * mat[_MM21] * mat[_MM34] * mat[_MM43] -           
          mat[_MM11] * mat[_MM22] * mat[_MM34] * mat[_MM43] + 

          mat[_MM14] * (  mat[_MM23] * mat[_MM32] * mat[_MM41] - mat[_MM22] * mat[_MM33] * mat[_MM41] - 
                          mat[_MM23] * mat[_MM31] * mat[_MM42] + mat[_MM21] * mat[_MM33] * mat[_MM42] + 
                          mat[_MM22] * mat[_MM31] * mat[_MM43] - mat[_MM21] * mat[_MM32] * mat[_MM43] ) +

          mat[_MM44] * (  mat[_MM12] * mat[_MM23] * mat[_MM31] - 
                         mat[_MM11] * mat[_MM23] * mat[_MM32] - 
                         mat[_MM12] * mat[_MM21] * mat[_MM33] + 
                         mat[_MM11] * mat[_MM22] * mat[_MM33] ) +

          mat[_MM13] * ( -mat[_MM24] * mat[_MM32] * mat[_MM41] +
                         mat[_MM22] * mat[_MM34] * mat[_MM41] +
                         mat[_MM24] * mat[_MM31] * mat[_MM42] -
                         mat[_MM21] * mat[_MM34] * mat[_MM42] -
                         mat[_MM22] * mat[_MM31] * mat[_MM44] + 
                         mat[_MM21] * mat[_MM32] * mat[_MM44] );   

}

static inline float * Matrix4Invert(float* outmat, const float* m) 
{
   float D = Matrix4Det(m);
   
   outmat[_MM11] = ( -m[_MM24] * m[_MM33] * m[_MM42] + m[_MM23] * m[_MM34] * m[_MM42] + m[_MM24] * m[_MM32] * m[_MM43] - m[_MM22] * m[_MM34] * m[_MM43] - m[_MM23] * m[_MM32] * m[_MM44] + m[_MM22] * m[_MM33] * m[_MM44] ) / D;
   outmat[_MM12] = (  m[_MM14] * m[_MM33] * m[_MM42] - m[_MM13] * m[_MM34] * m[_MM42] - m[_MM14] * m[_MM32] * m[_MM43] + m[_MM12] * m[_MM34] * m[_MM43] + m[_MM13] * m[_MM32] * m[_MM44] - m[_MM12] * m[_MM33] * m[_MM44] ) / D;
   outmat[_MM13] = ( -m[_MM14] * m[_MM23] * m[_MM42] + m[_MM13] * m[_MM24] * m[_MM42] + m[_MM14] * m[_MM22] * m[_MM43] - m[_MM12] * m[_MM24] * m[_MM43] - m[_MM13] * m[_MM22] * m[_MM44] + m[_MM12] * m[_MM23] * m[_MM44] ) / D;
   outmat[_MM14] = (  m[_MM14] * m[_MM23] * m[_MM32] - m[_MM13] * m[_MM24] * m[_MM32] - m[_MM14] * m[_MM22] * m[_MM33] + m[_MM12] * m[_MM24] * m[_MM33] + m[_MM13] * m[_MM22] * m[_MM34] - m[_MM12] * m[_MM23] * m[_MM34] ) / D;
                                                                                                                                                                                                                        
   outmat[_MM21] = (  m[_MM24] * m[_MM33] * m[_MM41] - m[_MM23] * m[_MM34] * m[_MM41] - m[_MM24] * m[_MM31] * m[_MM43] + m[_MM21] * m[_MM34] * m[_MM43] + m[_MM23] * m[_MM31] * m[_MM44] - m[_MM21] * m[_MM33] * m[_MM44] ) / D;
   outmat[_MM22] = ( -m[_MM14] * m[_MM33] * m[_MM41] + m[_MM13] * m[_MM34] * m[_MM41] + m[_MM14] * m[_MM31] * m[_MM43] - m[_MM11] * m[_MM34] * m[_MM43] - m[_MM13] * m[_MM31] * m[_MM44] + m[_MM11] * m[_MM33] * m[_MM44] ) / D;
   outmat[_MM23] = (  m[_MM14] * m[_MM23] * m[_MM41] - m[_MM13] * m[_MM24] * m[_MM41] - m[_MM14] * m[_MM21] * m[_MM43] + m[_MM11] * m[_MM24] * m[_MM43] + m[_MM13] * m[_MM21] * m[_MM44] - m[_MM11] * m[_MM23] * m[_MM44] ) / D;
   outmat[_MM24] = ( -m[_MM14] * m[_MM23] * m[_MM31] + m[_MM13] * m[_MM24] * m[_MM31] + m[_MM14] * m[_MM21] * m[_MM33] - m[_MM11] * m[_MM24] * m[_MM33] - m[_MM13] * m[_MM21] * m[_MM34] + m[_MM11] * m[_MM23] * m[_MM34] ) / D;
                                                                                                                                                                                                                        
   outmat[_MM31] = ( -m[_MM24] * m[_MM32] * m[_MM41] + m[_MM22] * m[_MM34] * m[_MM41] + m[_MM24] * m[_MM31] * m[_MM42] - m[_MM21] * m[_MM34] * m[_MM42] - m[_MM22] * m[_MM31] * m[_MM44] + m[_MM21] * m[_MM32] * m[_MM44] ) / D;
   outmat[_MM32] = (  m[_MM14] * m[_MM32] * m[_MM41] - m[_MM12] * m[_MM34] * m[_MM41] - m[_MM14] * m[_MM31] * m[_MM42] + m[_MM11] * m[_MM34] * m[_MM42] + m[_MM12] * m[_MM31] * m[_MM44] - m[_MM11] * m[_MM32] * m[_MM44] ) / D;
   outmat[_MM33] = ( -m[_MM14] * m[_MM22] * m[_MM41] + m[_MM12] * m[_MM24] * m[_MM41] + m[_MM14] * m[_MM21] * m[_MM42] - m[_MM11] * m[_MM24] * m[_MM42] - m[_MM12] * m[_MM21] * m[_MM44] + m[_MM11] * m[_MM22] * m[_MM44] ) / D;
   outmat[_MM34] = (  m[_MM14] * m[_MM22] * m[_MM31] - m[_MM12] * m[_MM24] * m[_MM31] - m[_MM14] * m[_MM21] * m[_MM32] + m[_MM11] * m[_MM24] * m[_MM32] + m[_MM12] * m[_MM21] * m[_MM34] - m[_MM11] * m[_MM22] * m[_MM34] ) / D;
                                                                                                                                                                                                                        
   outmat[_MM41] = (  m[_MM23] * m[_MM32] * m[_MM41] - m[_MM22] * m[_MM33] * m[_MM41] - m[_MM23] * m[_MM31] * m[_MM42] + m[_MM21] * m[_MM33] * m[_MM42] + m[_MM22] * m[_MM31] * m[_MM43] - m[_MM21] * m[_MM32] * m[_MM43] ) / D;
   outmat[_MM42] = ( -m[_MM13] * m[_MM32] * m[_MM41] + m[_MM12] * m[_MM33] * m[_MM41] + m[_MM13] * m[_MM31] * m[_MM42] - m[_MM11] * m[_MM33] * m[_MM42] - m[_MM12] * m[_MM31] * m[_MM43] + m[_MM11] * m[_MM32] * m[_MM43] ) / D;
   outmat[_MM43] = (  m[_MM13] * m[_MM22] * m[_MM41] - m[_MM12] * m[_MM23] * m[_MM41] - m[_MM13] * m[_MM21] * m[_MM42] + m[_MM11] * m[_MM23] * m[_MM42] + m[_MM12] * m[_MM21] * m[_MM43] - m[_MM11] * m[_MM22] * m[_MM43] ) / D;
   outmat[_MM44] = ( -m[_MM13] * m[_MM22] * m[_MM31] + m[_MM12] * m[_MM23] * m[_MM31] + m[_MM13] * m[_MM21] * m[_MM32] - m[_MM11] * m[_MM23] * m[_MM32] - m[_MM12] * m[_MM21] * m[_MM33] + m[_MM11] * m[_MM22] * m[_MM33] ) / D;

   return outmat;
}

static inline float *Matrix4Identity(float *mat)
{
  mat[_MM11] = 1.0f;
  mat[_MM12] = 0.0f;
  mat[_MM13] = 0.0f;
  mat[_MM14] = 0.0f;
  
  mat[_MM21] = 0.0f;
  mat[_MM22] = 1.0f;
  mat[_MM23] = 0.0f;
  mat[_MM24] = 0.0f;
  
  mat[_MM31] = 0.0f;
  mat[_MM32] = 0.0f;
  mat[_MM33] = 1.0f;
  mat[_MM34] = 0.0f;

  mat[_MM41] = 0.0f;
  mat[_MM42] = 0.0f;
  mat[_MM43] = 0.0f;
  mat[_MM44] = 1.0f;

  return mat;
}

/*
  fovY - Field of view, in the y direction, in radians
  Aspect - Aspect ratio, defined as view space height divided by width
  zn - Z-value of the near view-plane
  zf - Z-value of the far view-plane

  zwraca wskaznik na samego siebie
*/

static inline float* Matrix4PerspectiveFovRH(float *m, float fovY, float Aspect, float zn, float zf)
{
  float h = 1.0f/tanf(fovY/2);
  m[_MM11] = h / Aspect; m[_MM12] = 0.0f;  m[_MM13] = 0.0f; m[_MM14] = 0.0f;
  m[_MM21] = 0.0f; m[_MM22] = h; m[_MM23] = 0.0f; m[_MM24] = 0.0f;
  m[_MM31] = 0.0f; m[_MM32] = 0.0f; m[_MM33] = zf/(zn-zf);     m[_MM34] = -1.0f;
  m[_MM41] = 0.0f; m[_MM42] = 0.0f; m[_MM43] = zn*zf/(zn-zf);  m[_MM44] =  0.0f;
  return m;
}

/*
  pEye - wektor trzy elementowy, skad sie patrzy
  pAt - wektor trzy elementowy, punkt na ktory sie patrzy
  pUp - wektor trzy elementowy, okesla wektor UP swiata
*/
static inline float* Matrix4LookAtRH(float *m, const float *pEye, const float *pAt,const float *pUp)
{
  float zaxis[3];
  float xaxis[3];
  float yaxis[3];

  Vector3Subtract(zaxis, pEye, pAt);
  Vector3Normalize(zaxis, zaxis);

  Vector3Cross(xaxis, pUp, zaxis);
  Vector3Normalize(xaxis, xaxis);

  Vector3Cross(yaxis, zaxis, xaxis);

  m[_MM11] = xaxis[0]; m[_MM12] = yaxis[0];  m[_MM13] = zaxis[0]; m[_MM14] = 0.0f;
  m[_MM21] = xaxis[1]; m[_MM22] = yaxis[1];  m[_MM23] = zaxis[1]; m[_MM24] = 0.0f;
  m[_MM31] = xaxis[2]; m[_MM32] = yaxis[2];  m[_MM33] = zaxis[2]; m[_MM34] = 0.0f;
  m[_MM41] = -Vector3Dot(xaxis, pEye); 
                      m[_MM42] = -Vector3Dot(yaxis, pEye); 
                                           m[_MM43] = -Vector3Dot(zaxis, pEye);
                                                               m[_MM44] =  1.0f;
  return m;
}

/*
  Funkcja zachowuje siê tak jak D3DXVec3TransformCoord() z biblioteki D3DX.
  matrix - macierz 4x4
  inVec - wektor 3 elementowy
  po transformacji wektor jest dzielony przez wspolczynnik w.
*/
static inline float* Vector3TransformCoord(float *outVec3, const float* matrix4, const float *inVec3)
{
  float tmpVec[4];
  float outTmpVec[4];
  tmpVec[0] = inVec3[0];
  tmpVec[1] = inVec3[1];
  tmpVec[2] = inVec3[2];

  tmpVec[3] = 1;
  Matrix4Vec4Multiply(outTmpVec, matrix4, tmpVec);
  Vector4Divide(outTmpVec, outTmpVec, tmpVec[3]);
  outVec3[0] = outTmpVec[0];
  outVec3[1] = outTmpVec[1];
  outVec3[2] = outTmpVec[2];  
  return outVec3;
}

static inline float *Matrix4Ortho(float w, float h, float zn, float zf, float *mat)
{
  mat[_MM11] = -2.0f/w;
  mat[_MM12] = 0.0f;
  mat[_MM13] = 0.0f;
  mat[_MM14] = 0.0f;
  
  mat[_MM21] = 0.0f;
  mat[_MM22] = -2.0f/h;
  mat[_MM23] = 0.0f;
  mat[_MM24] = 0.0f;
  
  mat[_MM31] = 0.0f;
  mat[_MM32] = 0.0f;
  mat[_MM33] = 1.0f / (zf - zn);
  mat[_MM34] = 0.0f;

  mat[_MM41] = 0.0f;
  mat[_MM42] = 0.0f;
  mat[_MM43] = zn / (zn - zf);
  mat[_MM44] = 1.0f;
 return mat;
}

class CMatrix4
{
public:
	
	union {		
         struct {
            float	 _11, _12, _13, _14;
            float  _21, _22, _23, _24;
            float  _31, _32, _33, _34;
            float  _41, _42, _43, _44;
        };
        
        float M [ 16 ];

        struct {
           CVector4 Row1, Row2, Row3, Row4;
        };
      };

      CMatrix4 operator  +  ( CMatrix4 &Mat );
      CMatrix4 &operator += ( CMatrix4 &Mat );
      CMatrix4 operator  -  ( CMatrix4 &Mat );
      CMatrix4 &operator -= ( CMatrix4 &Mat );
      CMatrix4 operator  *  ( CMatrix4 &Mat );
      CMatrix4 &operator *= ( CMatrix4 &Mat );

      CMatrix4 operator  *  ( float scalar );
      CMatrix4 &operator *= ( float scalar );

      CMatrix4 operator  /  ( float scalar );
      CMatrix4 &operator /= ( float scalar );

	    CVector3  operator  *  ( CVector3 &V ); 
      CVector4  operator  *  ( CVector4 &V );
         
      float *SetIdentity() { return Matrix4Identity(M); }
      float *SetOrtho(float w, float h, float zn, float zf) { return Matrix4Ortho(w,h,zn,zf,M);}
      float Det () { return Matrix4Det(this->M); }

    operator float* ()
    {
      return M;
    }
    operator const float* () const 
    {
      return M;
    }

      /*
        Znajduje macierz odwrotna i zapisuje ja w outmat
      */
      void Invert () { CMatrix4 mat; Matrix4Invert(mat.M,this->M); *this=mat;};
    CMatrix4 *Transpose ();     

	  CMatrix4 Transform(CVector3 &pos, CVector3 &rot, CVector3 &scale);
    CMatrix4 &SetScale(float x1,float x2,float x3);
    CMatrix4 &SetTranslate(float x1,float x2,float x3);
	  void SetRotateX(float fRads);
	  void SetRotateY(float fRads);
	  void SetRotateZ(float fRads);

    /*
      Stosujac ta macierz przksztalca wektor vec, wykonuje mnozenie vec * this->M
      wczesniej wektor vec jest zamieniany na wektor 4-ro elementowy, po transformacji
      wykonywane jest dzielenie przez w tak aby zwrocony wektor mial postac : [x/w, y/w, z/w]
    */
    CVector3 *TransformVector3(CVector3 * outvec)
    {
      Vector3TransformCoord( outvec->tab, this->M, outvec->tab );
      return outvec;
    }

    CVector3 *TransformVector3(CVector3 * outvec,const CVector3 * vec)
    {
      Vector3TransformCoord( outvec->tab, this->M, vec->tab );
      return outvec;
    }	  

	  CMatrix4 *SetCameraLookAtRH(CVector3 *From, CVector3 *At, CVector3 *Up)
    {
      Matrix4LookAtRH(M, From->tab, At->tab, Up->tab);
      return this;
    }
    CMatrix4 *SetPerspectiveFovRH(float fovY, float Aspect, float zn, float zf)
    {
      Matrix4PerspectiveFovRH(M, fovY, Aspect, zn, zf);      
      return this;
    }

    CMatrix3 GetUpper3x3();

    friend CVector4 operator * ( CVector4 &V, CMatrix4 &M );	
};

/*!
  q.x = sin(theta/2) * axis.x
  q.y = sin(theta/2) * axis.y
  q.z = sin(theta/2) * axis.z
  q.w = cos(theta/2)
*/
static inline float *QuaternionRotationAxis(float *outq, const float* axis, float rangle)
{ 
  Vector3Multiply(outq, axis, sinf(rangle/2.0f));  
  //Vector3Normalize(outq,outq);
  outq[3] = cosf(rangle/2.0f);
  return outq;
}

class Quaternion
{
public:
  union 
  {		
    struct 
    {
      float	 x, y, z, w;
    };        
    float tab [ 4 ];
  };
  
  Quaternion(void) : x(0.0f),y(0.0f),z(0.0f),w(0.0f){};
  Quaternion(float e0, float e1, float e2, float e3) : x(e0),y(e1),z(e2),w(e3){}


  operator float* ()
  {
    return tab;
  }
  operator const float* () const 
  {
    return tab;
  }


  float Magnitude() {return Vector4Length(tab);}
  /*
    axis - os obrotu
    angle - w radianach
  */
  void RotationAxis(const CVector3 *axis, float rangle)
  {
    QuaternionRotationAxis(tab, axis->tab, rangle);
  }

  void ConvertToRotationMatrix(CMatrix4 *mat)
  {
    mat->M[_MM11] = 1.0f - 2.0f * (y*y + z*z);
    mat->M[_MM12] = 2.0f * (x*y - w*z);
    mat->M[_MM13] = 2.0f * (w*y + x*z);
    mat->M[_MM14] = 0.0f;

    mat->M[_MM21] = 2.0f * (x*y + w*z);
    mat->M[_MM22] = 1.0f - 2.0f * ( x*x + z*z );
    mat->M[_MM23] = 2.0f * (y*z - w*x);
    mat->M[_MM24] = 0.0f;

    mat->M[_MM31] = 2.0f * ( x*z - w*y );
    mat->M[_MM32] = 2.0f * (y*z + w*x);
    mat->M[_MM33] = 1.0f - 2.0f * (x*x + y*y);
    mat->M[_MM34] = 0.0f;

    mat->M[_MM41] = 0.0f;
    mat->M[_MM42] = 0.0f;
    mat->M[_MM43] = 0.0f;
    mat->M[_MM44] = 1.0f;    
  }
};
#endif
E:\Project\Kopia (5) VBEngine\Utility\vbmath.h
#include <math.h>

//#define DEBUGMATH

#ifdef DEBUGMATH
//#include <d3dx.h>
#include <d3dx9math.h>
#include <stdio.h>
#include <windows.h>
#include <assert.h>
#endif

#include "vbmath.h"


#ifdef DEBUGMATH
bool testAllVBMath()
{

  D3DXMATRIX matrix;
	D3DXQUATERNION q(0,0,0,0);
	D3DXVECTOR3 eye, lookat, upvec, temp, axis(1.0f,1.0f,1.0f);
	D3DXQuaternionRotationAxis(&q, &axis, PI);
  Quaternion q2;
  CVector3 vecq(1.0f, 1.0f, 1.0f);
  q2.RotationAxis(&vecq,PI);
	D3DXMatrixRotationQuaternion(&matrix, &q);
  CMatrix4 outm;
  q2.ConvertToRotationMatrix(&outm);

  CVector3 vec1,res;
  CVector3 vec2(10.0f, 10.0f, 10.0f);
  CVector4 vec4_1, vec4_2(10,10,10,8);

  Vector3Normalize(vecq,vecq);

  // CVector3 test cases
  vec1/=23;
  vec1+=vec2;
  vec1/=131;
  vec1 = (vec1 + (3.0f * vec1) * 5 + vec1 - vec2)/2;
  vec4_1 =  (vec4_1 + (3.0f * vec4_1) * 5 + vec4_1 - vec4_2)/2 ;

  // CMatrix3 test cases
  CMatrix3 mat3_1,mat3_2, mat3inv;
  mat3_1.SetIdentity();  
  mat3_1._11 = 2;
  mat3_2 = mat3_1;

  mat3_2._13=123.34f;
  mat3_2._32=23.34f;
  mat3_2._12=3.34f;

  DIE( mat3_2.Det() != 1 );

  mat3inv = mat3_2;
  mat3_2.Invert();
  
  mat3_1 = mat3_2 * mat3inv;
  float res2 = mat3_1.Det();
  DIE(res2 == 1);

  DIE( mat3_1.Det() == 1 );

  //CMatrix4 test cases
  CMatrix4 mat4_1,mat4_2, mat4inv;
  mat4_1.SetIdentity();  
  mat4_1._11 = 2;
  mat4_2 = mat4_1;

  mat4_2._11=123.34f;
  mat4_2._22=23.34f;
  mat4_2._33=3.34f;
  mat4_2._44=3.34f;
  mat4_2._14=3.34f;

  DIE( mat4_2.Det() != 1 );

  CMatrix4 rem = mat4_2;
  mat4_2.Invert();

  mat4_1 = mat4_2 * rem;
  //mat4_2 *= mat4inv;
  res2 = mat4_1.Det();
  DIE( FABS(res2 - 1.0) < 0.001 );

   // TransformCoord test 
  CVector3 vec_tc(10,10,10);
  CVector3 vec_tc2(30,30,30);
  CVector3 vecOut_tc;
  CMatrix4 mat_tc;
  
  mat_tc.SetTranslate(10,10,10);
  Vector3TransformCoord(vecOut_tc, mat_tc, vec_tc);

  mat_tc.TransformVector3(&vec_tc2);
  DIE(vec_tc2.x == 40 && vec_tc2.y == 40 && vec_tc2.z == 40);

  // LookAt matrix test
  CMatrix4 mat_look1;
  D3DXMATRIX mat_look2;
  D3DXVECTOR3 eye1(10.0f, 100.0f, 100.0f);
  D3DXVECTOR3 at1(54.0f, 1.0f, 10.0f);
  D3DXVECTOR3 up1(0.0f, 1.0f, 0.0f);

  CVector3 eye2(10.0f, 100.0f, 100.0f);
  CVector3 at2(54.0f, 1.0f, 10.0f);
  CVector3 up2(0.0f, 1.0f, 0.0f);

  D3DXMatrixLookAtRH(&mat_look2, &eye1, &at1, &up1);
  mat_look1.SetCameraLookAtRH(&eye2, &at2, &up2);

  for (int i=0; i<16; i++)
  {
    DIE( FABS(mat_look1.M[i]) - FABS( ((float*)mat_look2)[i]) < EPSILON);
  }

   // Perspective matrix test
  CMatrix4 mat_per1;
  D3DXMATRIX mat_per2;
  
  D3DXMatrixPerspectiveFovRH(&mat_per2, PI, 480.0f/640.0f, 100.0f, 500.0f);
  mat_per1.SetPerspectiveFovRH(PI, 480.0f/640.0f, 100.0f, 500.0f);

  for (int i=0; i<16; i++)
  {
    DIE( FABS(mat_per1.M[i]) - FABS( ((float*)mat_per2)[i]) < EPSILON);
  }

  

  // Vector3 Operator tests
  vec1.Set(0,0,0);
  vec2.Set(10,10,10);
  res = vec1 + vec2;
  DIE( res.x == 10.0f && res.y == 10.0f && res.z == 10.0f );

  res = res - vec2;
  DIE( res.x == 0.0f && res.y == 0.0f && res.z == 0.0f );

  vec1.Set(1.0f, 0.0f, 0.0f);
  vec2.Set(0.0f, 1.0f, 0.0f);
  DIE( vec1.Dot(&vec2) == 0.0f );
  DIE( vec1.Dot(&vec1) == 1.0f );

  vec1.Set(10.0f, 11.0f, -55.0f);

  ///*
  D3DXVECTOR3 vec;
  
 // float f1 = UNIROOT(123,2);
 // float f2 = sqrtf(123);
//  DIE( UNIROOT(123,2) == sqrtf(123));
//  DIE( UNIROOT(16,2) == 4);
//  float val = UNIROOT(9,2);
//  DIE( UNIROOT(9,2) == 3);

  int t1 = timeGetTime();
  unsigned int maxn = 100;
  for(unsigned int n=0; n < maxn; n++)
  {
    vec1.Normalize();
   // D3DXVec3Normalize(&vec,&vec);
  }
  


  //vec1.Normalize();
  int t2 = timeGetTime() - t1;
  printf("%d",t2); 
 // */

  DIE(vec1.Length() == 1.0f);
  //DIE(vec1.LengthSq() == 1.0f);
    
  float len = vec1.LengthSq();
  DIE(len == 1.0f);
/*
  if ( vec1.LengthSq() == 1.0 )    
  {
    int n=0;
    n++;
    */
    DIE((vec1.LengthSq() >= 1.0f));
    /*
  }
*/


  return true;
}

#endif

/**********************************************************************

  Vector3 class

 ***********************************************************************/

CVector3 CVector3::operator+ ( const CVector3 &V ) {
   CVector3 R;

   Vector3Add(R.tab, this->tab, V.tab);

   return R;
}


CVector3 CVector3::operator- ( const CVector3 &V ) {
   CVector3 R;

   Vector3Subtract(R.tab, this->tab, V.tab); 

   return R;
}

CVector3 CVector3::operator*  ( float scalar ) {
   CVector3 R;

   Vector3Multiply(R.tab, this->tab, scalar);

   return R;
}


CVector3 CVector3::operator  /  ( float scalar ) {
   CVector3 R(0,0,0);

   Vector3Divide(R.tab, this->tab, scalar);
   
   return R;
}


CVector3 CVector3::operator * ( const CVector3 &V ) {
   CVector3 R;

   VecVec3Multiply( R.tab, this->tab, V.tab );

   return R;
}

CVector3 operator * ( float scalar, const CVector3 &V )
{
   CVector3 R;

   Vector3Multiply( R.tab, V.tab, scalar );

   return R;
}


CVector3 CVector3::operator - () {
	CVector3 R(0,0,0);
  Vector3Multiply(R.tab, this->tab, -1.0f);    
  return R;
}

void CVector3::SetLength( float ln ) 
{  
  Vector3Multiply( this->tab, this->tab, ln / Vector3Length(this->tab));
}

/**
	Arbitrarly rotates point/vector p around r , p degrees

	found on internet: http://astronomy.swin.edu.au/pbourke/geometry/rotate/
	written by Ronald Goldman	

  \param theta angle in radians
  \param rot_vec vector around which rotation will be performed  
*/

CVector3 &CVector3::ArbitraryRotate(float theta,CVector3 rot_vec)
{
   CVector3 q(0.0,0.0,0.0),r=rot_vec;
   float costheta,sintheta;
   
   r.Normalize();
   costheta = cosf(theta);
   sintheta = sinf(theta);

   q.x += (costheta + (1 - costheta) * r.x * r.x) * x;
   q.x += ((1 - costheta) * r.x * r.y - r.z * sintheta) * y;
   q.x += ((1 - costheta) * r.x * r.z + r.y * sintheta) * z;

   q.y += ((1 - costheta) * r.x * r.y + r.z * sintheta) * x;
   q.y += (costheta + (1 - costheta) * r.y * r.y) * y;
   q.y += ((1 - costheta) * r.y * r.z - r.x * sintheta) * z;

   q.z += ((1 - costheta) * r.x * r.z - r.y * sintheta) * x;
   q.z += ((1 - costheta) * r.y * r.z + r.x * sintheta) * y;
   q.z += (costheta + (1 - costheta) * r.z * r.z) * z;

   *this = q;

   return *this;
}



#ifdef DIRECT3D_VERSION 

//CVector3::operator D3DVECTOR () {
//   return *( ( D3DVECTOR * ) this );
//}

//CVector3::operator D3DVECTOR * () {
//   return ( ( D3DVECTOR * ) this );
//}

#endif






/******************************************************************************


******************************************************************************/



CVector4::CVector4(){
	x = y = z = w = 0.0f;
}



CVector4 CVector4::operator + ( CVector4 &V ) {
   CVector4 R;

   Vector4Add(R.tab, this->tab, V.tab);

   return R;
}



CVector4 CVector4::operator - ( CVector4 &V ) {
   CVector4 R;

   Vector4Subtract(R.tab, this->tab, V.tab);

   return R;
}


CVector4 CVector4::operator * ( float scalar ) {
   CVector4 R;

   Vector4Multiply(R.tab, this->tab, scalar);
   
   return R;
}


CVector4 CVector4::operator / ( float scalar ) {
  CVector4 R;

  Vector4Divide(R.tab, this->tab, scalar);

  return R;
}


CVector4 CVector4::operator * ( CVector4 &V ) {
   CVector4 R;

   VecVec4Multiply(R.tab, this->tab, V.tab);

   return R;
}


CVector4 operator * ( float scalar, const CVector4 &V ) {
   CVector4 R;

   Vector4Multiply(R.tab, V.tab, scalar);

   return R;
}



CMatrix3 CMatrix4::GetUpper3x3()
{
    CMatrix3 mat3;
    mat3.M[_M11] = M[_MM11];
    mat3.M[_M12] = M[_MM12];
    mat3.M[_M13] = M[_MM13];

    mat3.M[_M21] = M[_MM21];
    mat3.M[_M22] = M[_MM22];
    mat3.M[_M23] = M[_MM23];

    mat3.M[_M31] = M[_MM31];
    mat3.M[_M32] = M[_MM32];
    mat3.M[_M33] = M[_MM33];
    return mat3;
}


CVector4 operator * (CVector4 &V, CMatrix4 &M ) {
   // For row vectors:
   CVector4 R;

   R.x = M._11 * V.x + M._21 * V.y + M._31 * V.z + M._41 * V.w;
   R.y = M._12 * V.x + M._22 * V.y + M._32 * V.z + M._42 * V.w;
   R.z = M._13 * V.x + M._23 * V.y + M._33 * V.z + M._43 * V.w;
   R.w = M._14 * V.x + M._24 * V.y + M._34 * V.z + M._44 * V.w;

   return R;
}

CMatrix3 CMatrix3::operator  +  ( CMatrix3 &Mat ) 
{
   CMatrix3 R;
  
   Vector3Add(&R._11, &this->_11, &Mat._11);
   Vector3Add(&R._21, &this->_21, &Mat._21);
   Vector3Add(&R._31, &this->_31, &Mat._31);
      
   return *this;
}

CMatrix3 &CMatrix3::operator += ( CMatrix3 &Mat ) 
{
   Vector3Add(&this->_11, &this->_11, &Mat._11);
   Vector3Add(&this->_21, &this->_21, &Mat._21);
   Vector3Add(&this->_31, &this->_31, &Mat._31);
      
   return *this;
}

CMatrix3 CMatrix3::operator  -  ( CMatrix3 &Mat ) {
   CMatrix3 R;

   Vector3Subtract(&R._11, &this->_11, &Mat._11);
   Vector3Subtract(&R._21, &this->_21, &Mat._21);
   Vector3Subtract(&R._31, &this->_31, &Mat._31);
   
   return R;
}

CMatrix3 &CMatrix3::operator -= ( CMatrix3 &Mat ) 
{
   Vector3Subtract(&this->_11, &this->_11, &Mat._11);
   Vector3Subtract(&this->_21, &this->_21, &Mat._21);
   Vector3Subtract(&this->_31, &this->_31, &Mat._31);
      
   return *this;
}

CMatrix3 CMatrix3::operator  *  ( CMatrix3 &Mat ) 
{
   CMatrix3 R;

   MatMat3Multiply(R.M, this->M, Mat.M);
    
   return R;
}

CMatrix3 &CMatrix3::operator *= ( CMatrix3 &Mat ) {
   CMatrix3 R;

   MatMat3Multiply(R.M, this->M, Mat.M);

   ( *this ) = R;

   return *this;
}

CMatrix3 CMatrix3::operator * ( float scalar ) 
{
   CMatrix3 R;

   Vector3Multiply(&R._11, &this->_11, scalar);
   Vector3Multiply(&R._21, &this->_21, scalar);
   Vector3Multiply(&R._31, &this->_31, scalar);
         
   return R;
}

CMatrix3 &CMatrix3::operator *= ( float scalar ) 
{   
   Vector3Multiply(&this->_11, &this->_11, scalar);
   Vector3Multiply(&this->_21, &this->_21, scalar);
   Vector3Multiply(&this->_31, &this->_31, scalar);   

   return *this;
}

CMatrix3 CMatrix3::operator  /  ( float scalar ) 
{
   CMatrix3 R;

   Vector3Divide(&R._11, &this->_11, scalar);
   Vector3Divide(&R._21, &this->_21, scalar);
   Vector3Divide(&R._31, &this->_31, scalar);   
      
   return R;
}

CMatrix3 &CMatrix3::operator /= ( float scalar ) 
{
   Vector3Divide(&this->_11, &this->_11, scalar);
   Vector3Divide(&this->_21, &this->_21, scalar);
   Vector3Divide(&this->_31, &this->_31, scalar);         

   return *this;
}

CVector3 CMatrix3::operator * ( CVector3 &V ) {
   // For column vectors:
   CVector3 R;
   
   R.x = _11 * V.x + _12 * V.y + _13 * V.z;
   R.y = _21 * V.x + _22 * V.y + _23 * V.z;
   R.z = _31 * V.x + _32 * V.y + _33 * V.z;

   return R;
}

CMatrix3 *CMatrix3::Transpose () 
{
   Matrix3Transpose(this->M);
   return this;
}

CVector3 operator * ( CVector3 &V, CMatrix3 &M ) 
{
   // For row vectors:
   CVector3 R;
   
   R.x = M._11 * V.x + M._21 * V.y + M._31 * V.z;
   R.y = M._12 * V.x + M._22 * V.y + M._32 * V.z;
   R.z = M._13 * V.x + M._23 * V.y + M._33 * V.z;

   return R;
}

CMatrix4 CMatrix4::operator  +  ( CMatrix4 &Mat ) {
   CMatrix4 R;

   Vector4Add(&R._11, &this->_11, &Mat._11);
   Vector4Add(&R._21, &this->_21, &Mat._21);
   Vector4Add(&R._31, &this->_31, &Mat._31);
   Vector4Add(&R._41, &this->_41, &Mat._41);
   
   return R;
}

CMatrix4 &CMatrix4::operator += ( CMatrix4 &Mat ) {
  Vector4Add(&this->_11, &this->_11, &Mat._11);
  Vector4Add(&this->_21, &this->_21, &Mat._21);
  Vector4Add(&this->_31, &this->_31, &Mat._31);
  Vector4Add(&this->_41, &this->_41, &Mat._41);
  return *this;
}

CMatrix4 CMatrix4::operator  - ( CMatrix4 &Mat ) {
   CMatrix4 R;

   Vector4Subtract(&R._11, &this->_11, &Mat._11);
   Vector4Subtract(&R._21, &this->_21, &Mat._21);
   Vector4Subtract(&R._31, &this->_31, &Mat._31);
   Vector4Subtract(&R._41, &this->_41, &Mat._41);
   
   return R;
}

CMatrix4 &CMatrix4::operator -= ( CMatrix4 &Mat ) 
{   
   Vector4Subtract(&this->_11, &this->_11, &Mat._11);
   Vector4Subtract(&this->_21, &this->_21, &Mat._21);
   Vector4Subtract(&this->_31, &this->_31, &Mat._31);
   Vector4Subtract(&this->_41, &this->_41, &Mat._41);
   return *this;
}

CMatrix4 CMatrix4::operator * ( CMatrix4 &Mat ) {
  CMatrix4 R;

  MatMat4Multiply(R.M, this->M, Mat.M);

  return R;
}

CMatrix4 &CMatrix4::operator *= ( CMatrix4 &Mat ) {
   CMatrix4 R;

   MatMat4Multiply(R.M, this->M, Mat.M);
   
   ( *this ) = R;

   return *this;
}

CMatrix4 CMatrix4::operator * ( float scalar ) 
{
   CMatrix4 R;

   Vector4Multiply(&R._11, &this->_11, scalar);
   Vector4Multiply(&R._21, &this->_21, scalar);
   Vector4Multiply(&R._31, &this->_31, scalar);
   Vector4Multiply(&R._41, &this->_41, scalar);
      
   return R;
}

CMatrix4 &CMatrix4::operator *= ( float scalar ) {   
   
   Vector4Multiply(&this->_11, &this->_11, scalar);
   Vector4Multiply(&this->_21, &this->_21, scalar);
   Vector4Multiply(&this->_31, &this->_31, scalar);
   Vector4Multiply(&this->_41, &this->_41, scalar);      

   return *this;
}

CMatrix4 CMatrix4::operator  /  ( float scalar ) {
   CMatrix4 R;

   float *M1, *R1;

   M1 =   &_11;
   R1 = &R._11;

   for ( int i = 0; i < 14; i++ ) {
      ( *R1++ ) = ( *M1++ ) / scalar;
   }

   return R;
}

CMatrix4 &CMatrix4::operator /= ( float scalar ) {
   float *M1;

   M1 = &_11;

   for ( int i = 0; i < 14; i++ ) {
      ( *M1++ ) /= scalar;
   }

   return *this;
}

CVector4 CMatrix4::operator * ( CVector4 &V ) {
    CVector4 R;
   
    R.x = _11 * V.x + _21 * V.y + _31 * V.z + _41 * V.w;
    R.y = _12 * V.x + _22 * V.y + _32 * V.z + _42 * V.w;
    R.z = _13 * V.x + _23 * V.y + _33 * V.z + _43 * V.w;
    R.w = _14 * V.x + _24 * V.y + _34 * V.z + _44 * V.w;

    return R;
}

CVector3 CMatrix4::operator * ( CVector3 &v ) {
    CVector3 R;
    R.x = v.x * _11 + v.y * _21 + v.z * _31 + _41;
    R.y = v.x * _12 + v.y * _22 + v.z * _32 + _42;
    R.z = v.x * _13 + v.y * _23 + v.z * _33 + _43;
	return R;
}

CMatrix4 *CMatrix4::Transpose () {   
   Matrix4Transpose(this->M);   
   return this;
}


CMatrix4 &CMatrix4::SetScale(float x,float y,float z)
{
    SetIdentity();
    _11 = x;
    _22 = y;
    _33 = z;
    return *this;
}

CMatrix4 &CMatrix4::SetTranslate(float x,float y,float z)
{
    SetIdentity();
    _41 = x;
  	_42 = y;
	  _43 = z;
    return *this;
}

/*
  \param rot rotacja dla poszczegolnych osi podana w radianach
*/
CMatrix4 CMatrix4::Transform(CVector3 &pos, CVector3 &rot, CVector3 &scale){

	CMatrix4 t0, t1, t2, s, temp;

	t0.SetIdentity();
	t1.SetIdentity();
	t2.SetIdentity();
	temp.SetIdentity();

	if(rot.x != 0.0f)
		t0.SetRotateX(rot.x);

	if(rot.y != 0.0f)
		t1.SetRotateY(rot.y);

	if(rot.z != 0.0f)
		t2.SetRotateZ(rot.z);

	temp = temp * t1;
	temp = temp * t0;
	temp = temp * t2;

	temp._41 = pos.x;
	temp._42 = pos.y;
	temp._43 = pos.z;

  s.SetIdentity();
  s._11 = scale.x;
  s._22 = scale.y;
  s._33 = scale.z;

  temp = temp * s;

	this->SetIdentity();
	*this = temp; 
	return *this;
}


void CMatrix4::SetRotateX(float fRads){
  SetIdentity();
	_22 =  (float)cos(fRads);
	_23 =  (float)sin(fRads);
	_32 = -(float)sin(fRads);
	_33 =  (float)cos(fRads);
}

void CMatrix4::SetRotateY(float fRads){
  SetIdentity();
	_11 =  (float)cos(fRads);
	_13 = -(float)sin(fRads);
	_31 =  (float)sin(fRads);
	_33 =  (float)cos(fRads);
}

void CMatrix4::SetRotateZ(float fRads){
  SetIdentity();
	_11  =  (float)cos(fRads);
	_12  =  (float)sin(fRads);
	_21  = -(float)sin(fRads);
	_22  =  (float)cos(fRads);
}
E:\Project\Kopia (5) VBEngine\Utility\vbmath.cpp
#ifndef __TOOLS
#define __TOOLS

#ifndef MAX
#define MAX(x, y) ((x) > (y) ? (x) : (y))
#endif

#ifndef MIN
#define MIN(x, y) ((x) > (y) ? (y) : (x))
#endif

#ifndef ABS
#define ABS(a) (((a) < 0) ? -(a) : (a))
#endif

#ifndef IABS
#if 0
inline int IABS(int a) { return (a &= 0x7FFFFFFF); }
#else
#define IABS(a)   ABS(a)
#endif
#endif


#ifndef FABS
#if 1
inline float FABS(float a)
{
  int tmp = *(int *)&a;
  tmp &= 0x7FFFFFFF;
  return *(float *)&tmp;
}
#else
#define FABS(a) ((a < 0) ? -(a) : (a))
#endif
#endif

#define SetFlag(Flags, f) (Flags |= f)
#define ClearFlag(Flags, f) (Flags &= ~f)
#define CheckFlag(Flags, f) ((Flags & f) == f)

int myrand(int range);
void randinit(void);

float GaussRand(float m , float k, float min, float max);
char * my_snprintf(char *string , size_t size, const char *fmt, ...);
char * cat_snprintf(char *string , size_t size, const char *fmt, ...);

#endif /* end of : __TOOLS */
E:\Project\Kopia (5) VBEngine\Utility\Tools.h
#include <stdio.h>
#include <string.h>
#include <stdarg.h>

#include "Tools.h"
#include <math.h>
//#define WIN32

#ifdef WIN32
#define my_vsnprintf       _vsnprintf
#else
#define my_vsnprintf       vsnprintf
#endif

char * my_snprintf(char *string , size_t size, const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	my_vsnprintf(string, size, fmt, args);
	va_end(args);
	return string;
}

char * cat_snprintf(char *string , size_t size, const char *fmt, ...)
{
  va_list args;
  size_t len = strlen(string);

  if(len + 1 >= size)
  {
    return string;
  }
	
	va_start(args, fmt);
	my_vsnprintf(string + len, size - len, fmt, args);
	va_end(args);

	return string;
}

/* ================================================================================= */

#define RANDSIZL   ( 8 )  /* I recommend 8 for crypto, 4 for simulations */
#define RANDSIZ    ( 1 << RANDSIZL )

typedef  unsigned long  ub8;
#define UB8MAXVAL 0xffffffffffffffffLL
#define UB8BITS 64
typedef    signed long  sb8;
#define SB8MAXVAL 0x7fffffffffffffffLL
typedef  unsigned long  int  ub4;   /* unsigned 4-byte quantities */
#define UB4MAXVAL 0xffffffff
typedef    signed long  int  sb4;
#define UB4BITS 32
#define SB4MAXVAL 0x7fffffff
typedef  unsigned short int  ub2;
#define UB2MAXVAL 0xffff
#define UB2BITS 16
typedef    signed short int  sb2;
#define SB2MAXVAL 0x7fff
typedef  unsigned       char ub1;
#define UB1MAXVAL 0xff
#define UB1BITS 8
typedef    signed       char sb1;   /* signed 1-byte quantities */
#define SB1MAXVAL 0x7f
typedef                 int  word;  /* fastest type available */

#define bis(target,mask)  ((target) |=  (mask))
#define bic(target,mask)  ((target) &= ~(mask))
#define bit(target,mask)  ((target) &   (mask))


#ifndef align
# define align(a) (((ub4)a+(sizeof(void *)-1))&(~(sizeof(void *)-1)))
#endif /* align */

/* context of random number generator */
struct randctx
{
  ub4 randcnt;
  ub4 randrsl[RANDSIZ];
  ub4 randmem[RANDSIZ];
  ub4 randa;
  ub4 randb;
  ub4 randc;
};

static struct randctx CTX;

#define ind(mm,x)  (*(ub4 *)((ub1 *)(mm) + ((x) & ((RANDSIZ-1)<<2))))
#define rngstep(mix,a,b,mm,m,m2,r,x) \
{ \
  x = *m;  \
  a = (a^(mix)) + *(m2++); \
  *(m++) = y = ind(mm,x) + a + b; \
  *(r++) = b = ind(mm,y>>RANDSIZL) + x; \
}

static void isaac( struct randctx *ctx )
{
   register ub4 a,b,x,y,*m,*mm,*m2,*r,*mend;
   mm=ctx->randmem; r=ctx->randrsl;
   a = ctx->randa; b = ctx->randb + (++ctx->randc);
   for (m = mm, mend = m2 = m+(RANDSIZ/2); m<mend; )
   {
      rngstep( a<<13, a, b, mm, m, m2, r, x);
      rngstep( a>>6 , a, b, mm, m, m2, r, x);
      rngstep( a<<2 , a, b, mm, m, m2, r, x);
      rngstep( a>>16, a, b, mm, m, m2, r, x);
   }
   for (m2 = mm; m2<mend; )
   {
      rngstep( a<<13, a, b, mm, m, m2, r, x);
      rngstep( a>>6 , a, b, mm, m, m2, r, x);
      rngstep( a<<2 , a, b, mm, m, m2, r, x);
      rngstep( a>>16, a, b, mm, m, m2, r, x);
   }
   ctx->randb = b; ctx->randa = a;
}


#define mix(a,b,c,d,e,f,g,h) \
{ \
   a^=b<<11; d+=a; b+=c; \
   b^=c>>2;  e+=b; c+=d; \
   c^=d<<8;  f+=c; d+=e; \
   d^=e>>16; g+=d; e+=f; \
   e^=f<<10; h+=e; f+=g; \
   f^=g>>4;  a+=f; g+=h; \
   g^=h<<8;  b+=g; h+=a; \
   h^=a>>9;  c+=h; a+=b; \
}

/* if (flag==TRUE), then use the contents of randrsl[] to initialize mm[]. */
void randinit()
{
   word i;
   ub4 a,b,c,d,e,f,g,h;
   ub4 *m,*r;
   CTX.randa = CTX.randb = CTX.randc = 0;
   m=CTX.randmem;
   r=CTX.randrsl;
   a=b=c=d=e=f=g=h=0x9e3779b9;  /* the golden ratio */

   for (i=0; i<4; ++i)          /* scramble it */
   {
     mix(a,b,c,d,e,f,g,h);
   }
   
     /* initialize using the contents of r[] as the seed */
     for (i=0; i<RANDSIZ; i+=8)
     {
       a+=r[i  ]; b+=r[i+1]; c+=r[i+2]; d+=r[i+3];
       e+=r[i+4]; f+=r[i+5]; g+=r[i+6]; h+=r[i+7];
       mix(a,b,c,d,e,f,g,h);
       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;
       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;
     }
     /* do a second pass to make all of the seed affect all of m */
     for (i=0; i<RANDSIZ; i+=8)
     {
       a+=m[i  ]; b+=m[i+1]; c+=m[i+2]; d+=m[i+3];
       e+=m[i+4]; f+=m[i+5]; g+=m[i+6]; h+=m[i+7];
       mix(a,b,c,d,e,f,g,h);
       m[i  ]=a; m[i+1]=b; m[i+2]=c; m[i+3]=d;
       m[i+4]=e; m[i+5]=f; m[i+6]=g; m[i+7]=h;
     }
   
   for( i = 0; i < 1024; i++ )
   {
     isaac(&CTX);            /* fill in the first set of results */
   }
   CTX.randcnt=RANDSIZ;  /* prepare to use the first set of results */

}

/*
 * MAXVal > 0 -> return  <0...MAXVal>
 * MAXVal < 0 -> return  <-MAXVal...0>
 */
int myrand(int MaxVal )
{
  static int i = 0;
  int IsaacVal;
  int ret;

  if( MaxVal > 0 )
  {
    MaxVal++;
  }
  else
  {
    MaxVal--;
  }

  IsaacVal = CTX.randrsl[ i ];
  ret = ( IsaacVal % MaxVal );

  if( i > RANDSIZ )
  {
    isaac( &CTX );
    i = 0;
  }
  else
  {
    i++;
  }

  if( ( ( MaxVal > 0 ) && ( ret < 0 ) ) || 
      ( ( MaxVal < 0 ) && ( ret > 0 ) )
    )
  {
    ret = -ret;  
  }

  return ret;
}

#define SQRT2PI 2.50662827463f
float GaussRand(float m, float k, float min, float max)
{
  float retval;
  float randval = (float)myrand(1000);
  
  randval/= 1000;
  float randX = (max - min) *randval;

  float sign;
  int val = myrand(1000) - 500;
  if (val <0)
  {
    sign = -1.0f;
  }
  else 
  {
    sign = 1.0f;
  }
  retval = sign * sqrtf( FABS(2 * k * k * logf(SQRT2PI * k * randX))) + m;


  if (retval < min) retval = min;
  else
  if(retval > max) retval = max;
  return retval;
}
E:\Project\Kopia (5) VBEngine\Utility\Tools.cpp
#ifndef _SINGLETON_H
#define _SINGLETON_H

/*
class       : Singleton
description : Podstawowy obiekt singletonowy

methods     : konstruktor   - ustawia statyczny obiekt
              dekonstruktor - zeruje statyczny obiekt
			  Instance()    - pobiera adres statycznego obiektu

*/

template<class C>
class Singleton
{
private:
	static C* Object;
public:
	Singleton()
	{
		assert((Object == NULL) && "Cannot instantiate a second singleton of the same class");
		Object = (C*)this;
	}
	~Singleton()
	{
		Object = NULL;
	}
	static C* Instance()
	{
		//DIE((Object != NULL) && "This Singleton Was not Created yet!");
		return Object;
	}
};

template<class C>  C* Singleton<C>::Object;

#endif /* _SINGLETON_H */
E:\Project\Kopia (5) VBEngine\Utility\Singleton.h


#ifdef DO_PROFILE
#include <assert.h>
#include "singleton.h"
#include "logger.h"
#include <windows.h>
#include <mmsystem.h>
#include <stdio.h>
#include "misc.h"

#define PROFILE(x) static int ProfileHandle##x = 0 ;\
if (ProfileHandle##x == 0) ProfileHandle##x = Profiler::Instance()->CreateNewHandle(#x);\
ProfileObject obj##x(ProfileHandle##x);
      
struct ProfHandle
{
  const char *name;
  int handle;
  unsigned int callcount;
  unsigned int calltime;
  int parentHandle;
  int level;
};

class Profiler :public Singleton<Profiler>
{
  ProfHandle *harray;
  unsigned int nextHandle;
  int CurrentHandle;
  int currentLevel;
  int startTime;
public:
  Profiler()
  {
    currentLevel = 0; 
    CurrentHandle = -1;
    nextHandle = 0;
    harray = new ProfHandle[300];
    startTime = timeGetTime();
  }
  ~Profiler()
  {
    Dump();
  }
  ProfHandle * RetrieveHandle(int h)
  {
    harray[h].parentHandle = CurrentHandle;
    CurrentHandle = h;
    harray[h].level = currentLevel++;
    return harray + h;
  }
  int CreateNewHandle(const char * name)
  {
   memset(harray+nextHandle,0, sizeof(ProfHandle));
   harray[nextHandle].name = name;
   return nextHandle++;
  }
  void EndHandle()
  {
    CurrentHandle = harray[CurrentHandle].parentHandle; 
    currentLevel--;
  }
  void Dump()
  {
    char temp[96];
    float total_time = (float)timeGetTime() - (float) startTime;
    memset(temp,' ',96);
    //FILE *dumpfile;
    //dumpfile = fopen("profiler.out","w");
    LogError("Profiler Output start:\n");
    for (unsigned int i =0 ; i <nextHandle ; i++)
    {
      float percentage;
      ProfHandle &h =harray[i];
      if (h.parentHandle == -1)
      {
        percentage = 100.0f *(float) h.calltime /total_time;
      }
      else
      {
        percentage = 100.0f *(float) h.calltime / (float) harray[h.parentHandle].calltime;
      }
      temp[h.level] = 0; 
      LogError("%sSample: %s took: %ims to complete %i cycles, avg = %g, percentage of parent: %g\n",temp,h.name,h.calltime,h.callcount,(float) h.calltime/(float) h.callcount, percentage);
      temp[h.level] = ' ';
    }
    LogError("Profiler Output end\n");
    //fclose(dumpfile);
  }
};


class ProfileObject
{
  ProfHandle *handle;
  unsigned int starttime;
public:
  ProfileObject(int h)
  {
    handle = Profiler::Instance()->RetrieveHandle(h);
    starttime = timeGetTime();
  }
  ~ProfileObject()
  {
    handle->callcount++;
    handle->calltime += timeGetTime() - starttime;
    Profiler::Instance()->EndHandle(); 
  }
};

#define PROFILE_INIT() new Profiler;
#define PROFILE_DEINIT() delete Profiler::Instance();

#else

#define PROFILE(x) 
#define PROFILE_INIT()
#define PROFILE_DEINIT()
#endif
E:\Project\Kopia (5) VBEngine\Utility\profile.h

#define DO_PROFILE
#include "Defines.h"
#include "profile.h"
E:\Project\Kopia (5) VBEngine\Utility\profile.cpp
#ifndef _PARABOLA_H
#define _PARABOLA_H

#include "vbmath.h"
/*
class       : Parabola 
description : klasa pomocnicza odpowiadajaca za obliczanie parabol;

methods     :

*/



class Parabola
{
  CVector3 mStartPosition, mTargetPosition, mSpeed;
  float mAlfa, mGamma, mFlightDuration; 
public:
   Parabola(CVector3 *start_point, float speed, float alfa, float gamma); 
   Parabola(CVector3 *start_point,CVector3 *end_point, float speed, float alphamin = 0, float alphamax = PI/2);
   void  GetPointByTime(float DeltaT,CVector3 *result);
   float GetPointByZ   (float z,CVector3 *result);
};

#endif
E:\Project\Kopia (5) VBEngine\Utility\Parabola.h
#include <windows.h>
#include "Parabola.h"

#define GRAVITY 9.81f

Parabola::Parabola(CVector3 *start_point, float speed, float alfa, float gamma)
{
  mStartPosition = *start_point;
  float Vx , Vy , Vz , Vxy;
  Vz  = speed * sinf (alfa);
  Vxy = speed * cosf (alfa);
  Vx  = Vxy   * sinf (gamma);
  Vy  = Vxy   * cosf (gamma);
  mSpeed = CVector3(Vx,Vy,Vz);
  float VzPrzezG =  Vz / GRAVITY;

  mFlightDuration  = VzPrzezG + sqrtf (VzPrzezG * VzPrzezG + (2/GRAVITY) * start_point->z);
  mTargetPosition = CVector3(Vx * mFlightDuration , Vy * mFlightDuration , 0.0f );

}
Parabola::Parabola(CVector3 *start_point,CVector3 *end_point, float speed, float alphamin, float alphamax)
{

  float deltax, deltay, deltaz;
	deltax = end_point->x - start_point->x;
	deltay = end_point->y - start_point->y;
	// byl blad delta z powinna dla dalszych wzorow wychodzic dodatnia
	deltaz = start_point->z - end_point->z;
	
	float DoceloweAlfa;
	float DeltaZmin, DeltaZmax;
	float R = sqrtf(deltax *deltax + deltay * deltay);
	float RsqPrzezVsq = (GRAVITY / 2) * R * R / (speed * speed);
	float dDeltaZmax,dDeltaZmin;
  
	bool FoundAlfa = false;
  // jezeli kat maksymalny kat wiekszy od  45 stopni sprawdzic czy predkosc
  // wystarczy dla dolecenia - jezeli nie ustawic kat na 45 stopni i predkosc na idealna
  // dla 45 stopni
	

  if (alphamax > PI / 4) 
  {
	 float minPredkoscDla45Sq  = GRAVITY * R *  R/(deltaz + R);
     if (speed * speed < minPredkoscDla45Sq ) //czy predkosc jest wyzsza od tej dla 45 stopni?
     {
       speed = sqrtf(minPredkoscDla45Sq);
       DoceloweAlfa = PI / 4;
       FoundAlfa = true;
     }
  } 
  else     //jezeli kat maksymalny mniejszy od 45 stopni sprawdzic czy przy najwyzszym doleci
  {
    float tg = tanf(alphamax);
	  float cosSq = cosf(alphamax);
    cosSq *= cosSq;
	  float minPredkoscDlaAlfaMaxSq =(GRAVITY/2) * R *  R/((deltaz + R*tg)*cosSq);
    if (speed * speed < minPredkoscDlaAlfaMaxSq)
    {
      speed = sqrtf(minPredkoscDlaAlfaMaxSq);
      FoundAlfa = true;
      DoceloweAlfa = alphamax;
    }
  }
  // znajdowanie kata do celu miedzy wartosciami granicznymi
  // metoda polowienia kata
  while (!FoundAlfa)
	{
		//dla dolnej wartosci alfa
		float salpha = sinf(alphamin);
		salpha *= salpha;
		DeltaZmin = (R/2 * sinf(2*alphamin) - RsqPrzezVsq)/ salpha;
		//dla gornej wartosci alfa	
		salpha = sinf(alphamax);
		salpha *= salpha;
		DeltaZmax = (R/2 * sinf(2*alphamax) - RsqPrzezVsq)/ salpha;
		dDeltaZmin = abs (DeltaZmin - deltaz);
		dDeltaZmax = abs (DeltaZmax - deltaz);
		if (dDeltaZmax > dDeltaZmin)
		{
  	  if (dDeltaZmin	< EPSILON)
			{
			  DoceloweAlfa = alphamin; 
        FoundAlfa = true;
			}
      else
			{
			  alphamax = (alphamax + alphamin)/2;
      }
		} 
		else
		{
		  if (dDeltaZmax	< EPSILON)
		  {
			  DoceloweAlfa = alphamax; 
        FoundAlfa = true;
		  }
      else
	 	  {
		    alphamin = (alphamax + alphamin)/2;
			}
	  }
	}
 
  float Vz, Vxy, Vx, Vy;
  Vz  = speed * sinf (DoceloweAlfa);
  Vxy = speed * cosf (DoceloweAlfa);
  mFlightDuration = R / Vxy;
  Vx = deltax / mFlightDuration;
  Vy = deltay / mFlightDuration;
  mSpeed = CVector3(Vx,Vy,Vz);


  mGamma = asinf(Vx/Vxy);
  mAlfa = DoceloweAlfa; 
}

void Parabola::GetPointByTime(float DeltaT,CVector3 *result)
{
  *result     = mSpeed * DeltaT;
  result->z -= (GRAVITY/2) * DeltaT * DeltaT;
}

float Parabola::GetPointByZ(float z, CVector3 * result)
{
  float VzPrzezG = mSpeed.z/GRAVITY;
  float deltaZ = mStartPosition.z - z;
  float deltaT = VzPrzezG + sqrtf(VzPrzezG * VzPrzezG + (2/GRAVITY) *deltaZ);
  if( result != NULL )
  {
	  result->x = mSpeed.x * deltaT + mStartPosition.x;
	  result->y = mSpeed.y * deltaT + mStartPosition.y;
    result->z = z;
  }
  return deltaT;
}
E:\Project\Kopia (5) VBEngine\Utility\parabola.cpp
#ifndef __MISC_H
#define __MISC_H

#include <stdlib.h>

// SC = SelfCleaning - fifo z autokasowaniem kontenerów
template<class item_class>
class SCItemNode
{
	SCItemNode *next;
	item_class* item;
public:
	SCItemNode(item_class *i) :next(NULL),item(i) {}
	item_class* GetItem(SCItemNode **pnext = NULL)
	{
		item_class * tempitem;
		tempitem = item;
		if(pnext) *pnext = next;
		delete this;
		return tempitem;
	}
	SCItemNode *Attach(SCItemNode *link)
	{
		next = link;
		return link;
	}
};


template<class list_item> 
class SCItemList
{
	typedef SCItemNode<list_item> ListNode;
	ListNode *root,*last;
public:
	SCItemList() : root(NULL),last(NULL){}
	~SCItemList() // delete any dangling items
	{
		while(root)
			delete root->GetItem(&root);
	}
	list_item *Get()
	{
		return root ? root->GetItem(&root) : NULL;
	}
	void Attach(list_item *item)
	{
		if(!root)
			root = last =new ListNode(item);
		else
			last = last->Attach(new ListNode(item));
	}
};



template<class item_class>
class SCStackNode
{
	SCStackNode *next;
	item_class* item;
public:
	SCStackNode(item_class *i) :next(NULL),item(i) {}
	item_class* GetItem(SCStackNode **pnext = NULL)
	{
		item_class * tempitem;
		tempitem = item;
		if(pnext) *pnext = next;
		delete this;
		return tempitem;
	}
	SCStackNode *Attach(SCStackNode *link)
	{
		link->next = this;
		return link;
	}
};

template<class list_item> 
class SCStack
{
	typedef SCStackNode<list_item> StackNode;
	StackNode *root;
public:
	SCStack() : root(NULL){}
	~SCStack() // delete any dangling items
	{
		while(root)
			delete root->GetItem(&root);
	}

	list_item *Get()
	{
		return root ? root->GetItem(&root) : NULL;
	}
	void Attach(list_item *item)
	{
		if(!root)
			root = new StackNode(item);
		else
			root = root->Attach(new StackNode(item));
	}

};


template<typename list_item>
class ItemNode
{
    ItemNode *mPrev,*mNext;
    list_item *Object;

public:
    ItemNode(list_item *object) : Object(object),
                                  mPrev(NULL),
                                  mNext(NULL) {}
    
    list_item *GetItem(ItemNode **next)
    {
        *next = mNext;
        return Object;
    }
    ItemNode *GetNext()
    {
        return mNext;
    }
    ItemNode *GetPrev()
    {
        return mPrev;
    }
    ItemNode *Attach(ItemNode *node)
    {
      if (node)
      {
        node->mNext = mNext;
        node->mPrev = this;
      }
      if(mNext)
      {
        mNext->mPrev = node;
      }
      mNext = node;
      return mNext;
    }
    ItemNode * AttachPrev(ItemNode *node)
    {
      if (node)
      {
        node->mPrev = mPrev;
        node->mNext = this;
      }
      if(mPrev)
      {
        mPrev->mNext = node;
      }
      mPrev = node;
      return mPrev;
    }
    void Remove(void)
    {
      if(mPrev)
      {
        mPrev->mNext = mNext;
      }
      if(mNext)
      {
        mNext->mPrev = mPrev;
      }
      delete this;
    }
};


template<typename list_item>
class ItemList
{
	typedef ItemNode<list_item> ListNode;
	ListNode *root,*last, *current;
  SCStack<ListNode> mStack;
public:
	ItemList() : root(NULL),last(NULL), current(NULL){}
	~ItemList() // delete any dangling items
	{
		ListNode *temp,*temp2;
        temp = root;
        while (temp)
        {
            temp2 = temp->GetNext();
            delete temp;
            temp = temp2;
        }
	}

	list_item *Get()
	{
    return current ? current->GetItem(&current) : NULL;
	}
	void Attach(list_item *item)
	{
		if(!root)
    {
			current = root = last =new ListNode(item);
    }
		else
    {
			last = last->Attach(new ListNode(item));
    }
	}
    void Remove(list_item *item)
    {
        ListNode *temp = root,*temp2;
        while (temp && temp->GetItem(&temp2) != item)
        { 
          temp = temp2;
        }
        if (temp)
        {
            if (temp == last)
                last = temp->GetPrev();
            if (temp == root)
                root = temp->GetNext();
            temp->Remove();
        }
        Reset();
    }
    void Reset()
    {
      current = root;
    }
    bool IsEmpty()
    {
      return (root == NULL);
    }
    void Push()
    {
      mStack.Attach(current);
      current = root;
    }
    void Pop()
    {
      current = mStack.Get();
    }
};


#endif 
E:\Project\Kopia (5) VBEngine\Utility\Misc.h
#ifndef _LOGGER_H
#define _LOGGER_H

#include <stdio.h>
#include <stdarg.h>
#include "Singleton.h"

/*
class       :
description :

methods     :

*/
enum eLogLevel
{
    LL_CRITICAL,
    LL_ERROR,
    LL_WARNING,
    LL_MESSAGE
};



class Logger :public Singleton<Logger>
{
    FILE *mLogFile;
    eLogLevel mLogLevel;
    bool mToConsole;
public:
    Logger(eLogLevel level, bool to_console = true , char * filename = NULL);
    ~Logger();
    void Log(eLogLevel level,const char *format, va_list args);
    void LogToScreen(const char *str);
};

inline void LogCritical(const char *format, ...)
{
 va_list args;
 va_start(args,format);
 Logger::Instance()->Log(LL_CRITICAL,format,args);
 va_end(args);
}

inline void LogError(const char *format, ...)
{
 va_list args;
 va_start(args,format);
 Logger::Instance()->Log(LL_ERROR,format,args);
 va_end(args);
}

inline void LogWarning(const char *format, ...)
{
 va_list args;
 va_start(args,format);
 Logger::Instance()->Log(LL_WARNING,format,args);
 va_end(args);
}

inline void LogMessage(const char *format, ...)
{
 va_list args;
 va_start(args,format);
 Logger::Instance()->Log(LL_MESSAGE,format,args);
 va_end(args);
}

#ifdef  DIEASASSERT
#ifdef  NDEBUG
#define DIE( condition )
#else
#define DIE( condition )                                          \
  if(!(condition))                                                \
  {                                                               \
    LogCritical("%s , %s, %d", #condition , __FILE__ ,__LINE__ ); \
    abort();                                                      \
  }
#endif
#else
#define DIE( condition )                                          \
  if(!(condition))                                                \
  {                                                               \
    LogCritical("%s , %s, %d", #condition , __FILE__ ,__LINE__ ); \
  }
#endif

#endif
E:\Project\Kopia (5) VBEngine\Utility\logger.h
#include "..\config.h"

#include <assert.h>

#include "logger.h"
#include <d3dx9effect.h>
#include "..\graphics\renderer.h"



Logger::Logger(eLogLevel level, bool to_console, char *filename)
{
   if( filename)
   {
       mLogFile = fopen(filename, "wt");
       if ( mLogFile )
        fputs("Logging Started\n",mLogFile);
   }
   else
       mLogFile = NULL;
   mLogLevel = level;
   mToConsole = to_console;
   if (to_console)
     puts("Logging Started\n");
}

Logger::~Logger()
{
    if (mLogFile) 
        fclose(mLogFile);
}

void Logger::Log(eLogLevel level,const char *format, va_list args)
{
  if (level <= this->mLogLevel)
  {
    if(mLogFile)
    {
       vfprintf(mLogFile,format,args);
       fprintf(mLogFile,"\n");
       fflush(mLogFile);
    }
    if(mToConsole)
    {
       vprintf(format,args);
       printf("\n");
    }
  }
}

void Logger::LogToScreen(const char *str)
{
#ifdef DEBUG
  Renderer::Instance()->AddText(str);
#endif 
}
E:\Project\Kopia (5) VBEngine\Utility\logger.cpp
#ifndef _EVENTMANAGER_H
#define _EVENTMANAGER_H

/*
class       : EventManager
description : Router przekazujacy wiadomosci do obiektow

methods     : RegisterListener   - rejestruje obiekt nasluchujacy wiadomosci
              UnregisterListener - wyrejestrowuje obiekt nasluchujacy zwraca true jak jest to
                                 - ostatni obiekt na liscie
              PostEvent          - umimeszcza otrzymana wiadomosc na kolejce wiadomosci gracza

*/

class EventHandler;
class Event;
typedef ItemList<EventHandler> EventHandlerList;

// wymaga zadeklarowanej zmiennej qEvent
//  : Event qEvent;
#define POST_EVENT(_EVENT,_ID,_URGENT, _DATA)\
  do{\
  Event *_Event = new Event(); \
  _Event->mMask = _EVENT;\
  _Event->mID = _ID;\
  _Event->mID2 = 0; \
  _Event->mUrgent= _URGENT;\
  _Event->mData = (void *)_DATA; \
  _Event->mTime = NOW;\
  EventManager::Instance()->PostEvent(_Event);\
  _Event->Release(); \
  }while(0)

#define POST_EVENT3(_EVENT,_ID,_TIME, _DATA)\
  do{\
  Event *_Event = new Event(); \
  _Event->mMask = _EVENT;\
  _Event->mID = _ID;\
  _Event->mID2 = 0; \
  _Event->mUrgent= false;\
  _Event->mData = (void *)_DATA; \
  _Event->mTime = _TIME;\
  EventManager::Instance()->PostEvent(_Event);\
  _Event->Release(); \
  }while(0)

#define POST_EVENT2(_EVENT,_ID, _ID2, _URGENT, _DATA)\
  do{\
  Event *_Event = new Event(); \
  _Event->mMask = _EVENT;\
  _Event->mID = _ID;\
  _Event->mID2 = _ID2; \
  _Event->mUrgent= _URGENT;\
  _Event->mData = (void *)_DATA; \
  _Event->mTime = NOW;\
  EventManager::Instance()->PostEvent(_Event);\
  _Event->Release(); \
  }while(0)

class EventManager :public Singleton<EventManager>
{
   EventHandlerList mHandlerList;
public:
    void RegisterListener  (EventHandler *handler) {mHandlerList.Attach(handler);}
    bool UnregisterListener(EventHandler *handler);
    void PostEvent(Event *event);
    void Loop();

};

#endif
E:\Project\Kopia (5) VBEngine\Utility\EventManager.h
#include "..\config.h"

#include <assert.h>

#include "Misc.h"
#include "Singleton.h"
#include "defines.h"
#include "Ctime.h"
#include "Logger.h"
#include "Event.h"

#include "EventManager.h"
#include "EventHandler.h"

// dodawanie nowego eventa
void EventManager::PostEvent(Event *event)
{
   mHandlerList.Push(); // liste handlerów zapisz
   EventHandler *handler; 
   while (( handler = mHandlerList.Get() )) // dopóki jeszcze jakiœ jest
   {
       if ( handler->TestEvent(event) ) // je¿eli temu sie nale¿y 
           if( event->mUrgent ) // i jest pilna
           {
               handler->ProcessEvent(event); // to przetwórz od razu
           }
           else // w innym wypadku wrzuæ w kolejke
               handler->PostEvent(event->Clone());
   }
   mHandlerList.Pop();  // po skoñczonej pracy przywróæ wczeœniejsz¹ wartoœæ listy
}
// znajduje i usuwa handlera na liœcie,
// jeœli lista jest pusta zwraca true
bool EventManager::UnregisterListener(EventHandler *handler)
{
  mHandlerList.Remove(handler);
  if (mHandlerList.IsEmpty()) return true;
  return false;
}
// przechodzi po wszystkich handlerach i sprawdza czy eventy s¹ do przetworzenia
void EventManager::Loop()
{
  EventHandler *handler;
  while (( handler = mHandlerList.Get() ))
  {
    handler->Loop();
  }
  mHandlerList.Reset();
}
E:\Project\Kopia (5) VBEngine\Utility\EventManager.cpp
#ifndef _EVENTHANDLER_H
#define _EVENTHANDLER_H

/*
class       : EventHandler
description : Podstawowa klasa dla obiektow otrzymujacych wiadomosci

methods     : konstruktor  - rejestruje obiekt w EventManager tworzac go jesli nie jest 
                             utworzony
              destruktor   - wyrejestrowuje obiekt z EventManagera 
              TestEvent    - sprawdzenie czy dany obiekt nas³uchuje tych eventów
              ProcessEvent - wirtualna funkcja przetwarzaj¹ca wiadomoœci w pêtli Loop()
			                       dodatkowo wywo³ywana przy priorytetowych wiadomosciach bezposrednio
			        PostEvent    - dodaje event do wewnêtrznej listy, odpytywanej przez Loop
			        Loop         - wywolywana dla kazdego obiektu co "klatke" przesyla eventy z listy
			                       do ProcessEvent
*/





class EventHandler
{
  unsigned int  mListenMask;
	EventList mEventList;
public:
	EventHandler(unsigned int listen_mask) : mListenMask(listen_mask)
	{ // jeœli jeszcze nikt event managera nie stworzy³ - to stwórz
    if (EventManager::Instance() == NULL) new EventManager;
    // i w ka¿dym razie sie zarejestruj
		EventManager::Instance()->RegisterListener(this);
	}
    ~EventHandler()
	{
    // je¿eli jesteœ ostatnim
		if(EventManager::Instance()->UnregisterListener(this))
      // to zgaœ œwiat³o
      delete EventManager::Instance();
	}
	bool TestEvent(Event *event);
	// dodaj nowego eventa do kolejki
	void PostEvent(Event *event) { mEventList.Attach(event); }
	
  void Loop();

	virtual void ProcessEvent(Event *event) = 0;

  // dodaj, usuñ i sprawdŸ maske 
  void AddMask(unsigned int mask) {mListenMask |= mask;}
  void RemoveMask(unsigned int mask) {mListenMask &= ~mask;}
  bool TestMask(unsigned int mask) { return ((mListenMask & mask) != 0);}
};

#endif
E:\Project\Kopia (5) VBEngine\Utility\EventHandler.h
#include "..\config.h"

#include <assert.h>

#include "Misc.h"
#include "Singleton.h"
#include "Logger.h"
#include "Ctime.h"
#include "defines.h"

#include "Event.h"
#include "EventManager.h"
#include "EventHandler.h"


// pêtla pobieraj¹ca z kolejki eventy do obecnego czasu
// i wysy³aj¹ca do funkcji process event tego obiektu
void EventHandler::Loop()
{
  Event *temp;
  float CurrentTime = CTime::Instance()->GetTime();
  while(( temp = mEventList.Get(CurrentTime) ))
  {
    ProcessEvent(temp);
    temp->Release();
  }
}
// sprawdza czy dany event sie nam nalezy czy nie
bool EventHandler::TestEvent(Event *event) 
{
  return ((mListenMask & event->mMask) != 0);
}
E:\Project\Kopia (5) VBEngine\Utility\EventHandler.cpp
#ifndef _EVENT_H
#define _EVENT_H

#define BIT(i) (1<<i)

enum EventType
{
  ET_GLOBAL          = BIT(0),
  ET_USER_1_INPUT    = BIT(1),
  ET_USER_2_INPUT    = BIT(2),
  ET_USER_3_INPUT    = BIT(3),
  ET_USER_4_INPUT    = BIT(4),
  ET_USER_5_INPUT    = BIT(5),
  ET_USER_6_INPUT    = BIT(6),
  ET_USER_7_INPUT    = BIT(7),
  ET_USER_8_INPUT    = BIT(8),
  ET_USER_9_INPUT    = BIT(9),
  ET_USER_10_INPUT   = BIT(10),
  ET_USER_11_INPUT   = BIT(11),
  ET_USER_12_INPUT   = BIT(12),
  ET_BALL            = BIT(13),
  ET_SCENE           = BIT(14),
  ET_GAME            = BIT(15),
  ET_TEAM_0          = BIT(16),
  ET_TEAM_0_PLAYER   = BIT(17),
  ET_TEAM_0_SUB      = BIT(18),
  ET_TEAM_1          = BIT(19),
  ET_TEAM_1_PLAYER   = BIT(20),
  ET_TEAM_1_SUB      = BIT(21),
  ET_AUDIO           = BIT(22),
  ET_TACTIC          = BIT(23),
  ET_STADION         = BIT(24),
  ET_GUI             = BIT(25),
  ET_GUI_CONTROLS    = BIT(26),
  ET_GUI_FRIENDLY    = BIT(27),
  ET_GUI_WORLDLEAGUE = BIT(28),
  ET_GUI_EUROLEAGUE  = BIT(29),
  ET_GUI_STADIUM     = BIT(30)
};

#define ET_USER_MASK_SUM ( ET_USER_1_INPUT | ET_USER_2_INPUT | ET_USER_3_INPUT | ET_USER_4_INPUT | \
            ET_USER_5_INPUT | ET_USER_6_INPUT | ET_USER_7_INPUT | ET_USER_8_INPUT | ET_USER_9_INPUT | \
            ET_USER_10_INPUT | ET_USER_11_INPUT | ET_USER_12_INPUT )


enum GlobalEventID
{
    GEID_QUIT,
    GEID_END_GAME,
    GEID_NEW_GAME,
    GEID_FORCE_END_GAME
};


enum GameEvents
{
  GE_BALL_TARGET,
  GE_BALL_PASS_OVER,
  GE_BALL_PASS_UNDER_NET,
  GE_BALL_HIT_NET,
  GE_BALL_HIT_FLOOR,
  GE_BREAK_LIGHTS,
  GE_TEAM0_CHANGE_TACTIC,
  GE_TEAM1_CHANGE_TACTIC,
  GE_LAST_EVENT
};

enum TeamEvents
{
  TE_PRZEBICIE = GE_LAST_EVENT,
  TE_RESET_HITCOUNT,
  TE_SUCCESSFUL_BLOCK,
  TE_MAKE_BLOK,
  TE_MAKE_DECOY,
};

/*
class       : Event
description : struktura przechowujaca dane eventow (wiadomosci) przekazywanych przez engine

methods     : Clone - kopiowanie zawartosci do nowo utworzonej kopii

*/
class Event
{
  unsigned int ref_count;
  ~Event() {assert(this->ref_count == 0 && "Uzyj Release !!");};
public:
   Event() {this->mData = NULL; this->ref_count = 1;this->mUrgent = false;};
   unsigned int mMask;
   unsigned int mID;
   unsigned int mID2;
   void *mData;
   bool mUrgent;
   float mTime;
   
   Event *Clone() 
   {
     this->ref_count++;
	   return this;
   }
   void Release() 
   {
     if(!(--this->ref_count))
     {
       if(mData)
       {
         delete mData;
         mData = NULL;
       }
       delete this;
     }
   }

};
/*
class       : EventNode
description : struktura - kontener dla listy eventow
*/

class EventNode
{
public:
  EventNode *mNext;
  Event *mEvent;
  EventNode(Event * event) :mNext(NULL), mEvent(event) {}
};

/*
class       : EventList
description : lista - FIFO eventow bazowana na czasie dostarczenia

methods     : Attach - doczepia event do kolejki bazujac na czasie dostarczenia
              Get    - pobiera pierwszy event oczekujacy w kolejce jesli ma czas mniejszy od
                       czasu dostarczenia - przesuwa kolejke do przodu
*/
class EventList
{
  EventNode *mRoot;
public:
  EventList() :mRoot(NULL) {}
  void Attach(Event *event);
  Event *Get(float time);
};



#endif
E:\Project\Kopia (5) VBEngine\Utility\Event.h
#include "..\config.h"

#include <assert.h>

#include "..\utility\defines.h"

#include "Event.h"



// EventList::Attach(Event *event)
// funkcja wyszukuje pozycje na liscie w ktorej czas eventa jest wiekszy od czasu danego 
// eventa i dodaje go pozycje wczesniej
 
void EventList::Attach(Event *event)
{
  if (mRoot == NULL)
  {
    mRoot = new EventNode(event);
    return;
  }
  if (mRoot->mNext == NULL)
  {
    EventNode *temp = new EventNode(event);
    if (mRoot->mEvent->mTime > event->mTime)
    {
       temp->mNext = mRoot;
       mRoot = temp;
    }
    else
    {
       mRoot->mNext = temp;
    }
    return;
  }
  
  EventNode *temp = mRoot;
  // sprawdzenie czy doszlismy do konca kolejki, badz czy nastepna pozycja nie ma ustawionego
  // czasu pozniejszego niz czas dodawanego eventa
  
  while((temp->mNext != NULL ) && ( temp->mNext->mEvent->mTime < event->mTime ))
  {
    temp = temp->mNext;
  }
  
  // stworzyc nowy wezel
  EventNode *newEventNode = new EventNode(event);
  newEventNode->mNext = temp->mNext;
  temp->mNext = newEventNode;
}

// Event *EventList::Get(float time)
// zwraca event wczesniejszy od danego czasu z kolejki, albo NULL jesli kolejka jest pusta
// badz czas jest pozniejszy 
// czysci kontenery pozostale po pobraniu
Event *EventList::Get(float time)
{
  // nic nie ma na liscie
  if( mRoot == NULL ) return NULL;
  // czas pierwszego jest pozniejszy niz podany
  if( mRoot->mEvent->mTime > time) return NULL;
  EventNode *tempEventNode;
  Event     *tempEvent;
  // pobranie pierwszej z FIFO
  tempEventNode = mRoot;
  // usuniecie z kolejki
  mRoot = mRoot->mNext;
  // pobranie zawartosci wezla
  tempEvent = tempEventNode->mEvent;
  // skasowanie kontenera
  delete tempEventNode;
  // zwrocenie zawartosci
  return tempEvent;
}
E:\Project\Kopia (5) VBEngine\Utility\Event.cpp
#ifndef _DEFINES
#define _DEFINES

#define USE_HOPS

#define MAX_FILE_NAME 256
#define MAX_STRING_LENGTH 256

#ifndef MAX_PATH
#define MAX_PATH 512
#endif

#ifndef NULL
#define NULL 0
#endif

#define MAX_EVENT_DATA_SIZE 24

#define MAX_TEXTURES_IN_MATERIAL 2

#define USE_MATERIAL

#define MAX_TEAM 2
#define MAX_PLAYERS_IN_TEAM 12
#define MAX_PLAYERS_ON_FIELD 6

#define MAX_USERS 12
#define MAX_LOCAL_USERS 2
#define MAX_MAPPED_KEYS 7

#define VB_FAIL 1
#define VB_OK 0

#define MAX_IDLE_ANIMATIONS 5
#define MAX_SIT_ANIMATIONS 4

#define MAX_BLOCK_CHANCES 5

/*********** sciezki ***********/

#define PlayerDataPath ".\\Players\\"
#define TeamDataPath ".\\Teams\\"
#define GamePlayPath ".\\GamePlayData\\"
#define CameraPath ".\\CameraPath\\"
#define MeshDataPath ".\\MeshData\\"
#define MovesDataPath ".\\MeshData\\Moves\\"
#define TexturesPath ".\\Textures\\"
#define ShadersPath ".\\Shaders\\"
#define DataPath ".\\Data\\"

//wirtualne klawisze wynikowo przesy³ane zawodnikowi w evencie

/* default direct shit sound primary buffer parameters */
#define DEFAULT_AUDIO_CHANNELS				2
#define DEFAULT_AUDIO_FREQUENCY				44100
#define DEFAULT_AUDIO_BITRATE					16

#define   VBK_DOWN        1
#define   VBK_UP          2
#define   VBK_LEFT        4
#define   VBK_RIGHT       8
#define   VBK_ACTION_1    16
#define   VBK_ACTION_2    32
#define   VBK_ACTION_3    64
#define   VBK_ACTION_4    128
#define   VBK_HINT        256
#define   VBK_ACTION_HINT 512
#define   KEY_BLOCK       0xFFFFFFFF

#define VBK_UP_LEFT     (VBK_UP   | VBK_LEFT)
#define VBK_UP_RIGHT    (VBK_UP   | VBK_RIGHT)
#define VBK_DOWN_LEFT   (VBK_DOWN | VBK_LEFT)
#define VBK_DOWN_RIGHT  (VBK_DOWN | VBK_RIGHT)
#define VBK_ACTIONS     (VBK_ACTION_1 | VBK_ACTION_2 | VBK_ACTION_3 | VBK_ACTION_4)
#define VBK_DIRECTIONS     (VBK_DOWN | VBK_UP | VBK_LEFT | VBK_RIGHT)

#define CIRCLE   1.0f

#define PLAYER_DIM 0.3f

#define DEFAULT_TEXTURE 0

#define MAX_TACTIC_PHASES 3

typedef unsigned int HTexture;  /* handler/index w tablicy na dana texture */
typedef unsigned int HShader;  /* handler/index w tablicy na dany shader */
typedef unsigned int HMaterial;  /* handler/index w tablicy na dany material */
typedef unsigned int HMesh;
typedef unsigned int HAnimation;
typedef unsigned int HPhase;

/* music and sound ID should be renamed more accurately when they will be available */
enum AUDIO_ID
{
  MUSIC_0 = 0, MUSIC_1, MUSIC_2, MUSIC_3, MUSIC_4,
  EFFECT_0, EFFECT_1, EFFECT_2, EFFECT_3, EFFECT_4,
  EFFECT_5, EFFECT_6, EFFECT_7, EFFECT_8, EFFECT_9,
  EFFECT_10, EFFECT_11, EFFECT_12, EFFECT_13, EFFECT_14,
  WAV_0, WAV_1, WAV_2, WAV_3, WAV_4, WAV_5, WAV_6, WAV_7, WAV_8, WAV_9,
  WAV_10, WAV_11, WAV_12, WAV_13, WAV_14, WAV_15, WAV_16, WAV_17, WAV_18,
  WAV_19, WAV_21, WAV_22, WAV_23, WAV_24, WAV_25, WAV_26, WAV_27, WAV_28,
  WAV_29, LAST_AUDIO
};

enum Direction
{
  ANGLE_0 = 0,
  ANGLE_45, //1
  ANGLE_90, //2
  ANGLE_135, //3
  ANGLE_180,//4
  ANGLE_225,
  ANGLE_270,
  ANGLE_315,
  ANGLE_FREE
};

enum TurnAngle
{
  LEFT_180 = -4,
  LEFT_135,
  LEFT_90,
  LEFT_45,
  NO_TURN,
  RIGHT_45,
  RIGHT_90,
  RIGHT_135,
  RIGHT_180
};

enum PositionOnField
{
  POS_0 = 0,
  POS_1,
  POS_2,
  POS_3,
  POS_4,
  POS_5,
  
  SUB_0,
  SUB_1,
  SUB_2,
  SUB_3,
  SUB_4,
  SUB_5,

  POS_ZAGRYWKA,

  POS_BLOK_0,// <-> POS_3
  POS_BLOK_1,// <-> POS_4
  POS_BLOK_2,// <-> POS_5
  POS_BLOK_3,// -> POS_3
  POS_BLOK_4,// -> POS_5
  POS_BLOK_5,// -> POS_3
  POS_BLOK_6,// -> POS_4
  POS_BLOK_7,// -> POS_4
  POS_BLOK_8,// -> POS_5
  
  POS_DEFENDER_0,
  POS_DEFENDER_1,
  POS_DEFENDER_2,
  POS_DEFENDER_3,
  POS_DEFENDER_4,

  LAST_POS
};

enum TeamNumber
{
  TEAM_0,
  TEAM_1
};


enum States
{
  STATE_NONE=0,
  STATE_IDLE=1,
  TURN_LEFT_45,
  TURN_LEFT_90,
  TURN_LEFT_135,
  TURN_LEFT_180,
  TURN_RIGHT_45,
  TURN_RIGHT_90,
  TURN_RIGHT_135,
  TURN_RIGHT_180,  
  RUN_FAST,
  STOP_FAST_TURN_180,
  STOP_FAST,
  ZAGRYWKA_HINT,
  ZAGRYWKA_STEP_LEFT, 
  ZAGRYWKA_STEP_RIGHT,
  ZAGRYWKA_AIMING_LOP,
  ZAGRYWKA_HINT_AIMING_LOP,
  ZAGRYWKA_AIMING_SCINA,
  ZAGRYWKA_HINT_AIMING_SCINA,
  ZAGRYWKA_ACTION_LOP,
  ZAGRYWKA_END_LOP,
  ZAGRYWKA_ACTION_SCINA,
  ZAGRYWKA_END_SCINA,
  PRZYJECIE_SCINA_LOW,
  PRZYJECIE_END_SCINA_LOW,
  PRZYJECIE_SCINA,
  PRZYJECIE_END_SCINA,
  PRZYJECIE_SKOK,
  PRZYJECIE_END_SKOK,
  PRZYJECIE_GORNE,
  PRZYJECIE_END_GORNE,
  PRZYJECIE_DOLNE,
  PRZYJECIE_END_DOLNE,
  PRZYJECIE_KOLANA,
  PRZYJECIE_END_KOLANA,
  PRZYJECIE_STOPA,
  PRZYJECIE_END_STOPA,
  PRZYJECIE_BLOK,
  PRZYJECIE_BLOK_HINT,
  PRZYJECIE_BLOK_STEP_LEFT,
  PRZYJECIE_BLOK_STEP_RIGHT,
  PRZYJECIE_END_BLOK,
  PRZYJECIE_SZCZUPAK_FORWARD,
  PRZYJECIE_END_SZCZUPAK_FORWARD,
  HOP_FORWARD,
  HOP_FORWARD_LEFT_45,
  HOP_FORWARD_RIGHT_45,
#ifdef USE_HOPS
  HOP_BACKWARD_LEFT_45,
  HOP_BACKWARD_RIGHT_45,
#endif
  PRZYJECIE_DOLNE_HINT,
  PRZYJECIE_GORNE_HINT,
  SIT_IDLE,
  STAND_UP,
  SIT_DOWN,
  STATE_SZCZUPAK,
  LAST_STATE
};

/*
  Nie nalezy zmieniac numeracji, sa to indeksy w tablicy
  mapowan dla kazdego usera
*/
enum KeyMaps
{
  MAPKEY_UP    = 0,
  MAPKEY_DOWN  = 1,
  MAPKEY_LEFT  = 2,
  MAPKEY_RIGHT = 3,
  MAPKEY_1     = 4,  
  MAPKEY_2     = 5,
  MAPKEY_3     = 6,    
  MAPKEY_4     = 7 
};

#define VBKEY_ESCAPE          0x01
#define VBKEY_1               0x02
#define VBKEY_2               0x03
#define VBKEY_3               0x04
#define VBKEY_4               0x05
#define VBKEY_5               0x06
#define VBKEY_6               0x07
#define VBKEY_7               0x08
#define VBKEY_8               0x09
#define VBKEY_9               0x0A
#define VBKEY_0               0x0B
#define VBKEY_MINUS           0x0C    /* - on main keyboard */
#define VBKEY_EQUALS          0x0D
#define VBKEY_BACK            0x0E    /* backspace */
#define VBKEY_TAB             0x0F
#define VBKEY_Q               0x10
#define VBKEY_W               0x11
#define VBKEY_E               0x12
#define VBKEY_R               0x13
#define VBKEY_T               0x14
#define VBKEY_Y               0x15
#define VBKEY_U               0x16
#define VBKEY_I               0x17
#define VBKEY_O               0x18
#define VBKEY_P               0x19
#define VBKEY_LBRACKET        0x1A
#define VBKEY_RBRACKET        0x1B
#define VBKEY_RETURN          0x1C    /* Enter on main keyboard */
#define VBKEY_LCONTROL        0x1D
#define VBKEY_A               0x1E
#define VBKEY_S               0x1F
#define VBKEY_D               0x20
#define VBKEY_F               0x21
#define VBKEY_G               0x22
#define VBKEY_H               0x23
#define VBKEY_J               0x24
#define VBKEY_K               0x25
#define VBKEY_L               0x26
#define VBKEY_SEMICOLON       0x27
#define VBKEY_APOSTROPHE      0x28
#define VBKEY_GRAVE           0x29    /* accent grave */
#define VBKEY_LSHIFT          0x2A
#define VBKEY_BACKSLASH       0x2B
#define VBKEY_Z               0x2C
#define VBKEY_X               0x2D
#define VBKEY_C               0x2E
#define VBKEY_V               0x2F
#define VBKEY_B               0x30
#define VBKEY_N               0x31
#define VBKEY_M               0x32
#define VBKEY_COMMA           0x33
#define VBKEY_PERIOD          0x34    /* . on main keyboard */
#define VBKEY_SLASH           0x35    /* / on main keyboard */
#define VBKEY_RSHIFT          0x36
#define VBKEY_MULTIPLY        0x37    /* * on numeric keypad */
#define VBKEY_LMENU           0x38    /* left Alt */
#define VBKEY_SPACE           0x39
#define VBKEY_CAPITAL         0x3A
#define VBKEY_F1              0x3B
#define VBKEY_F2              0x3C
#define VBKEY_F3              0x3D
#define VBKEY_F4              0x3E
#define VBKEY_F5              0x3F
#define VBKEY_F6              0x40
#define VBKEY_F7              0x41
#define VBKEY_F8              0x42
#define VBKEY_F9              0x43
#define VBKEY_F10             0x44
#define VBKEY_NUMLOCK         0x45
#define VBKEY_SCROLL          0x46    /* Scroll Lock */
#define VBKEY_NUMPAD7         0x47
#define VBKEY_NUMPAD8         0x48
#define VBKEY_NUMPAD9         0x49
#define VBKEY_SUBTRACT        0x4A    /* - on numeric keypad */
#define VBKEY_NUMPAD4         0x4B
#define VBKEY_NUMPAD5         0x4C
#define VBKEY_NUMPAD6         0x4D
#define VBKEY_ADD             0x4E    /* + on numeric keypad */
#define VBKEY_NUMPAD1         0x4F
#define VBKEY_NUMPAD2         0x50
#define VBKEY_NUMPAD3         0x51
#define VBKEY_NUMPAD0         0x52
#define VBKEY_DECIMAL         0x53    /* . on numeric keypad */
#define VBKEY_OEM_102         0x56    /* <> or \| on RT 102-key keyboard (Non-U.S.) */
#define VBKEY_F11             0x57
#define VBKEY_F12             0x58
#define VBKEY_F13             0x64    /*                     (NEC PC98) */
#define VBKEY_F14             0x65    /*                     (NEC PC98) */
#define VBKEY_F15             0x66    /*                     (NEC PC98) */
#define VBKEY_KANA            0x70    /* (Japanese keyboard)            */
#define VBKEY_ABNT_C1         0x73    /* /? on Brazilian keyboard */
#define VBKEY_CONVERT         0x79    /* (Japanese keyboard)            */
#define VBKEY_NOCONVERT       0x7B    /* (Japanese keyboard)            */
#define VBKEY_YEN             0x7D    /* (Japanese keyboard)            */
#define VBKEY_ABNT_C2         0x7E    /* Numpad . on Brazilian keyboard */
#define VBKEY_NUMPADEQUALS    0x8D    /* = on numeric keypad (NEC PC98) */
#define VBKEY_PREVTRACK       0x90    /* Previous Track (VBKEY_CIRCUMFLEX on Japanese keyboard) */
#define VBKEY_AT              0x91    /*                     (NEC PC98) */
#define VBKEY_COLON           0x92    /*                     (NEC PC98) */
#define VBKEY_UNDERLINE       0x93    /*                     (NEC PC98) */
#define VBKEY_KANJI           0x94    /* (Japanese keyboard)            */
#define VBKEY_STOP            0x95    /*                     (NEC PC98) */
#define VBKEY_AX              0x96    /*                     (Japan AX) */
#define VBKEY_UNLABELED       0x97    /*                        (J3100) */
#define VBKEY_NEXTTRACK       0x99    /* Next Track */
#define VBKEY_NUMPADENTER     0x9C    /* Enter on numeric keypad */
#define VBKEY_RCONTROL        0x9D
#define VBKEY_MUTE            0xA0    /* Mute */
#define VBKEY_CALCULATOR      0xA1    /* Calculator */
#define VBKEY_PLAYPAUSE       0xA2    /* Play / Pause */
#define VBKEY_MEDIASTOP       0xA4    /* Media Stop */
#define VBKEY_VOLUMEDOWN      0xAE    /* Volume - */
#define VBKEY_VOLUMEUP        0xB0    /* Volume + */
#define VBKEY_WEBHOME         0xB2    /* Web home */
#define VBKEY_NUMPADCOMMA     0xB3    /* , on numeric keypad (NEC PC98) */
#define VBKEY_DIVIDE          0xB5    /* / on numeric keypad */
#define VBKEY_SYSRQ           0xB7
#define VBKEY_RMENU           0xB8    /* right Alt */
#define VBKEY_PAUSE           0xC5    /* Pause */
#define VBKEY_HOME            0xC7    /* Home on arrow keypad */
#define VBKEY_UP              0xC8    /* UpArrow on arrow keypad */
#define VBKEY_PRIOR           0xC9    /* PgUp on arrow keypad */
#define VBKEY_LEFT            0xCB    /* LeftArrow on arrow keypad */
#define VBKEY_RIGHT           0xCD    /* RightArrow on arrow keypad */
#define VBKEY_END             0xCF    /* End on arrow keypad */
#define VBKEY_DOWN            0xD0    /* DownArrow on arrow keypad */
#define VBKEY_NEXT            0xD1    /* PgDn on arrow keypad */
#define VBKEY_INSERT          0xD2    /* Insert on arrow keypad */
#define VBKEY_DELETE          0xD3    /* Delete on arrow keypad */
#define VBKEY_LWIN            0xDB    /* Left Windows key */
#define VBKEY_RWIN            0xDC    /* Right Windows key */
#define VBKEY_APPS            0xDD    /* AppMenu key */
#define VBKEY_POWER           0xDE    /* System Power */
#define VBKEY_SLEEP           0xDF    /* System Sleep */
#define VBKEY_WAKE            0xE3    /* System Wake */
#define VBKEY_WEBSEARCH       0xE5    /* Web Search */
#define VBKEY_WEBFAVORITES    0xE6    /* Web Favorites */
#define VBKEY_WEBREFRESH      0xE7    /* Web Refresh */
#define VBKEY_WEBSTOP         0xE8    /* Web Stop */
#define VBKEY_WEBFORWARD      0xE9    /* Web Forward */
#define VBKEY_WEBBACK         0xEA    /* Web Back */
#define VBKEY_MYCOMPUTER      0xEB    /* My Computer */
#define VBKEY_MAIL            0xEC    /* Mail */
#define VBKEY_MEDIASELECT     0xED    /* Media Select */

#define M_X 300
#define M_Y 301
#define M_Z 302
#define M_RGB1 303
#define M_RGB2 304
#define M_RGB3 305
#define M_1 306
#define M_2 307
#define M_3 308
#define M_MX 309
#define M_MY 310
#define M_MZ 311

#define J_X_LEFT	401
#define J_X_RIGHT	402
#define J_Y_UP		403
#define J_Y_DOWN	404
#define J_Z_UP		405
#define J_Z_DOWN	406

#define J_LRX_LEFT		410
#define J_LRX_RIGTH		411
#define J_LRY_LEFT		412
#define J_LRY_RIGTH		413
#define J_LRZ_LEFT		414
#define J_LRZ_RIGTH		415

#define J_SLIDER0_L		420
#define J_SLIDER0_R		421
#define J_SLIDER1_L		420
#define J_SLIDER1_R		421

#define J_RGB1 430
#define J_RGB2 431
#define J_RGB3 432
#define J_RGB4 433
#define J_RGB5 434
#define J_RGB6 435
#define J_RGB7 436
#define J_RGB8 437
#define J_RGB9 438




#ifndef MAKEFOURCC
    #define MAKEFOURCC(ch0, ch1, ch2, ch3)                              \
                ((unsigned long)(unsigned char)(ch0) | ((unsigned long)(unsigned char)(ch1) << 8) |       \
                ((unsigned long)(unsigned char)(ch2) << 16) | ((unsigned long)(unsigned char)(ch3) << 24 ))
#endif /* defined(MAKEFOURCC) */


enum eTeams
{
  TEAM_BRAZIL,
  TEAM_GREECE,
  TEAM_SPAIN,
  TEAM_PORTUGAL,
  TEAM_FRANCE,
  TEAM_BULGARIA,
  TEAM_JAPAN,
  TEAM_POLAND,
  TEAM_ITALY,
  TEAM_CHINA,
  TEAM_SERBIA,
  TEAM_CUBA,
  TEAM_RUSSIA,
  TEAM_CZECH,
  TEAM_CROATIA,
  TEAM_TURKEY,
  TEAM_GERMANY,
  TEAM_HOLLAND,
  TEAM_FINLAND,
  TEAM_SLOVAKIA
};

char *teamDatafiles[];
char *teamNames[]; 
char *team3let[];

struct SetStruct
{
  unsigned char Score[MAX_TEAM];
  unsigned char winningTeam;
};

enum align_type {
  ALIGN_LEFT = 0, 
  ALIGN_CENTER,
  ALIGN_RIGHT,
};

#endif
E:\Project\Kopia (5) VBEngine\Utility\Defines.h
#ifndef _CTIME_H
#define _CTIME_H

/*
class       : CTime
description : Singleton zarzadzania czasem

methods     : SnapShot   - ustawia czas na aktualny czas zegarowy
              GetTime    - pobiera ustawiony czas
*/

#define NOW      CTime::Instance()->GetTime()
#define REALNOW  CTime::Instance()->GetRealTime()


class CTime : public Singleton<CTime>
{
  float mFrameTime;
  float mConstructionTime;
  float mTimeScale;
  float GetSystemTime(void);
  bool mPaused;
  float mPauseTime;
  float mRealPauseTime;
  float mRealFrameTime;
public:
  CTime();
  void SnapShot(void);
  float GetTime(void) {return mFrameTime;};
  float GetRealTime(void) {return mRealFrameTime;}
  void Pause();
  void Unpause()  {mPaused = false;};
};

#endif
E:\Project\Kopia (5) VBEngine\Utility\CTime.h
#include <assert.h>
#include <windows.h>
#include <mmsystem.h>

#include "Defines.h"
#include "conf.h"
#include "singleton.h"
#include "CTime.h"
#include "Tools.h"


// funkcja pobieraj¹ca czas systemowy i t³umacz¹ca go na nasz format (float w sekundach)
float CTime::GetSystemTime(void)
{
  float deltaTime = ((float)timeGetTime()/1000) - mConstructionTime;
  return deltaTime *mTimeScale + mConstructionTime;
};
// konstruktor - wczytuje szybkoœæ czasu
CTime::CTime() : mFrameTime(0.0f) ,mPauseTime(0.0f),mRealPauseTime(0.0f), mPaused(false)
{
  ConfFile config;
  char buffer[MAX_FILE_NAME];
  
  mTimeScale = 1.0f;
  my_snprintf(buffer, MAX_FILE_NAME, "%s%s", DataPath, "game.dat");
  if (SUCCEEDED(config.Init(buffer)))
  {
    config.GET_FOLAT("GAME_SPEED",&mTimeScale);
    config.DeInit();
  }
  this->mConstructionTime = ((float)timeGetTime()/1000);
}
// zapisuje czas aktualnej klatki
void CTime::SnapShot(void)
{
  mRealFrameTime = this->GetSystemTime();
  if (!mPaused)
  {
     mFrameTime = (mRealFrameTime - mRealPauseTime) + mPauseTime;
  }
}

void CTime::Pause(void)
{
  mPaused = true;
  mRealPauseTime = mRealFrameTime;
  mPauseTime = mFrameTime;
}
  
E:\Project\Kopia (5) VBEngine\Utility\CTime.cpp
#ifndef TEXTHELP_H
#define TEXTHELP_H

//#include "Includy.h"
#include <windows.h>
class ConfFile
{
    char *pbuffer;
    char name[256];
    bool is_comment(char *pstr);
    char * get_new_line(char *pbuffer);
    HRESULT GET_TAG(char *ptag, bool, void *);
      
public:
  
	ConfFile();
  ~ConfFile();
    
	HRESULT Init(char*);
  void DeInit(void);
    
	HRESULT GET_INT(char *ptag, int *pdata)
        {
          return GET_TAG(ptag, true, (void *)pdata);
        };
	HRESULT GET_FOLAT(char *ptag, float *pdata)
        {
          return GET_TAG(ptag, false, (void *)pdata);
        };
	char * GET_STR(char *ptag);
  HRESULT GET_VECT(char *ptag, float *, float *, float *);
};

#endif /* TEXTHELP_H */
E:\Project\Kopia (5) VBEngine\Utility\conf.h
//#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <assert.h>

#include "defines.h"
#include "Tools.h"
#include "conf.h"
#include "singleton.h"

#include "..\FileSystem\FileSystem.h"

#ifndef MAX_PATCH
#define MAX_PATCH   256
#endif

#ifdef HAVE_STRDUP
#define mystrdup(str)    strdup(str)
#else
#define mystrdup(str)    _strdup(str)
#endif


ConfFile::ConfFile()
{
  this->pbuffer = NULL;
  this->name[0] = '\0';
};

ConfFile::~ConfFile()
{
  if (pbuffer) {
    free(pbuffer);
    pbuffer = NULL;
  }
};

void ConfFile::DeInit()
{
  this->name[0] = '\0';
  if (pbuffer) {
    free(pbuffer);
    pbuffer = NULL;
  }
};

HRESULT ConfFile::Init(char *filename)
{
  FILE* in;
  size_t lenght;
  
  if (NULL == filename || (filename && *filename == '\0'))
  {
    return E_FAIL;
  }
  
  if (NULL == (in=fopen(filename,"rt")))
  {
    void *data;
    unsigned int size;
    data = FileSystem::Instance()->LoadFile(filename,&size);
    if (data == NULL) return E_FAIL;

    if (NULL == (pbuffer = (char *)malloc(size+1))) 
        return E_FAIL;
    
    memcpy(pbuffer,data,size);
    pbuffer[size] = '\0';

    return S_OK;
  }

  my_snprintf(this->name, 256, filename);

  // find size of buffer 
  fseek(in, 0, SEEK_END);
  lenght = ftell(in);
  fseek(in, 0, SEEK_SET);

  // alloc buffer 
  if (NULL == (pbuffer = (char *)malloc(lenght))) {
    fclose(in);
    return E_FAIL;
  }
  memset(pbuffer, 0, lenght);

  fread(pbuffer, sizeof(char), lenght, in);
  fclose(in);

  return S_OK;
};

bool ConfFile::is_comment(char *pstr)
{
    return (*pstr == ';' || *pstr == '#');
};

char * ConfFile::get_new_line(char *pbuffer)
{
  int ok;
  do {
    ok = 0;
    pbuffer = strchr(pbuffer, '\n');
    if (pbuffer)
    {
      pbuffer++;
      ok = is_comment(pbuffer);
    }
  } while (ok);
  return pbuffer;
};

HRESULT ConfFile::GET_TAG(char *ptag , bool typ, void *pdata)
{
  int not_equal = 1;
  char *pstart, *pend, end_backup;
  char *pbuf = pbuffer;
  
  while (not_equal && pbuf && *pbuf != '\0') {

    if (NULL == (pend = strchr(pbuf, '=')))
    {
      if ((pbuf = get_new_line(pbuf)))
      {
        continue;
      } else {
        break;
      }
    }
    
    // find start and remove unused spaces 
    pstart = pbuf;
    while (pstart && *pstart != '\0' && *pstart == ' ')
    {
       pstart++;
    }

    // find end and remove unused spaces 
    pend--;
    while (pend && *pend != '\0' && *pend == ' ')
    {
      pend--;
    }
    pend++;

    // compare 
    end_backup = *pend;
    *pend = '\0';
    not_equal = strcmp(pstart, ptag);
    *pend = end_backup;

    if (!not_equal)
    {
       // find start and remove unused spaces 
       pstart = strchr(pend, '=');
       pstart++;
       while (pstart && *pstart != '\0' && *pstart == ' ')
       {
           pstart++;
       }
       // find end and remove unused spaces 
       pend = pstart;
       while (pend && *pend != '\0' && *pend != ' ' && *pend != '\n' && !is_comment(pend))
       {
          pend++;
       }
       end_backup = *pend;
      *pend = '\0';
       if (pstart && *pstart != '\0') {
          if (typ) {
            int retval;
            sscanf(pstart, "%d", &retval);
            *(int *)pdata = retval;
          } else {
            float retval;
            sscanf(pstart, "%f", &retval);
            *(float *)pdata = retval;
          }
       }
       *pend = end_backup;
    } else {
      pbuf = get_new_line(pbuf);
    }
    
  }

  if (not_equal)
  {
    return E_FAIL;
  }

  return S_OK;
};

HRESULT ConfFile::GET_VECT(char *ptag, float *px, float *py, float *pz)
{
  int not_equal = 1;
  char *pstart, *pend, end_backup;
  char *pbuf = pbuffer;
  
  while (not_equal && pbuf && *pbuf != '\0') {

    if (NULL == (pend = strchr(pbuf, '=')))
    {
      if ((pbuf = get_new_line(pbuf)))
      {
        continue;
      } else {
        break;
      }
    }
    
    // find start and remove unused spaces 
    pstart = pbuf;
    while (pstart && *pstart != '\0' && *pstart == ' ')
    {
       pstart++;
    }

    // find end and remove unused spaces 
    pend--;
    while (pend && *pend != '\0' && *pend == ' ')
    {
      pend--;
    }
    pend++;

    // compare 
    end_backup = *pend;
    *pend = '\0';
    not_equal = strcmp(pstart, ptag);
    *pend = end_backup;

    if (!not_equal)
    {
       int count = 3;
       char *ptmp;
       // find start and remove unused spaces //
       pstart = strchr(pend, '{');
       ptmp = strchr(pstart, '}');
       if(!ptmp)
       {
         printf("File : %s\n", this->name);
         printf("Tag : %s\n", ptag);
         assert(NULL != ptmp && "I: NO VECTOR END SEQUENCE");
       }
       while (count) 
       {  
         pstart++;
         while (pstart && *pstart != '\0' && *pstart != '\n' && *pstart == ' ')
         {
           pstart++;
         }
         if(!pstart  || (pstart && (*pstart == '\0' || *pstart == '\n' || *pstart == ' ')))
         {
           printf("File : %s\n", this->name);
           printf("Tag : %s\n", ptag);
           assert(pstart && *pstart != '\0' && *pstart != '\n' && *pstart != ' ' && "II: VECTOR READING ERROR");
         }
         // find end and remove unused spaces 
         if (count > 1)
         {
           pend = strchr(pstart, ',');
         }
         else
         {
           pend = strchr(pstart, '}');
         }
         pend--;
         while (pend && pend != pstart && *pend == ' ')
         {
           pend--;
         }
         
         if(!pend  || (pend && (pend == pstart || pend >= ptmp)))
         {
           printf("File : %s\n", this->name);
           printf("Tag : %s\n", ptag);
           assert(pend && pend != pstart && pend < ptmp && "III: VECTOR READING ERROR");
         }

         pend++;
         end_backup = *pend;
        *pend = '\0';
         if (pstart && *pstart != '\0')
         {
           switch (count)
           {
             case 3:
               sscanf(pstart, "%f", px);
             break;
             case 2:
               sscanf(pstart, "%f", py);
             break;
             default:
               sscanf(pstart, "%f", pz);
             break;
           }
           
         }
         *pend = end_backup;
         count--;
         if (count) {
           pstart = strchr(pend, ',');
         }
       }
    } else {
      pbuf = get_new_line(pbuf);
    }
    
  }

  if (not_equal)
  {
    return E_FAIL;
  }

  return S_OK;
};

char * ConfFile::GET_STR(char *ptag)
{
  char *retval = NULL;
  int not_equal = 1;
  char *pstart, *pend, end_backup;
  char *pbuf = pbuffer;
  
  while (not_equal && pbuf && *pbuf != '\0') {

    if (NULL == (pend = strchr(pbuf, '=')))
    {
      if ((pbuf = get_new_line(pbuf)))
      {
        continue;
      } else {
        break;
      }
    }
    
    // find start and remove unused spaces 
    pstart = pbuf;
    while (pstart && *pstart != '\0' && *pstart == ' ')
    {
       pstart++;
    }

    // find end and remove unused spaces 
    pend--;
    while (pend && *pend != '\0' && *pend == ' ')
    {
      pend--;
    }
    pend++;

    // compare 
    end_backup = *pend;
    *pend = '\0';
    not_equal = strcmp(pstart, ptag);
    *pend = end_backup;

    if (!not_equal)
    {
       // find start and remove unused spaces 
       pstart = strchr(pend, '=');
       pstart++;
       while (pstart && *pstart != '\0' && *pstart != '"')// find first " //
       {
           pstart++;
       }
       pstart++;// get fisrts string char 

       // find end and remove unused spaces 
       pend = pstart;
       while (pend && *pend != '\0' && *pend != '"')
       {
          pend++;
       }
       end_backup = *pend;
      *pend = '\0';
       if (pstart && *pstart != '\0') {
         retval = mystrdup(pstart);// memory allocation !!! please call free() when you don't need this string 
       }
       *pend = end_backup;
    } else {
      pbuf = get_new_line(pbuf);
    }
    
  }

  if (not_equal)
  {
    return NULL;
  }

  return retval;
};

E:\Project\Kopia (5) VBEngine\Utility\conf.cpp
#pragma once

//#include "Includy.h"

#define BYTE unsigned char
#define LONG long

struct MOUSESTATE
{
	float lX;
	float lY;
	float lZ;
	BYTE rgbButtons[4];
	BYTE mButtons[4];
	float MX;
	float MY;
	float MZ;
};



class CMappingList
{
	int real;
	int mapped;
	CMappingList *next;
	float deadzone;
public:
	float withDeadZone(LONG n);

	void SetDeadZone(float _d) { deadzone = _d; };
	float GetDeadZone() { return deadzone; };
	CMappingList();
	~CMappingList();
	void Add(int _real, int _mapped);
	bool Change(int _real, int _mapped);
  bool ChangeForReal(int _real, int _mapped);
	void Translate(BYTE *_diks, BYTE *_diks_old, BYTE *diks_new, BYTE *diks_new_menu, DIJOYSTATE2 &js);
	void TranslateMouse(DIMOUSESTATE &dims, DIJOYSTATE2 &js, MOUSESTATE *dims_new);
	float GetDims(DIMOUSESTATE &dims, int _x);
	float GetDimsJoy(DIJOYSTATE2 &js, int _x, bool analog);
};
E:\Project\Kopia (5) VBEngine\Input\mapper.h


#include <dinput.h>

#include "..\Utility\vbmath.h"
#include "..\Utility\defines.h"
#include "..\Utility\tools.h"
#include "mapper.h"

CMappingList::CMappingList()
{
	next = NULL;
	this->SetDeadZone(100.0f);
}

CMappingList::~CMappingList()
{
	if (next) delete next;
}

void CMappingList::Add(int _real, int _mapped)
{
	if (this->next==NULL)
	{
		real = _real; 
		mapped = _mapped;
		this->next = new CMappingList();
	} else next->Add(_real, _mapped);
}

/*
  \fn bool CMappingList::Change(int _real, int _mapped)
  \brief Przechodzi po wszystkich mapowaniach, i jesli znajdzie to ktore nalezy zmienic
  dokonuje zmiany.
  \param _real klawisz ten ktory przychodzi z DInput
  \param _mapped (ten bedzie zmieniany na liscie), to co bedzie pozniej czytane z tablict diks
  \return true - zmiana zostala dokonana, false - nie znaleziono takiego mapowania

  Ta funkcja zmiania mapowanie dla danego klawisza - real - powinna byc uzywana tylko na poczatku 
  dzialania gry - gdyz wewnetrznie te mapowania sa ustawione na sztywno w klasie User
*/
bool CMappingList::Change(int _real, int _mapped)
{
	if (this->real==_real)
	{
		this->mapped = _mapped;
    return true;
	}
	if (this->next!=NULL) 
    return next->Change(_real, _mapped);		
  
  return false;
}

/*
  \fn bool CMappingList::ChangeForReal(int _real, int _mapped)
  \brief Przechodzi po wszystkich mapowaniach, i jesli znajdzie to ktore nalezy zmienic
  dokonuje zmiany.
  \param _real (ten bedzie zmieniany na liscie) klawisz ten ktory przychodzi z DInput
  \param _mapped to co bedzie pozniej czytane z tablict diks
  \return true - zmiana zostala dokonana, false - nie znaleziono takiego mapowania

  Funkcja zmienia tylko jaki klawisz ma byc podpiety do istniejacego juz mapowania, np.
  user zmienia sobie klawisze w opcjach gry, mapowania pozostaja takie same dla okreslonych
  userow (USER_1, USER_2 ...)
*/
bool CMappingList::ChangeForReal(int _real, int _mapped)
{
  if (this->mapped == _mapped)
	{
		this->real = _real;
    return true;
	}
	if (this->next!=NULL) 
    return next->ChangeForReal(_real, _mapped);		
  
  return false;
}

void CMappingList::Translate(BYTE *_diks, BYTE *_diks_old, BYTE *diks_new, BYTE *diks_new_menu, DIJOYSTATE2 &js)
{
	if (this->next!=NULL)
	{	
		if (this->real<400)
		{
			BYTE old = (_diks[real]&128)^(_diks_old[real]&128);		
			diks_new[this->mapped] = _diks[this->real];
			diks_new_menu[this->mapped] = (_diks[this->real]&128)&&(old);
		} else {
			diks_new[this->mapped] =(unsigned char)this->GetDimsJoy(js, this->real, false);
		}

		this->next->Translate(_diks, _diks_old, diks_new, diks_new_menu, js);
	}
}

float CMappingList::withDeadZone(LONG n)
{
	if ((float)(IABS(n))<this->deadzone) return 0;
	return ((float)n)/100.0f;
}

float CMappingList::GetDimsJoy(DIJOYSTATE2 &js, int _x, bool analog)
{
	if ((_x == J_X_LEFT)||(_x == J_X_RIGHT))
	{
		if (analog)	return withDeadZone(js.lX);
		else {
			if (_x == J_X_RIGHT)
			{
				if (js.lX>500) return 1;
						  else return 0;
									 
			}
			if (_x == J_X_LEFT)
			{
				if (js.lX<-500) return 1;
						   else return 0;
			}			
		}
	}
	if ((_x == J_Y_UP)||(_x == J_Y_DOWN)) 
	{
		if (analog) return withDeadZone(js.lY);
		else {
			if (_x == J_Y_UP)
			{
				if (js.lY>500) 
					return 1;
						  else 
							  return 0;
									 
			}
			if (_x == J_Y_DOWN)
			{
				if (js.lY<-500) 
					return 1;
						   else 
							   return 0;
			}						
		}
	}

	if ((_x == J_LRX_LEFT)||(_x == J_LRX_RIGTH)) 
	{
		if (analog) return withDeadZone(js.lRx);
		else {
			if (_x == J_LRX_RIGTH)
			{				
				if (js.lRx>500) 
					return 1;
						  else 
							  return 0;
									 
			}
			if (_x == J_LRX_LEFT)
			{
				if (js.lRx<-500) 
					return 1;
						   else 
							   return 0;
			}						
		}
	}
	if ((_x == J_LRY_LEFT)||(_x == J_LRY_RIGTH)) 
	{
		if (analog) return withDeadZone(js.lRy);
		else {
			if (_x == J_LRY_RIGTH)
			{				
				if (js.lRy>500) 
					return 1;
						  else 
							  return 0;
									 
			}
			if (_x == J_LRY_LEFT)
			{
				if (js.lRy<-500) 
					return 1;
						   else 
							   return 0;
			}						
		}
	}
	if ((_x == J_LRZ_LEFT)||(_x == J_LRZ_RIGTH)) 
	{
		if (analog) return withDeadZone(js.lRz);
		else {
			if (_x == J_LRZ_RIGTH)
			{				
				if (js.lRz>500) 
					return 1;
						  else 
							  return 0;
									 
			}
			if (_x == J_LRZ_LEFT)
			{
				if (js.lRz<-500) 
					return 1;
						   else 
							   return 0;
			}						
		}
	}

	if ((_x == J_SLIDER0_L)||(_x == J_SLIDER0_R)) 
	{
		if (analog) return withDeadZone(js.rglSlider[0]);
		else {
			if (_x == J_SLIDER0_R)
			{
				if (js.rglSlider[0]>500) return 1;
									else return 0;
									 
			}
			if (_x == J_SLIDER0_L)
			{
				if (js.rglSlider[0]<-500) return 1;
									 else return 0;
			}						
		}
	}
	if ((_x == J_SLIDER1_L)||(_x == J_SLIDER1_R)) 
	{
		if (analog) return withDeadZone(js.rglSlider[1]);
		else {
			if (_x == J_SLIDER1_R)
			{
				if (js.rglSlider[1]>500) return 1;
									else return 0;
									 
			}
			if (_x == J_SLIDER1_L)
			{
				if (js.rglSlider[1]<-500) return 1;
									 else return 0;
			}						
		}
	}

	if (_x == J_RGB1) return js.rgbButtons[0];
	if (_x == J_RGB2) return js.rgbButtons[1];
	if (_x == J_RGB3) return js.rgbButtons[2];
	if (_x == J_RGB4) return js.rgbButtons[3];
	if (_x == J_RGB5) return js.rgbButtons[4];
	if (_x == J_RGB6) return js.rgbButtons[5];
	if (_x == J_RGB7) return js.rgbButtons[6];
	if (_x == J_RGB8) return js.rgbButtons[7];
	if (_x == J_RGB9) return js.rgbButtons[8];
	return 0;
}

float CMappingList::GetDims(DIMOUSESTATE &dims, int _x)
{
	if (_x == M_X) return (float)dims.lX;
	if (_x == M_Y) return (float)dims.lY;
	if (_x == M_Z) return (float)dims.lZ;	
	if (_x == M_MX) return (float)dims.lX;
	if (_x == M_MY) return (float)dims.lY;
	if (_x == M_MZ) return (float)dims.lZ;	
	if (_x == M_RGB1) return dims.rgbButtons[0];
	if (_x == M_RGB2) return dims.rgbButtons[1];
	if (_x == M_RGB3) return dims.rgbButtons[2];
	if (_x == M_1) return dims.rgbButtons[0];
	if (_x == M_2) return dims.rgbButtons[1];
	if (_x == M_3) return dims.rgbButtons[2];
	return 0;
}

void CMappingList::TranslateMouse(DIMOUSESTATE &dims, DIJOYSTATE2 &js, MOUSESTATE *dims_new)
{
	if (this->next!=NULL)
	{
		if (this->mapped==M_X)
		{
			if (this->real<400)
			{
				dims_new->lX = this->GetDims(dims, this->real);
			} else {
				dims_new->lX = this->GetDimsJoy(js, this->real, true);
			}
		}
		if (this->mapped==M_Y)
		{
			if (this->real<400)
			{
				dims_new->lY = this->GetDims(dims, this->real);
			} else {
				dims_new->lY = this->GetDimsJoy(js, this->real, true);
			}
		}
		if (this->mapped==M_MX)
		{
			if (this->real<400)
			{
				dims_new->MX = this->GetDims(dims, this->real);
			} else {
				dims_new->MX = this->GetDimsJoy(js, this->real, true);
			}
		}
		if (this->mapped==M_MY)
		{
			if (this->real<400)
			{
				dims_new->MY = this->GetDims(dims, this->real);
			} else {
				dims_new->MY = this->GetDimsJoy(js, this->real, true);
			}
		}


		if (this->mapped==M_RGB1)
		{
			if (this->real<400)
			{
				dims_new->rgbButtons[0] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->rgbButtons[0] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		if (this->mapped==M_RGB2)
		{
			if (this->real<400)
			{
				dims_new->rgbButtons[1] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->rgbButtons[1] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		if (this->mapped==M_RGB3)
		{
			if (this->real<400)
			{
				dims_new->rgbButtons[2] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->rgbButtons[2] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		if (this->mapped==M_1)
		{
			if (this->real<400)
			{
				dims_new->mButtons[0] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->mButtons[0] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		if (this->mapped==M_2)
		{
			if (this->real<400)
			{
				dims_new->mButtons[1] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->mButtons[1] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		if (this->mapped==M_3)
		{
			if (this->real<400)
			{
				dims_new->mButtons[2] = (unsigned char)this->GetDims(dims, this->real);
			} else {
				dims_new->mButtons[2] = (unsigned char)this->GetDimsJoy(js, this->real, false);
			}
		}
		this->next->TranslateMouse(dims, js, dims_new);
	} 
}
E:\Project\Kopia (5) VBEngine\Input\mapper.cpp
#ifndef INPUT
#define INPUT

/*
class       : Input
description : 
methods     :
              Input()  - konstruktor
	            ~Input() - destruktor
              SetAquire(bool bl) - 
*/

struct MOUSESTATE;
class CMappingList;

class Input : public Singleton<Input>
{
  LPDIRECTINPUT8 g_lpDI;
	LPDIRECTINPUTDEVICE8 devklawiatura; 
	LPDIRECTINPUTDEVICE8 devmysz;    
	LPDIRECTINPUTDEVICE8 devjoy;

	CMappingList *mapping;
	CMappingList *mouse_mapping;	
  bool acquired;

  static BOOL CALLBACK EnumJoysticksCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef) 
	{      
		return ((Input*)pvRef)->EnumJoysticksCallback(lpddi);  
	}   
	
	static BOOL CALLBACK EnumObjectsCallback( const DIDEVICEOBJECTINSTANCE* pdidoi, VOID* pContext )
	{
		return ((Input*)pContext)->EnumObjectsCallbak(pdidoi);
	}
	bool EnumObjectsCallbak( const DIDEVICEOBJECTINSTANCE* pdidoi);
	BOOL CALLBACK EnumJoysticksCallback(LPCDIDEVICEINSTANCE lpddi);

  MOUSESTATE dims;
  DIMOUSESTATE dims_real;
public:	

  DIJOYSTATE2 js;
  BYTE diksold[256];
	BYTE diks_real[256];


  /* Mouse */
  bool old_wlaczonyl;
  bool old_wlaczonyr;
	bool wlaczonyl;
	bool wlaczonyr;
	bool wlaczl;
	bool wlaczr;
	float mouse_x, mouse_y;
  float total_mouse_x,total_mouse_y;
  /* End Mouse */

	Input();
	~Input();

  HRESULT GetAllDataToObject();
	HRESULT Init(HINSTANCE,HWND);
	void DeInit(void);
	
	void TranslateState();

	HRESULT ChangeMappingKeyboard(int _old);
	int GetCh(void);

	void operator()(DWORD) {GetAllDataToObject();};

	
	BYTE diks[256];
	BYTE diks_menu[256];
   
  bool WasPressed(int key)  { return ( !diksold[key]  &&  diks[key]);  }
  bool WasReleased(int key) { return (  diksold[key]  && !diks[key]);  };
  
	
	void Map();
  void AddMap(int _real, int _mapped);
  bool ChangeMap(int _real, int _mapped);
  bool ChangeMapForReal(int _real, int _mapped);
  void SetAquire(bool bl);
  bool GetJoyInput(unsigned int key);
};

#endif
E:\Project\Kopia (5) VBEngine\Input\Input.h
#include <dinput.h>
#include <assert.h>

#include "..\utility\Misc.h"
#include "..\utility\Singleton.h"
#include "..\Utility\vbmath.h"
#include "..\Utility\defines.h"

#include "Mapper.h"

#include "Input.h"

Input::Input()
{	
	g_lpDI=NULL;
	devklawiatura=NULL; 
	devmysz=NULL;   
	devjoy=NULL;
	ZeroMemory(diks, sizeof(diks));
  ZeroMemory(diksold, sizeof(diks));
	ZeroMemory(diks_menu, sizeof(diks));

	ZeroMemory(&dims, sizeof(dims));
  ZeroMemory(&js,sizeof(js));
	this->mouse_x = 0;
	this->mouse_y = 0;
  this->total_mouse_x = this->total_mouse_y = 0.0f;
	this->wlaczonyl=FALSE;
	this->wlaczonyr=FALSE;
	this->wlaczl = FALSE;
	this->wlaczr = FALSE;

	this->mapping = new CMappingList();
	this->mouse_mapping = new CMappingList();
	

};

Input::~Input()
{

};

void Input::DeInit()
{
    if (g_lpDI) 
    { 
        if (devklawiatura) 
        { 
            devklawiatura->Unacquire(); 
            devklawiatura->Release();
            devklawiatura=NULL; 
        } 
        if (devmysz) 
        { 
            devmysz->Unacquire(); 
            devmysz->Release();
            devmysz=NULL; 
        } 
		if (devjoy)
		{
			devjoy->Unacquire();
			devjoy->Release();
			devjoy = NULL;
		}
        g_lpDI->Release();
        g_lpDI = NULL; 
    } 
	if (mapping) delete mapping;
	if (mouse_mapping) delete mouse_mapping;
}

BOOL CALLBACK Input::EnumJoysticksCallback(LPCDIDEVICEINSTANCE lpddi)
{
	HRESULT hr;
	hr = g_lpDI->CreateDevice( lpddi->guidInstance, &this->devjoy, NULL );
	if( FAILED(hr) ) 
        return DIENUM_CONTINUE;
	return DIENUM_STOP;
}

bool Input::EnumObjectsCallbak( const DIDEVICEOBJECTINSTANCE* pdidoi)
{	    
    if( pdidoi->dwType & DIDFT_AXIS )
    {
        DIPROPRANGE diprg; 
        diprg.diph.dwSize       = sizeof(DIPROPRANGE); 
        diprg.diph.dwHeaderSize = sizeof(DIPROPHEADER); 
        diprg.diph.dwHow        = DIPH_BYID; 
        diprg.diph.dwObj        = pdidoi->dwType; // Specify the enumerated axis
        diprg.lMin              = -1000; 
        diprg.lMax              = +1000; 
    
        // Set the range for the axis		

		if( FAILED(devjoy->SetProperty( DIPROP_RANGE, &diprg.diph ) ) )
			return DIENUM_STOP;
		//if( FAILED( devjoy->SetProperty( DIPROP_RANGE, &diprg.diph ) ) ) 
          //  return DIENUM_STOP;
         
    }
	return DIENUM_CONTINUE;
}

HRESULT Input::Init(HINSTANCE m_hInst,HWND m_hWndMain)
{
	HRESULT hr;
	hr = DirectInput8Create( m_hInst,DIRECTINPUT_VERSION,IID_IDirectInput8,(void**)&g_lpDI, NULL );
    if FAILED(hr) 
    { 
        return hr; 
    } 

	hr = g_lpDI->CreateDevice( GUID_SysKeyboard, &devklawiatura, NULL );
	if( FAILED(hr) )
	{
		this->DeInit();
		return hr;
	}

	hr = this->devklawiatura->SetDataFormat( &c_dfDIKeyboard );
	if( FAILED(hr) )
	{
		this->DeInit();
		return hr;
	}

	hr = this->devklawiatura->SetCooperativeLevel( m_hWndMain,DISCL_EXCLUSIVE | DISCL_FOREGROUND );
	if( FAILED(hr) )
	{
		this->DeInit();
		return hr;
	}
	
	hr = this->devklawiatura->Acquire(); 
    if FAILED(hr) 
    { 
//		this->DeInit();
//        return hr; 
    } 
 
	hr = g_lpDI->CreateDevice( GUID_SysMouse, &devmysz, NULL );
	if( FAILED(hr) )
	{
		return hr;
	}

    
	hr = this->devmysz->SetDataFormat( &c_dfDIMouse );
    if FAILED(hr) 
    { 
		this->DeInit();
        return hr; 
    } 


	hr = this->devmysz->SetCooperativeLevel( m_hWndMain, DISCL_EXCLUSIVE | DISCL_FOREGROUND);
    if FAILED(hr) 
    { 
		this->DeInit();
        return hr; 
    } 

///////////////////////////// joy /////////////////////////////////////////////
	hr = g_lpDI->EnumDevices( DI8DEVCLASS_GAMECTRL, 
										 Input::EnumJoysticksCallback,
                                         this, DIEDFL_ATTACHEDONLY );
    if (SUCCEEDED(hr))
	{
		if (this->devjoy!=NULL)
		{
			if( FAILED( hr = this->devjoy->SetDataFormat( &c_dfDIJoystick2 ) ) )
				return hr;
			if( FAILED( hr = devjoy->SetCooperativeLevel( m_hWndMain, DISCL_EXCLUSIVE | DISCL_FOREGROUND )))
				return hr;
			if( FAILED( hr = devjoy->EnumObjects( Input::EnumObjectsCallback, 
                                                (VOID*)this, DIDFT_ALL ) ) )
				return hr;
		}
	}

///////////////////////////////////////////////////////////////////////
	ZeroMemory(&this->diks,sizeof(this->diks));
	ZeroMemory(&this->diks_real,sizeof(this->diks_real));

	ZeroMemory(&this->diks_menu,sizeof(this->diks_menu));
	ZeroMemory(&this->diksold,sizeof(this->diksold));
	ZeroMemory(&this->dims,sizeof(this->dims));
	ZeroMemory(&this->dims_real,sizeof(this->dims_real));
	this->Map();
	return 1;
}

void Input::AddMap(int _real, int _mapped)
{
  this->mapping->Add(_real, _mapped);
}

bool Input::ChangeMap(int _real, int _mapped)
{
  return this->mapping->Change(_real, _mapped);
}

/*
\fn bool Input::ChangeMapForReal(int _real, int _mapped)

*/
bool Input::ChangeMapForReal(int _real, int _mapped)
{
  return this->mapping->ChangeForReal(_real, _mapped);
}

void Input::Map()
{
	// w grze ---  w kodzie

	mapping->Add(41, 41);		/// TYLDA;

/* stara camera 
	mapping->Add(DIK_T, DIK_T);
	mapping->Add(DIK_G, DIK_G);
	mapping->Add(DIK_F, DIK_F);
	mapping->Add(DIK_H, DIK_H);
	mapping->Add(DIK_Q, DIK_Q);
	mapping->Add(DIK_E, DIK_E);
*/

/* nowa camera */
 

  /* taktyki */
  mapping->Add(VBKEY_ESCAPE, VBKEY_ESCAPE);
  mapping->Add(VBKEY_Y, VBKEY_Y);
  mapping->Add(VBKEY_N, VBKEY_N);

 /* end : taktyki */

  mapping->Add(VBKEY_F1, VBKEY_F1);
  mapping->Add(VBKEY_F2, VBKEY_F2);
  mapping->Add(VBKEY_F3, VBKEY_F3);
  mapping->Add(VBKEY_F4, VBKEY_F4);
  mapping->Add(VBKEY_RETURN, VBKEY_RETURN);

#if defined(DEBUG) || defined(DEMO)
  mapping->Add(VBKEY_F6, VBKEY_F6);
  mapping->Add(VBKEY_F7, VBKEY_F7);
  mapping->Add(VBKEY_F12, VBKEY_F12);
#endif

// kamera lukasza
  mapping->Add(DIK_INSERT, DIK_INSERT);
	mapping->Add(DIK_DELETE, DIK_DELETE);
	mapping->Add(DIK_HOME, DIK_HOME);
	mapping->Add(DIK_END, DIK_END);
	mapping->Add(DIK_NEXT, DIK_NEXT);
	mapping->Add(DIK_PRIOR , DIK_PRIOR);
#ifdef DEBUG
	mapping->Add(VBKEY_A, VBKEY_A);
	mapping->Add(VBKEY_W, VBKEY_W);
	mapping->Add(VBKEY_S, VBKEY_S);
	mapping->Add(VBKEY_D, VBKEY_D);
	mapping->Add(VBKEY_C, VBKEY_C);
	mapping->Add(VBKEY_X, VBKEY_X);
  mapping->Add(VBKEY_Q, VBKEY_Q);
// kamera lukasza

  mapping->Add(VBKEY_E, VBKEY_E);
  mapping->Add(VBKEY_R, VBKEY_R);
  mapping->Add(VBKEY_T, VBKEY_T);

#endif
  

/*
// klawisze na chwile
	mapping->Add(DIK_NUMPAD0, DIK_NUMPAD0);
	mapping->Add(DIK_NUMPAD1, DIK_NUMPAD1);
	mapping->Add(DIK_NUMPAD2, DIK_NUMPAD2);
	mapping->Add(DIK_NUMPAD3, DIK_NUMPAD3);
// klawisze na chwile
*/
/*
	mapping->Add(DIK_NUMPAD5, DIK_NUMPAD5);
	mapping->Add(DIK_NUMPAD4, DIK_NUMPAD4);
	mapping->Add(DIK_NUMPAD6, DIK_NUMPAD6);
	mapping->Add(DIK_NUMPAD7, DIK_NUMPAD7);
	mapping->Add(DIK_NUMPAD8, DIK_NUMPAD8);
	mapping->Add(DIK_NUMPAD9, DIK_NUMPAD9);
	mapping->Add(DIK_LEFT, DIK_LEFT);
	mapping->Add(DIK_RIGHT, DIK_RIGHT);
	mapping->Add(DIK_DOWN, DIK_DOWN);
	mapping->Add(DIK_UP, DIK_UP);
  mapping->Add(DIK_SPACE, DIK_SPACE);
	mapping->Add(DIK_RETURN, DIK_RETURN);
	mapping->Add(DIK_F12, DIK_F12);
	mapping->Add(DIK_LMENU, DIK_LMENU);
  mapping->Add(DIK_LSHIFT, DIK_LSHIFT);
*/

	if (this->devjoy!=NULL)
	{
		this->mouse_mapping->Add(J_X_LEFT, M_X);
		this->mouse_mapping->Add(J_Y_UP, M_Y);
	} else {
		this->mouse_mapping->Add(M_X, M_X);
		this->mouse_mapping->Add(M_Y, M_Y);
	}
	
	this->mouse_mapping->Add(M_MX, M_MX);
	this->mouse_mapping->Add(M_MY, M_MY);

	this->mouse_mapping->Add(M_1, M_1);
	this->mouse_mapping->Add(M_2, M_2);	

	if (this->devjoy!=NULL)
	{
		this->mouse_mapping->Add(J_RGB5, M_RGB1);
		this->mouse_mapping->Add(J_RGB6, M_RGB2);
		
    /* camera  - Mapowanie z dupy ... trza porawic po podpieciu jakiegos yoja */
#if 0
		this->mapping->Add(J_LRZ_LEFT, DIK_INSERT);
		this->mapping->Add(J_LRZ_RIGTH, DIK_DELETE);
		this->mapping->Add(J_SLIDER0_L, DIK_NEXT);
		this->mapping->Add(J_SLIDER0_R, DIK_PRIOR);
#endif
	} else {
		this->mouse_mapping->Add(M_RGB1, M_RGB1);
		this->mouse_mapping->Add(M_RGB2, M_RGB2);
	}
}

void Input::TranslateState()
{	
	this->mapping->Translate(this->diks_real, this->diksold, diks, diks_menu, this->js);	
	this->mouse_mapping->TranslateMouse(dims_real, this->js, &dims);
  this->old_wlaczonyl = wlaczonyl;
  this->old_wlaczonyr = wlaczonyr;
	this->wlaczonyl = (bool)(dims.mButtons[0] != 0);
	this->wlaczonyr = (bool)(dims.mButtons[1] != 0);	
	this->wlaczl = (bool)(dims.rgbButtons[0] != 0);
	this->wlaczr = (bool)(dims.rgbButtons[1] != 0);
	this->mouse_x = dims.MX;
	this->mouse_y = dims.MY;
  this->total_mouse_x += mouse_x *1.5f;
  this->total_mouse_y += mouse_y *1.5f;
  if (total_mouse_x > 1024.0f) total_mouse_x = 1024.0f;
  if (total_mouse_x < 0.0f) total_mouse_x = 0.0f;
  if (total_mouse_y > 768.0f) total_mouse_y = 768.0f;
  if (total_mouse_y < 0.0f) total_mouse_y = 0.0f;
}



HRESULT Input::ChangeMappingKeyboard(int _old)
{
	GetAllDataToObject();
	for (int t=0; t<256; t++)
	{
		if (diks_real[t]) mapping->Change(_old, t);
	}
	return S_OK;
}

int Input::GetCh()
{
	GetAllDataToObject();
	for (int t=0; t<256; t++)
	{
		if (diks_real[t]) return t;
	}
	return 0;
}

HRESULT Input::GetAllDataToObject()
{	
  if (this->acquired)
	{
		if(this->devjoy)
		{
			HRESULT hr;
			hr = devjoy->Poll(); 
			if( FAILED(hr) )  
      {
			  do
        {
				  hr = devjoy->Acquire();
			  }
        while( hr == DIERR_INPUTLOST || hr == E_ACCESSDENIED) ;
      }
			if(FAILED(hr))return hr;

			if( FAILED( hr = devjoy->GetDeviceState( sizeof(DIJOYSTATE2), &js ) ) )
				return hr;
		}
		if((devklawiatura)&&(devmysz))
		{
			HRESULT hr;

			memcpy(this->diksold, this->diks, sizeof(diks));
			hr = devklawiatura->GetDeviceState( sizeof(diks_real), &diks_real );
			if( FAILED(hr) )  
			{			
				do
				{
					hr = devklawiatura->Acquire();			
				}
				while( hr == DIERR_INPUTLOST || hr == E_ACCESSDENIED) ;
				ZeroMemory(&this->dims_real,sizeof(this->dims_real));
				if(FAILED(hr))return hr;
			}	

			hr = devmysz->GetDeviceState( sizeof(DIMOUSESTATE), &dims_real );
			if( FAILED(hr) )  
			{			
        do {
					hr = devmysz->Acquire();				
				} while( hr == DIERR_INPUTLOST || hr == E_ACCESSDENIED) ;
				if(FAILED(hr))return hr;
				memset(&this->dims_real, 0, sizeof(this->dims_real));
				return hr;
			}
		
      this->TranslateState();						
/*
      for(int i=0;i<256;i++)
  		{
	  		this->zmiana[i]=(this->diks[i]&128)^(this->diksold[i]&128);
		  }
*/
		}
	}

	return 0;

}


void Input::SetAquire(bool bl)
{
  this->acquired = bl; 
	if ((this->devmysz)&&(this->devklawiatura))
	{
		if (bl)
		{		
			this->devklawiatura->Acquire();
			this->devmysz->Acquire();
		} 
    else 
    {
			this->devklawiatura->Unacquire();
			this->devmysz->Unacquire();
		}
	}
}

bool Input::GetJoyInput(unsigned int joy_inp)
{
  return (this->mapping->GetDimsJoy(this->js,joy_inp,false) != 0.0f);
}
E:\Project\Kopia (5) VBEngine\Input\Input.cpp
#ifndef _VIDEOTEXTURE_H
#define _VIDEOTEXTURE_H





class VideoTextureRenderer;

class VideoTexture :public CTexture
{
public:
  VideoTexture(bool silent = true,unsigned long stopEventTarget = 0,unsigned long stopEventID = 0,bool looping = true);
  ~VideoTexture();
  HRESULT Load(LPDIRECT3DDEVICE9 m_device);
  void CheckMovie();
  void UnLoad();
  void Touch();
  
private:  
  IGraphBuilder   *mGraphBuilder;
  IMediaControl   *mMediaControl;
  IMediaPosition  *mMediaPosition;
  IMediaEvent     *mMediaEvent;
  VideoTextureRenderer *mTextureRenderer;
  bool             mSilent;
  bool             mLooping;
  unsigned long    mEventID;
  unsigned long    mEventTarget;
  bool mPlaying;
};

#endif /* _CMESH */
E:\Project\Kopia (5) VBEngine\Graphics\VideoTexture.h
#include "..\config.h"
#include <assert.h>
#include "..\utility\defines.h"
#include "..\utility\misc.h"
#include "..\utility\singleton.h"
#include "..\utility\vbmath.h"
#include "..\utility\tools.h"
#include "..\utility\Logger.h"
#include "..\utility\CTime.h"
#include "..\utility\Tools.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"

#include <d3dx9effect.h>

#include <crtdbg.h>
#include <atlconv.h>
#include "renderer.h"
#include "Camera.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "meshmanager.h"
#include "SceneObject.h"
#include "SceneManager.h"


#include "..\Core\Ball.h"

#include "DShowBase\streams.h"

#include "VideoTexture.h"

// klasa praktycznie skopiowana z przyk³adów Direct Show
// obs³uguje rendering do tekstury  pliku wideo

struct __declspec(uuid("{71771540-2017-11cf-ae26-0020afd79767}")) CLSID_TextureRenderer;
class VideoTextureRenderer : public CBaseVideoRenderer
{
public:
  VideoTextureRenderer(LPUNKNOWN pUnk,HRESULT *phr, bool silent = true);
  ~VideoTextureRenderer();
  void CheckMovie(); // sprawdŸ czy sie film nie urwa³ ;)
  HRESULT CheckMediaType(const CMediaType *pmt );     // Format acceptable?
  HRESULT SetMediaType(const CMediaType *pmt );       // Video format notification
  HRESULT DoRenderSample(IMediaSample *pMediaSample); // New video sample
  // ustaw docelow¹ teksture dla danego renderera
  void SetTargetTexture(LPDIRECT3DTEXTURE9 *target_tex ) {this->mTargetTexture = target_tex;}
private:
  BOOL m_bUseDynamicTextures;
  LONG m_lVidWidth;   // Video width
  LONG m_lVidHeight;  // Video Height
  LONG m_TexWidth;
  LONG m_TexHeight;
  LONG m_lVidPitch;   // Video Pitch
  D3DFORMAT        mTextureFormat;
  LPDIRECT3DTEXTURE9 mWorkTexture;
  LPDIRECT3DTEXTURE9 *mTargetTexture;
  bool             mSilent;

};




VideoTextureRenderer::VideoTextureRenderer(LPUNKNOWN pUnk,HRESULT *phr,bool silent)
                                  : CBaseVideoRenderer(__uuidof(CLSID_TextureRenderer), 
                                    NAME("Texture Renderer"), pUnk, phr),
                                    mSilent(silent)
                                  
{


}

VideoTexture::VideoTexture(bool silent,unsigned long stopEventTarget,unsigned long stopEventID,bool looping)
                                  : mSilent(silent),
                                    mEventTarget(stopEventTarget),
                                    mEventID(stopEventID),
                                    mLooping(looping)
{
    // Store and AddRef the texture for our use.
    mTextureRenderer = NULL;
    this->mPlaying = false;
}

VideoTexture::~VideoTexture()
{
  int i;
  i = this->mMediaEvent->Release(); 
  i = this->mMediaPosition->Release();
  i = this->mMediaControl->Release();
  i = this->mGraphBuilder->Release(); 
}
//-----------------------------------------------------------------------------
// CTextureRenderer destructor
//-----------------------------------------------------------------------------
VideoTextureRenderer::~VideoTextureRenderer()
{
   this->mWorkTexture->Release();
}


// Load odziedziczony ze zwyk³ego Texture
HRESULT VideoTexture::Load(LPDIRECT3DDEVICE9 m_device)
{
  if (mPlaying) // jeœli nadal gra - sprawdŸ film i zwróæ okej
  {
    CheckMovie();
    return S_OK;
  }
 if (is_loaded) return S_OK; // jeœli jest ju¿ wczytane te¿ zwróæ okej
    
    HRESULT hr = S_OK;
    IBaseFilter   *SourceFilter   ;       // Source Filter
    IPin          *SourceFilterOutput;    // Source Filter Output Pin   
           // DirectShow Texture renderer
    
    // Create the filter graph
    if (FAILED( hr = CoCreateInstance(CLSID_FilterGraph, NULL, CLSCTX_INPROC,IID_IGraphBuilder,(void**)&this->mGraphBuilder)))
        return hr;

    
  
    if (FAILED(hr))
    {
        return hr;
    }

    
    this->mTextureRenderer = new VideoTextureRenderer(NULL,&hr,mSilent);
    this->mTextureRenderer->SetTargetTexture(&this->tex);
    // Get a pointer to the IBaseFilter on the TextureRenderer, add it to graph
    if (FAILED(hr = this->mGraphBuilder->AddFilter(mTextureRenderer, L"TEXTURERENDERER")))
    {
       
        return hr;
    }
    

    wchar_t nm[256];
    mbstowcs(nm,name,256);

    // Add the source filter to the graph.
    hr = this->mGraphBuilder->AddSourceFilter (nm, L"SOURCE", &SourceFilter);
    if (FAILED(hr))
    {
      return hr;
    }


    if (FAILED(hr = SourceFilter->FindPin(L"Output", &SourceFilterOutput)))
    {
        return hr;
    }
if (false)//mSilent) // to nie dzia³a - ale chyba tego sie mo¿na domyœliæ, co nie?
{
    // If no audio component is desired, directly connect the two video pins
    // instead of allowing the Filter Graph Manager to render all pins.
    IPin* InPin;      // Texture Renderer Input Pin

    // Find the source's output pin and the renderer's input pin
    if (FAILED(hr = SourceFilter->FindPin(L"In", &InPin)))
    {
        
        return hr;
    }

    // Connect these two filters
    if (FAILED(hr = mGraphBuilder->Connect(SourceFilterOutput, InPin)))
    {
        LogError("VIDEOTEXTURE [%s]:Could not connect pins!  hr=0x%x",this->name, hr);
        return hr;
    }

}
else
{
    // Render the source filter's output pin.  The Filter Graph Manager
    // will connect the video stream to the loaded CTextureRenderer
    // and will load and connect an audio renderer (if needed).

    if (FAILED(hr = this->mGraphBuilder->Render(SourceFilterOutput)))
    {
        return hr;
    }
}
    int i = SourceFilterOutput->Release();  
    i = SourceFilter->Release();
    // Get the graph's media control, event & position interfaces
    
    this->mGraphBuilder->QueryInterface(&this->mMediaControl);
    this->mGraphBuilder->QueryInterface(&this->mMediaPosition);
    this->mGraphBuilder->QueryInterface(&this->mMediaEvent);
    
   
    this->is_loaded = true;
    return S_OK;


}
//-----------------------------------------------------------------------------
// CheckMediaType: This method forces the graph to give us an R8G8B8 video
// type, making our copy to texture memory trivial.
//-----------------------------------------------------------------------------
HRESULT VideoTextureRenderer::CheckMediaType(const CMediaType *pmt)
{
    HRESULT   hr = E_FAIL;
    VIDEOINFO *pvi=0;
    
    CheckPointer(pmt,E_POINTER);

    // Reject the connection if this is not a video type
    if( *pmt->FormatType() != FORMAT_VideoInfo ) {
        return E_INVALIDARG;
    }
    
    // Only accept RGB24 video
    pvi = (VIDEOINFO *)pmt->Format();

    if(IsEqualGUID( *pmt->Type(),    MEDIATYPE_Video)  &&
       IsEqualGUID( *pmt->Subtype(), MEDIASUBTYPE_RGB24))
    {
        hr = S_OK;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// SetMediaType: Graph connection has been made. 
//-----------------------------------------------------------------------------
HRESULT VideoTextureRenderer::SetMediaType(const CMediaType *pmt)
{
    HRESULT hr;

     m_TexWidth = 2;
    m_TexHeight = 2;

    // Retrive the size of this media type
    D3DCAPS9 caps;
    VIDEOINFO *pviBmp;                      // Bitmap info header
    pviBmp = (VIDEOINFO *)pmt->Format();

    m_lVidWidth  = pviBmp->bmiHeader.biWidth;
    m_lVidHeight = IABS(pviBmp->bmiHeader.biHeight);
    m_lVidPitch  = (m_lVidWidth * 3 + 3) & ~(3); // We are forcing RGB24

    ZeroMemory( &caps, sizeof(D3DCAPS9));
    hr = Renderer::Instance()->GetDevice()->GetDeviceCaps( &caps );
  
   
    while( (LONG)m_TexWidth < m_lVidWidth )
    {
        m_TexWidth = m_TexWidth << 1;
    }
    while( (LONG)m_TexHeight < m_lVidHeight )
    {
        m_TexHeight = m_TexHeight << 1;
    }


    // Create the texture that maps to this media type
    hr = E_UNEXPECTED;
    {
        hr = Renderer::Instance()->GetDevice()->CreateTexture(m_TexWidth, m_TexHeight, 1, 0, 
                                                D3DFMT_X8R8G8B8,D3DPOOL_MANAGED,
                                                this->mTargetTexture, NULL);
        hr = Renderer::Instance()->GetDevice()->CreateTexture(m_TexWidth, m_TexHeight, 1, 0, 
                                                D3DFMT_X8R8G8B8,D3DPOOL_MANAGED,
                                                &this->mWorkTexture, NULL);
    }
    

    // CreateTexture can silently change the parameters on us
    D3DSURFACE_DESC ddsd;
    ZeroMemory(&ddsd, sizeof(ddsd));

    if ( FAILED( hr = this->mWorkTexture->GetLevelDesc( 0, &ddsd ) ) ) {
        
        return hr;
    }

    IDirect3DSurface9 *pSurf; 

    if (SUCCEEDED(hr = this->mWorkTexture->GetSurfaceLevel(0, &pSurf)))
        pSurf->GetDesc(&ddsd);

    // Save format info
    mTextureFormat = ddsd.Format;
    return S_OK;
}


//-----------------------------------------------------------------------------
// DoRenderSample: A sample has been delivered. Copy it to the texture.
//-----------------------------------------------------------------------------
HRESULT VideoTextureRenderer::DoRenderSample( IMediaSample * pSample )
{
    BYTE  *pBmpBuffer, *pTxtBuffer; // Bitmap buffer, texture buffer
    LONG  lTxtPitch;                // Pitch of bitmap, texture

    

    BYTE  * pbS = NULL;
    DWORD * pdwS = NULL;
    DWORD * pdwD = NULL;
    UINT row, col, dwordWidth;
    
    CheckPointer(pSample,E_POINTER);
    CheckPointer(*this->mTargetTexture,E_UNEXPECTED);
    CheckPointer(this->mWorkTexture,E_UNEXPECTED);

    // Get the video bitmap buffer
    pSample->GetPointer( &pBmpBuffer );

    // Lock the Texture
    D3DLOCKED_RECT d3dlr;
    if (FAILED(this->mWorkTexture->LockRect(0, &d3dlr, 0, 0)))
       return E_FAIL;
    
       
    // Get the texture buffer & pitch
    pTxtBuffer = static_cast<byte *>(d3dlr.pBits);
    lTxtPitch = d3dlr.Pitch;
    
    
    // Copy the bits    

    if (mTextureFormat == D3DFMT_X8R8G8B8) 
    {
        // Instead of copying data bytewise, we use DWORD alignment here.
        // We also unroll loop by copying 4 pixels at once.
        //
        // original BYTE array is [b0][g0][r0][b1][g1][r1][b2][g2][r2][b3][g3][r3]
        //
        // aligned DWORD array is     [b1 r0 g0 b0][g2 b2 r1 g1][r3 g3 b3 r2]
        //
        // We want to transform it to [ff r0 g0 b0][ff r1 g1 b1][ff r2 g2 b2][ff r3 b3 g3]
        // below, bitwise operations do exactly this.

        dwordWidth = m_lVidWidth / 4; // aligned width of the row, in DWORDS
                                      // (pixel by 3 bytes over sizeof(DWORD))

        for( row = 0; row< (UINT)m_lVidHeight; row++)
        {
            pdwS = ( DWORD*)pBmpBuffer;
            pdwD = ( DWORD*)pTxtBuffer;

            for( col = 0; col < dwordWidth; col ++ )
            {
                pdwD[0] =  pdwS[0] | 0xFF000000;
                pdwD[1] = ((pdwS[1]<<8)  | 0xFF000000) | (pdwS[0]>>24);
                pdwD[2] = ((pdwS[2]<<16) | 0xFF000000) | (pdwS[1]>>16);
                pdwD[3] = 0xFF000000 | (pdwS[2]>>8);
                pdwD +=4;
                pdwS +=3;
            }

            // we might have remaining (misaligned) bytes here
            pbS = (BYTE*) pdwS;
            for( col = 0; col < (UINT)m_lVidWidth % 4; col++)
            {
                *pdwD = 0xFF000000     |
                        (pbS[2] << 16) |
                        (pbS[1] <<  8) |
                        (pbS[0]);
                pdwD++;
                pbS += 3;           
            }

            pBmpBuffer  += m_lVidPitch;
            pTxtBuffer += lTxtPitch;
        }// for rows
    }

    // Unlock the Texture
    if (FAILED(this->mWorkTexture->UnlockRect(0)))
        return E_FAIL;

    // jeœli wszystko posz³o zgodnie z planem zamieñ teksture na której pisaliœmy z tekstur¹ docelow¹
    // zmniejsza opóŸnienia zwi¹zane z tym ¿ê to inny thread pisze po teksturze
    LPDIRECT3DTEXTURE9 temp;
    temp = *this->mTargetTexture; 
    *this->mTargetTexture = mWorkTexture;
    this->mWorkTexture = temp;
    
    return S_OK;
}

void VideoTexture::CheckMovie()
{
 long lEventCode;
    long lParam1;
    long lParam2;
    HRESULT hr = S_OK;


       
    // Check for completion events
     hr = this->mMediaEvent->GetEvent(&lEventCode, (LONG_PTR *) &lParam1, (LONG_PTR *) &lParam2, 0);
    if (SUCCEEDED(hr))
    {
        // If we have reached the end of the media file, reset to beginning
        
        if (EC_COMPLETE == lEventCode) 
        {
          if(this->mLooping)
          {
            hr = this->mMediaPosition->put_CurrentPosition(0);
          }
          else
          {
            POST_EVENT(mEventTarget,mEventID,false,NULL);
          }
        }

        // Free any memory associated with this event
        hr = mMediaEvent->FreeEventParams(lEventCode, lParam1, lParam2);
    }
    
}


void VideoTexture::UnLoad()
{ // zatrzymaj tylko - wy³adownie nastêpuje w destruktorze 
  if (!mPlaying ) return;
  this->mMediaPosition->put_CurrentPosition(0);
  this->mMediaControl->Stop();
  this->mPlaying = false;
}

//funkcja puszczaj¹ca wideo 
void VideoTexture::Touch()
{
  if(mPlaying)
  {
    return;
  }
  // wczytaj jeœli nie jest wczytane
  if (!is_loaded) Load(Renderer::Instance()->GetDevice());
  mMediaControl->Run();
  mPlaying = true;
}
E:\Project\Kopia (5) VBEngine\Graphics\VideoTexture.cpp
#ifndef _TEXTURE_MANAGER_H
#define _TEXTURE_MANAGER_H

/*
class       : CTextureManager
description : Zazadza plikami textur poprzez tablice wskazników na classe CTexture.
              Twozy tablice wskazników na Textury i stopniowo zapełnia pola wraz z dodawaniem nowych
              elementów. Jesli ilosc ellemntów przekroczy "Max_Texture_Count" do powiękrzamy
              rozmiar tablicy o 50%.
methods     :
              CTextureManager()      - konstruktor
	            ~CTextureManager(void) - destruktor
              GetTextureHandler(...) - Szuka wpisu w tablicy i jesli nie znajdzie to
                                       allokuje nowa CTexture w tablicy (jesli jest miesce) lub
                                       najpierw powieksza tablice
              GetVideoTextureHandler(...) - Szuka wpisu w tablicy i jesli nie znajdzie to
                                            allokuje nowa VideoTexture w tablicy (jesli jest miesce) lub
                                            najpierw powieksza tablice
              GetTexture(...)        - pobranie CTexture (moze zwrucic NULL)
              CleanList()            - wyładowywuje textury z calej tablicy (sprawdza flage cleanable).
              SetTextureLevel(...)   - zmienia aktualny poziom textur
              UnloadTexture(hd)      - wyladowanie textury o podenym handleze
              UnloadTexture(name)    - wyladowanie textury o podanej nazwie
              Reload();              - zaladowanie wszystkich textur , które tego wymagaja (NeedReload)
              PreReload()            - wyladowanie wszystkich textur i wypelnienie tablicy NeedReload
                                       dla funkcji ReLoad
              Reset(...)             - zmiana aktualnego poziomu textur wraz z ich przeladowaniem.
*/

class CTexture;

#define DEFAULT_TEXTURE 0

class CTextureManager
{
  unsigned int curretn_level;                  /* obecny poziom dokladnosci textur */
  CTexture **pTexturesTab;                     /* tablica textur */
  bool *NeedReload;                            /* tablica textur wymagajaca preladowania w
                                                  funkcji Reload, wypelniana przez PreReload() */
  unsigned int Max_Texture_Count;              /* rozmiar tablicy (wraz z pustymi polami) */
public:
  CTextureManager(void);
	~CTextureManager(void);
  bool HasTexture(HTexture hd) {return (hd < this->Max_Texture_Count && this->pTexturesTab[hd]);};
  HTexture GetTextureHandler(const char *name);
  HTexture GetVideoTextureHandler(const char *name,bool silent = true, unsigned long stopEventTarget = 0,unsigned long stopEventID = 0,bool looping = true);
  CTexture * GetTexture(HTexture hd);
  void CleanList(void);
  void SetTextureLevel(int level);
  void UnloadTexture(HTexture hd);
  void UnloadTexture(char *name);
  void Reload(void);
  int PreReload(void);
  void Reset(int level);
};

#endif /* _TEXTURE_MANAGER_H */
E:\Project\Kopia (5) VBEngine\Graphics\TextureManager.h
#include "..\config.h"

#include <d3d9.h>
#include <assert.h>

#include "DShowBase\streams.h"

#include "..\Utility\Defines.h"
#include "..\Utility\logger.h"

#include "Renderer.h"
#include "Texture.h"
#include "VideoTexture.h"
#include "TextureManager.h"

#include "..\Utility\misc.h"
#include "..\Utility\ctime.h"
#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"
#include "GUI.h"

#include "..\core\SetupManager.h"

/* Konstuktor */
CTextureManager::CTextureManager(void)
{
  curretn_level = SetupManager::Instance()->GetVideo()->texture_level;
  this->Max_Texture_Count = 10;
  this->pTexturesTab = (CTexture **)calloc(this->Max_Texture_Count, sizeof(CTexture *));
  this->NeedReload = (bool *)calloc(this->Max_Texture_Count, sizeof(bool));
  GetTextureHandler("whitetxr.png");/* init 0 element of manager */
}  /* end of : Konstruktor */

/* Dekonstuktor: czysci pamieæ */
CTextureManager::~CTextureManager(void)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    delete this->pTexturesTab[hd];
    this->pTexturesTab[hd++] = NULL;
  }
  free(this->pTexturesTab);
  free(this->NeedReload);
} /* end of : DeKonstruktor */

/*
 * Pobranie wskaznika na CTexture z tablicy.
 *
 * Moze zwrucic NULL w 2 przypadkach :
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy 
 */
CTexture * CTextureManager::GetTexture(HTexture hd)
{
  if(this->HasTexture(hd))
  {
    return this->pTexturesTab[hd];
  }
  return NULL;
} /* end of : GetTexture */

/*
 * Pobranie (nowego) handlera do Textury o podanej nazwie
 * 
 * Jesli nie posiadamy jeszcze danej textury to nowy element jest dodawany do tablicy
 * Textur (ale nie laduje go)
 */
HTexture CTextureManager::GetTextureHandler(const char *name)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    /* szuka istniej¹cej Textury w tablicy */
    if(this->pTexturesTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  /*
   * Sprawdza czy nie przekroczylismy dopuszczalnej wielkosci tablicy
   * Jesli tak to realocujemy cala tablice po czym czyscimy nowe ellementy.
   */
  if(hd >= this->Max_Texture_Count)
  {
    unsigned int i = this->Max_Texture_Count;
    this->Max_Texture_Count += this->Max_Texture_Count / 2;
    this->pTexturesTab = (CTexture **)realloc(this->pTexturesTab,
                                        this->Max_Texture_Count * sizeof(CTexture *));
    this->NeedReload = (bool *)realloc(this->NeedReload,
                                        this->Max_Texture_Count * sizeof(bool));
    /* czusci nowe elementy */
    while(i < this->Max_Texture_Count)
    {
      this->NeedReload[i] = false;
      this->pTexturesTab[i++] = NULL;
    }
  }

  /* dodanie nowego elementu do tablicy */
  this->pTexturesTab[hd] = new CTexture();
  this->pTexturesTab[hd]->Init(name);
  this->pTexturesTab[hd]->SetTextureLevel(curretn_level);
  
  return hd;
} /* end of : GetTextureHandler */

/*
 * Wyladowanie Textury o podanym handlerze.
 * Sprawdzenie flagi clenable dobywa sie w CTexture.
 */
void CTextureManager::UnloadTexture(HTexture hd)
{
  if(this->HasTexture(hd))
  {
    this->pTexturesTab[hd]->UnLoad();
  }
} /* end of : UnloadTexture */

/*
 * Wyladowanie Textury o podanej nazwie.
 * Funcjiw wyszukuje w tablicy podanej nazwy nastepnie wywoluje UnloadTexture(hd) z znalezionym handlerem.
 * Sprawdzenie flagi clenable dobywa sie w CTexture.
 */
void CTextureManager::UnloadTexture(char *name)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    if(this->pTexturesTab[hd]->Cmp(name))
    {
      this->UnloadTexture(hd);
      return;
    }
    hd++;
  }
  DIE(hd < this->Max_Texture_Count && "Pruba wyladowania nie istniejacej Taxtury !!");
} /* end of : UnloadTexture name */

/*
 * Wy³adowywyje textury z ca³ej tablicy zgodnie z stanem flagi cleanable.
 */
void CTextureManager::CleanList(void)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    this->pTexturesTab[hd++]->UnLoad();
  }
} /* end of : CleanList */

/*
 * Wymusza wy³adowanie zaladowanych textur z ca³ej tablicy (ignoruje cleanable).
 * Zapamietuje je w tablicy NeedReload w celu puzniejszego zaladowania.
 * Funcja zwraca ilosc wyladowanych textur co jest pomocne dla paska zawansowania ladowania.
 */
int CTextureManager::PreReload(void)
{
  int count = 0;
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    this->NeedReload[hd] = false;
    if(this->pTexturesTab[hd]->IsLoaded())
    {
      this->pTexturesTab[hd]->UnLoadFull();
      this->NeedReload[hd] = true;
      count++;
    }
    hd++;
  }
  return count;
} /* end of : PreReload */

/*
 * Wymusza zaladowanie textur oznaczonych w tablicy NeedReload.
 */
void CTextureManager::Reload(void)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    if(this->NeedReload[hd])
    {
      this->pTexturesTab[hd]->Load(Renderer::Instance()->GetDevice());
    }
    hd++;
  }
} /* end of : Reload */

/*
 * Ustawia nowy posiom dokladnsci textur oraz przeladowywuje textury z nowym poziomem.
 */
void CTextureManager::Reset(int level)
{
  POST_EVENT2(ET_GUI, GUIE_SET_LOAD_COUNT, PreReload(), true, NULL);
  SetTextureLevel(level);
  Reload();
} /* end of : Reset */

/*
 * Ustawia nowy posiom dokladnsci textur.
 */
void CTextureManager::SetTextureLevel(int level)
{
  HTexture hd = 0;
  curretn_level = (unsigned int)level;
  while(this->HasTexture(hd))
  {
    this->pTexturesTab[hd++]->SetTextureLevel(level);
  }
} /* end of : Reset */

/*
 * Pobranie (nowego) handlera do VideoTextury o podanej nazwie
 * 
 * Jesli nie posiadamy jeszcze danej videotextury to nowy element jest dodawany do tablicy
 * Textur (ale nie laduje go)
 */
HTexture CTextureManager::GetVideoTextureHandler(const char *name,bool silent, unsigned long stopEventTarget,unsigned long stopEventID,bool looping)
{
  HTexture hd = 0;
  while(this->HasTexture(hd))
  {
    if(this->pTexturesTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  if(hd >= this->Max_Texture_Count)
  {
    unsigned int i = this->Max_Texture_Count;
    this->Max_Texture_Count += this->Max_Texture_Count / 2;
    this->pTexturesTab = (CTexture **)realloc(this->pTexturesTab,
                                        this->Max_Texture_Count * sizeof(CTexture *));
    this->NeedReload = (bool *)realloc(this->NeedReload,
                                        this->Max_Texture_Count * sizeof(bool));

    /* czusci nowe elementy */
    while(i < this->Max_Texture_Count)
    {
      this->NeedReload[i] = false;
      this->pTexturesTab[i++] = NULL;
    }
  }

  /* dodanie nowego elementu do tablicy */
  this->pTexturesTab[hd] = new VideoTexture(silent,stopEventTarget,stopEventID,looping);
  this->pTexturesTab[hd]->Init(name);
  
  return hd;
}
E:\Project\Kopia (5) VBEngine\Graphics\TextureManager.cpp
#ifndef _TEXTURE_H
#define _TEXTURE_H

/*
class       : CTexture
description : Klasa Textury obslugjaca podstawowe czynnosci (ladowanie, wyladowanie , etc.).
              Dodatkowo zapewniony jest mechanizm "linkowania" danej textury  do innej ...
              np:
                Model zawodnika posiada texture "Koszulka" co daje nam jedš koszulke dla
                wszystkich druzyn. Mechanizm "linkowania" pozwala podpinac pod nazwe "Koszulka"
                inne textury w zaleznosci od przynaleznosci do danej druzyny.

              Dodatkowo psiadamy 3 poziomy dokladnosci textur niski, sredni, wysoki.
              np. Dla koszulek : niski (128x128), sredni (256x256), wysoki (512x512)

methods     :
            CTexture()       - konstruktor
	          ~CTexture()      - destruktor
            IsClinable()     - zwraca status blokady textury
            SetClinable(...) - ustawia/zwalnia blokade textury
	          Init(...)        - kopiuje nazwe pliku z textura do wlasnego buffora
            Link(...)        - "podpina" inna texture do tej textury
            UnLink()         - resetuje "pdpięcie"
	          Cmp(...)         - porównanie szukaneej nazwy pliku z textura z naszym bufforem nazwy.
	          IsLoaded()       - zwraca status zaladowania textury
	          Load(...)        - Ładuje texture z pliku (ustawionego przez Init(...))
            UnLoad()         - wyładowywuje texture (sprawdza clinable).
            UnLoadFull()     - wyładowywuje texture (nie sprawdza clinable).
	          SetTexture(...)  - Ustawia dana textre na podanym "stage-u"
            GetDXTexture()   - Zwraca wskaznik na Direxowa texture. (TA ZABAWKA NIE WYUMUSZA ŁADOWANIA !!!)
            SetTextureLevel(...) - ustawia globalny poziom dokladnosci textur.
*/

struct Verts;

class CTexture
{
protected:
  int current_level;              /* aktualny poziom dokladnosci textury */
  bool is_loaded;                 /* status zaladowania textury */
  bool is_clinable;               /* status blokady textury w TM (zapobiega automatycznemy wyładowaniu)*/
  char name[MAX_FILE_NAME];       /* nazwa pliku z texturš */
	CTexture *pLink;                /* "Link" do prawdziwej textury */
	LPDIRECT3DTEXTURE9 tex;         /* Textura */ 
  LPDIRECT3DDEVICE9 pdevice;       /* device */

  /* ustawia vertexy do renderowania do textury (generacjia koszulek) */
  void SetVertPositions( Verts * v, float x, float y, float width, float height, 
                        float u0, float v0, float u1, float v1, bool flipOnY, 
                        bool flipV,  /*na y-grekach*/
                        bool flipU); /*na x-ach*/

  /* Generacja koszulek */
  HRESULT DrawSpecialTexture(HTexture baseTextureHandle, char *playerName, int number, char *color);

public:
  CTexture(void);
	virtual ~CTexture(void);
  bool IsClinable(void) {return this->is_clinable;};
  void SetClinable(bool mode) {this->is_clinable = mode;};
	void Init(const char *filename);
  void Link(CTexture *_link) {this->pLink = _link;};
  void UnLink(void) {this->pLink = NULL;};
	bool Cmp(const char *_name);
  bool IsLoaded() {return pLink ? pLink->IsLoaded() : this->is_loaded;};
	virtual HRESULT Load(LPDIRECT3DDEVICE9 m_device);
  virtual void UnLoad(void);
  void UnLoadFull(void);
  virtual void Touch() {if (pLink) pLink->Touch(); }
  void SetTextureLevel(int level);
	HRESULT SetTexture(LPDIRECT3DDEVICE9 m_device, int stage);
  LPDIRECT3DTEXTURE9 GetDXTexture(void) { return (this->pLink ? this->pLink->GetDXTexture() : this->tex);};
};

#endif /* _TEXTURE_H */
E:\Project\Kopia (5) VBEngine\Graphics\Texture.h
#include "..\config.h"

#include <windows.h>
#include <assert.h>
#include <string.h>

#include <d3d9.h>
#include <d3dx9effect.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\utility\VBmath.h"
#include "..\Utility\Singleton.h"

#include "..\Utility\ctime.h"
#include "..\Utility\logger.h"

#include "..\FileSystem\FileNode.h"
#include "..\FileSystem\BranchNode.h"
#include "..\FileSystem\FileSystem.h"

#include "renderer.h"
#include "Shader.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "MaterialManager.h"
#include "mesh.h"
#include "meshmanager.h"

#include "..\Utility\Event.h"
#include "..\Utility\EventManager.h"
#include "..\Utility\EventHandler.h"
#include "GUI.h"

#include "BmpFont.h"

#include "Texture.h"
#include "..\core\SetupManager.h"

/* opis prostego vertexa zawierajacego pozycjie i UV */
struct Verts
{
  float x,y,z;
  float u,v;
};

//pozycje numerkow w numerekX.jpg
const CVector3 NUV[6] = {
  CVector3(121.0f,320.0f,0.0f),
  CVector3(145.0f,381.0f,0.0f),

  CVector3(125.0f,76.0f,0.0f),
  CVector3(145.0f,122.0f,0.0f),

  CVector3(93.0f,209.0f,0.0f),
  CVector3(105.0f,233.0f,0.0f)
};


/* Konstuktor */
CTexture::CTexture(void)
{
  this->current_level = SetupManager::Instance()->GetVideo()->texture_level;
	this->name[0] = '\0';
	this->pLink = NULL;
  this->tex = NULL;
	this->is_loaded = false;
  this->is_clinable = true;
} /* end of : Konstruktor */

/* Dekonstuktor: wyladowywuje effect z pamieci */
CTexture::~CTexture(void)
{	
  if (this->tex)
	{
    this->tex->Release();
    this->tex = NULL;
  }
} /* end of : DeKonstruktor */

/*
 * Inicjalizator
 * Skopiowanie nazwy pliku do wlasnego buffora z nazwa (nazwa moze miec max MAX_FILE_NAME znaków)
 */
void CTexture::Init(const char *filename)
{
  if(filename)
  {
    my_snprintf(this->name, MAX_FILE_NAME, "%s", filename);
  }
} /* end of : Init */

/*
 * Prorwnaj zadan¹ nazwe z nazw¹ pliku naszej textury  (funkcja pomocnicza dla texture menagera)
 * zwraza True jesli sa to te same nazwy.
 */
bool CTexture::Cmp(const char *_name)
{
	return (_name && this->name[0] != '\0' && stricmp(this->name, _name)==0);
} /* end of : Cmp(...) */

/*
 * Wy³adowanie textury z pamiêci.
 */
void CTexture::UnLoadFull(void)
{
  if (this->is_loaded && this->tex)
	{
    this->is_loaded = false;
    this->tex->Release();
    this->tex = NULL;
    LogMessage("Unload texture: %s", this->name);
  }
}; /* end of : UnloadFull texture */


/*
 * Wy³adowanie textury z pamiêci (sprawdza blokade).
 */
void CTexture::UnLoad(void)
{
  if (this->is_clinable)
	{
    UnLoadFull();
  }
}; /* end of : Unload texture */

/*
 * Ustawia aktualny poziom textury.
 * Dodatkow pozwala tylko ustawic dostepne wartosci (0,1,2)
 */
void CTexture::SetTextureLevel(int level)
{
  if(level < 0)
  {
    this->current_level = 0;
    return;
  }
  if(level > 2 )
  {
    this->current_level = 2;
    return;
  }
  this->current_level = level;
}; /* end of : SetTextureLevel */

/*
 * Za³adowanie pliku tetury do pamiêci.
 *
 * Jesli dana textura jest "linkiem" to wywoluje sie ladowanie faktycznej textury (podlinkowanej).
 *
 * Funcjia pracuje w 2 trybach.
 * 1. Normalne ladowanie textury z dysku lub z DataFile
 * 2. Generacja (Renderowanie do textury) indywidualnych koszulek graczy (nazwiska)
 *
 * Przelaczanie z jednego trybu do inego odbywa sie przez sprawdzenie pierwszego znaku
 * w zadanej nazwie textury:
 *   - str[0] == '#' - generacja koszulek
 *   - str[0] != '#' - normalne ladowanie
 *
 * Normalne ladowanie ignoruje podane rozszezenie pliku prubujac wykryc i zaladowac pliki
 * wedlug nastepujacej kolejnosci rozszezen : dds, tga, png, jpg.
 * Pliki wyszukiwane sa w podkatalogach zaleznych od poziomu dokladnosci textur.
 *
 * Wpierwszej kolejnosci textury szukane sa na dysku a puzniej w DataFile.
 *
 * Dodatkowo jest tu wlonczony HACK skalujacy wszystkie textury z podsystemu GUI o 50%
 * (pilnujacy by w i h byly wielokrotnoscia 2)
 * (Graficy maja swoje fanaberie a programisci swoje algorytmy :)
 *
 * Funkcjia zwraca direxowy tryb blêdu HRESULT
 *  - S_OK jesli jest juz zaladowany.
 *  - Bl¹d kazdej funcji sk³adowej odpowiadaj¹cej za fizyczne zaladowanuie textury do pamieci.
 */
const char *extensions[] =
{
  "dds","tga","png","jpg"
};

const char *TexLevelDir[] = 
{
  "Level_128", "Level_256", "Level_512"
};

HRESULT CTexture::Load(LPDIRECT3DDEVICE9 device)
{
  this->pdevice = device;

  if (pLink != NULL)
  {
    return pLink->Load(device);
  }

	if (!this->is_loaded)
	{
		char path[MAX_PATH];
    HRESULT hr;

    if ( this->name[0] == '#' )
    {
      char playerName[MAX_PATH];
      char color[MAX_PATH];    
      int number=0;

      HTexture baseTexHandle = 0;

      /* odczytaj nazwe zawodnika i jego numer wraz z kolorem */
      sscanf(this->name, "#base=%d str1=%s num=%d color=%s",(unsigned int*)&baseTexHandle, playerName, &number, color);
      
      hr = DrawSpecialTexture(baseTexHandle, playerName, number, color);
 
    }
    else
    {
      /* generacja pelnej sciezki do textury */
      my_snprintf(path, MAX_PATH, "%s%s\\%s", TexturesPath, TexLevelDir[this->current_level], this->name);
 
      /* magia rozszezen */
      void *data = NULL;
      UINT size, i;
      char *dot = strrchr(path,'.');
      if (dot == NULL || dot == path)
      {
        dot = path + strlen(path) + 1 ;
        *dot = '.';
      }
      dot++;
      D3DXIMAGE_INFO info;
      memset(&info,0,sizeof(info));
      bool GUI = strnicmp(this->name,"gui\\",4) == 0;
      bool found = false;
      for (i = 0  ; i < 4 && !found ; i++)
      {
        *dot = '\0';
        cat_snprintf(path, sizeof(path), extensions[i]);
        hr = D3DXGetImageInfoFromFile(path, &info);
        if (SUCCEEDED(hr))
        {
          /* graficy vs programisci */
          UINT width=1;
          UINT height=1;
          while (width < info.Width ) width = width << 1;
          while (height < info.Height ) height = height << 1; 
          if (GUI)
          {
            width = width >> 1;
            height = height >> 1;
          }
          UINT mipLevels = 0; // sprawdzenie czy ma byc z mipmapami?
          hr = D3DXCreateTextureFromFileEx(device, path, width , height, mipLevels,0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED , D3DX_FILTER_TRIANGLE, D3DX_FILTER_LINEAR,0, NULL,NULL,&this->tex);
        }
        if (SUCCEEDED(hr)) found = true;  
      }
      for (i = 0  ; i < 4 && !found ; i++)
      {
        *dot = '\0';
        cat_snprintf(path, sizeof(path), extensions[i]);
        data = FileSystem::Instance()->LoadFile(path,&size);
        if (data != NULL)
        {
          hr = D3DXGetImageInfoFromFileInMemory(data, size, &info);
          if (SUCCEEDED(hr))
          {
            /* graficy vs programisci */
            UINT width=1;
            UINT height=1;
            while (width < info.Width ) width = width << 1;
            while (height < info.Height ) height = height << 1; 
            if (GUI)
            {
              width = width >> 1;
              height = height >> 1;
            }
            UINT mipLevels = 0; // sprawdzenie czy ma byc z mipmapami?
            hr = D3DXCreateTextureFromFileInMemoryEx(device, data, size, width , height, mipLevels,0, D3DFMT_A8R8G8B8, D3DPOOL_MANAGED , D3DX_FILTER_TRIANGLE, D3DX_FILTER_LINEAR,0, NULL,NULL,&this->tex);
          }
      
          if (SUCCEEDED(hr)) found = true;
        }
      }
     
    }

		if(SUCCEEDED(hr))
		{
      LogMessage("Load texture: %s", this->name);
      POST_EVENT(ET_GUI, GUIE_DEC_LOAD_COUNT, true, NULL);
      this->is_loaded = true;
		}
		else
		{
      this->tex = NULL;
      LogError("Load texture: %s failed !", this->name);
		}
  
    return hr;
  }
  return S_OK;
}/* end of : Load Texture */

/*
 * Ustwaia aktywna texture na danym stagu
 * 
 * Dodatkowo sprawdza czy posiadamy podpiêta(podlinkowana) texture i ustawia ja zamiast 
 * przechowywanej.
 *
 * Jesli dana textura nie byla jescze zaladowana to podejmuje prube jej zaladowania
 * (jesli i ta zawiedzie to na anym stagu zostaje wylonczona textura)
 */
HRESULT CTexture::SetTexture(LPDIRECT3DDEVICE9 device, int stage)
{
	if (this->pLink)
	{
		return this->pLink->SetTexture(device, stage);
	}

	if (FAILED(this->Load(device)))
  {
    return device->SetTexture(stage, NULL);
  }
  
  return device->SetTexture(stage, this->tex);
}/* end of : SetTexture */


/*
 * Ustwaia pozycjie vertexow dla renderowania do textury
 */
void CTexture::SetVertPositions(Verts * v, float x, float y, float width, float height, 
                        float u0, float v0, float u1, float v1, 
                        bool flipOnY, bool flipV, bool flipU)  
{
  if ( !flipOnY )
  {
     v[0].x = x;      v[1].x = x+width;    v[2].x = x+width;     v[3].x = x;
     v[0].y = y;      v[1].y = y;      v[2].y = y+height;    v[3].y = y+height;  
     v[0].z = 0.0f;   v[1].z = 0.0f;       v[2].z = 0.0f;        v[3].z = 0.0f;  
    v[0].u = u0;     v[1].u = u1;         v[2].u = u1;          v[3].u = u0;  
    v[0].v = v1;     v[1].v = v1;         v[2].v = v0;          v[3].v = v0;  
  }
  else
  {
    v[0].x = x;      v[1].x = x+width;    v[2].x = x+width;     v[3].x = x;
    /* UWAGA TO JEST WALNIETE BO ZAKLADA ZE KOSZULKI SA 512x512 */
    v[0].y = 512-y;  v[1].y = 512-y;      v[2].y = 512-y+height;    v[3].y = 512-y+height;  
    v[0].z = 0.0f;   v[1].z = 0.0f;       v[2].z = 0.0f;        v[3].z = 0.0f;  
    v[0].u = u0;     v[1].u = u1;         v[2].u = u1;          v[3].u = u0;  
    v[0].v = v0;     v[1].v = v0;         v[2].v = v1;          v[3].v = v1;  
  }

  if ( flipV )
  {
    float tmp = v[0].v; 
    v[0].v = v[3].v;
    v[3].v = tmp;
    
    tmp = v[1].v; 
    v[1].v = v[2].v;
    v[2].v = tmp;   
  }

  if ( flipU )
  {
    float tmp = v[0].u; 
    v[0].u = v[1].u;
    v[1].u = tmp;
     
    tmp = v[2].u; 
    v[2].u = v[3].u;
    v[3].u = tmp;  
  }

}

/*
 * Twozy indywidualne textury dla zawodnikow. (Rendering do textury)
 * Zajmuja (konsumuja) one pamiec video karty wienc lepiej sprawdz czy masz odpowiednia bestie na pokladzie
 */
HRESULT CTexture::DrawSpecialTexture(HTexture baseTextureHandle, char *playerName, int number, char *color)
{

  CTexture * baseTexture = CMeshManager::Instance()->GetTexture(baseTextureHandle);

  //tekstura na RenderTarget  
  LPDIRECT3DSURFACE9 rtSurf;         

  //D3DXowy wrapper na renderowanie do tekstury
  LPD3DXRENDERTOSURFACE toSurf=NULL; 
  
  //tekstury na numerki 
  LPDIRECT3DTEXTURE9 numerek1Tex=NULL;
  LPDIRECT3DTEXTURE9 numerek2Tex=NULL; // tylko jesli numerek : 10-12
  
  HRESULT hr;
  char path[MAX_PATH];

  //pobierz dane o teksturze koszulki teamu
  D3DSURFACE_DESC desc;  
  
  hr = baseTexture->Load(pdevice);
  assert(!FAILED(hr));
  hr = baseTexture->GetDXTexture()->GetLevelDesc(0,&desc);     
  assert(!FAILED(hr));

  assert(this->tex == NULL);
 
  //utworz teksture na Render Target
  hr = D3DXCreateTexture(
    pdevice,   
    desc.Width,
    desc.Height,
    0,               //wygeneruj wszystkie mipmapy0,//
    D3DUSAGE_RENDERTARGET,
    desc.Format,
    D3DPOOL_DEFAULT, //wymagane przez D3DUSAGE_RENDERTARGET    
    &this->tex);

  assert(!FAILED(hr));
 
  my_snprintf(path, MAX_PATH, "%s%s\\numer%s%d.png",  TexturesPath, TexLevelDir[this->current_level], color, number);
  unsigned int fileSize;
  void *data = FileSystem::Instance()->LoadFile(path, &fileSize);
  hr = D3DXCreateTextureFromFileInMemory(pdevice, data, fileSize, &numerek1Tex);

  assert(!FAILED(hr));

  //pobierz surface rendertargeta
  hr = this->tex->GetSurfaceLevel(0, &rtSurf);

  assert(!FAILED(hr));

  hr = D3DXCreateRenderToSurface( pdevice, desc.Width, desc.Height, 
    desc.Format, FALSE, D3DFMT_UNKNOWN, &toSurf);

  assert(!FAILED(hr));
  
  //odkomentowane renderowanie do wszystkich surfacow aby uzyskac mipmapy
  for ( int i = 0; i < 1/*rtTex->GetLevelCount()*/; i++)
  {

    float pow_tmp = powf(2.0f, (float)i);

    //ustaw viewport na cala teksture
    D3DVIEWPORT9 viewport;
    viewport.X = 0;
    viewport.Y = 0;
    viewport.MaxZ = 1;
    viewport.MinZ = 0;
    viewport.Width=desc.Width;//pow(2,i);
    viewport.Height=desc.Height;//pow(2,i);
    if (desc.Width == 0 || desc.Height == 0)
    {
      LogCritical("WTF?");
    }
    //rozpocznij renderowanie
    
    hr = toSurf->BeginScene(rtSurf, &viewport);      
    if (FAILED(hr))
    {
      LogCritical("HR beginScena: %x",hr);
      toSurf->Release();
      rtSurf->Release();
      this->tex->Release();
      numerek1Tex->Release();
      return hr;
    }
  // assert(!FAILED(hr) && "blad przy BeginScene rendertargeta");

    hr = pdevice->Clear(0,0,D3DCLEAR_TARGET,0xff00ff00,1.0f,0);
    
    //4 - wierzcholki do renderowania tekstur
    Verts vtx[4];      

    D3DXMATRIX mat, mid;
    /* TE LICZBY TEZ MI SIE NIE PODOBAJA */
    D3DXMatrixOrthoOffCenterLH(&mat, 0, 256, 0, 256, 0.0f,1.0f);
    D3DXMatrixIdentity(&mid);

    pdevice->SetTransform(D3DTS_WORLD,&mid);
    pdevice->SetTransform(D3DTS_VIEW,&mid);
    pdevice->SetTransform(D3DTS_PROJECTION, &mat);

    pdevice->SetRenderState(D3DRS_LIGHTING, FALSE);
    pdevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    pdevice->SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);
    pdevice->SetRenderState(D3DRS_ALPHABLENDENABLE, TRUE);
    pdevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    pdevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);

    hr |= pdevice->SetFVF(D3DFVF_XYZ | D3DFVF_TEX1 );
    assert(!FAILED(hr));

    //koszulka teamu
    this->SetVertPositions(vtx, 0.0f, 0.0f, desc.Width/pow_tmp, desc.Height/pow_tmp, 0.0f, 0.0f, 1.0f, 1.0f, 
      false,  //nie odbijaj na y-kach vertexow
      false,  //nie odbijaj na y-kach UV'alow
      true); //nie odbijaj na x-ach UV'alow

    hr |= pdevice->SetTexture(0, baseTexture->GetDXTexture());      
    hr |= pdevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN , 4,(void *)(vtx),sizeof (Verts));
    assert(!FAILED(hr));

    hr |= pdevice->SetTexture(0, numerek1Tex);        
    hr |= pdevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN , 4,(void *)(vtx),sizeof (Verts));
    assert(!FAILED(hr));

    //pdevice->SetTexture(0, numerek1Tex);      
    //hr |= pdevice->DrawPrimitiveUP(D3DPT_TRIANGLEFAN , 4,(void *)(vtx),sizeof (Verts));

    //utworz renderowanie literek, dla nazwy zawodnika
    CBmpFont bmpfont;
    bmpfont.Init(pdevice);
    bmpfont.LoadFont("arialblack");
    CVector3 txtpos (
      124.0f /pow_tmp,/* NIE MA JAK POZADNIE USTAWIONE WIELOSC TEXTUR NA SZTYWNO */ 
      188.5f /pow_tmp,/* NIE MA JAK POZADNIE USTAWIONE WIELOSC TEXTUR NA SZTYWNO */
      0.0f);
    CVector3 txtscale(0.3f/pow_tmp,-0.5f/pow_tmp,0.5f/pow_tmp);
    bmpfont.Print(&txtpos, &txtscale, ALIGN_CENTER, playerName);
    
    hr |= toSurf->EndScene(D3DX_FILTER_NONE);

  }
    
  //generuj mipmapy ( uwaga na ta funkcje )
  //if ( FAILED(D3DXFilterTexture(this->tex, NULL, D3DX_DEFAULT, D3DX_DEFAULT) ) )
  //{
  //  LogError("MipMap generation : %s failed !", this->name);
  //}

  //generowanie mipmap przez kopiowanie do pamieci systemowej, uzywanie D3DXFilterTexture 
  // i updatowanie textury w pamieci video (moze byc wolne!!)
  ///*
  LPDIRECT3DSURFACE9 tmpSurf;
  LPDIRECT3DTEXTURE9 tmpTex;
  hr |= pdevice->CreateTexture(desc.Width, desc.Height,0, 0, desc.Format, D3DPOOL_SYSTEMMEM, &tmpTex,NULL);
  hr |= tmpTex->GetSurfaceLevel(0, &tmpSurf);
  hr |= pdevice->GetRenderTargetData(rtSurf, tmpSurf);
  hr |= D3DXFilterTexture(tmpTex, NULL, D3DX_DEFAULT, D3DX_DEFAULT);    
  hr |= pdevice->UpdateTexture(tmpTex, this->tex);

  tmpSurf->Release();
  tmpTex->Release(); 
 // 
 // tmpTex = this->tex;
 // pdevice->CreateTexture(desc.Width, desc.Height,0, 0, desc.Format, D3DPOOL_MANAGED, &this->tex,NULL);
  
  rtSurf->Release();
  toSurf->OnLostDevice();
  toSurf->Release();
  numerek1Tex->Release();
  //D3DXSaveTextureToFile("test1.jpg",D3DXIFF_JPG ,this->tex, NULL);
  return hr;
}
E:\Project\Kopia (5) VBEngine\Graphics\Texture.cpp
#ifndef _STADION_H
#define _STADION_H

/*
class       : CStadion
description : Klasa poswiecona obsudze stadionu (ladowanie, renderowanie, animacje, etc)
              Wykonywane sa animacjie publicznosci oraz animacje reklam na bandach.
methods     :
            CStadion(...) - konstruktor (ladowanie)
            ~CStadion()   - dekonstruktor   
            ProcessEvent(...) - obsluz eventy gry
            Update()      - obsluga animacji publiki
            Render(...)   - rysowanie
            SwitchOrientation() - rotacja o 90 stopni (zmiana polow po kazdym secie)
*/

class Animation;

/* index meshy stadionu w tablicy  */
enum STADION_MESHES
{
  PARKIET = 0,
  SLUPKI,
  STADION,
  KRZESLO,
  BANDY,
  MEBLE,
  KAMERY,
  REKLAMY,
  FLAGI,
  BARIERKI,
  STADION_MESHES_COUNT
};

class Animation;
class CSedzia;

class CStadion : public SceneObject, EventHandler
{
  bool rotated;                        /* status rotacji stadionu przy zmianie polow (setów) */
  HMesh Meshes[STADION_MESHES_COUNT];  /* tablica handlerow skladowych meshy stadionu */
  HMesh *Publicznosc;                  /* tablica handlerow meshy publicznosci stadionu */
  int mRowCount;                       /* ilosc zedów w tablicy handlerow meshy publicznosci stadionu */
  float Last_Publika_Update_Time;      /* czas ostatniej zmiany klatki w animacji publiki */

  int Anim_Index[14];                  /* index aktualnej klatki animacji publicznosci */
  HTexture AnimLink[14];               /* handlery textur publicznosci w meshach stadionu */
  HTexture Anims[14][2];               /* handlery textur aktualnej animacji publicznosci */
  HTexture AnimTextures[14][5];        /* handlery textur wszystkich animacji publicznosci */
  
  float mReklamyFlipTime;              /* czas ostatniej zmiany klatki w animacji bandy */
  int mAktywnaReklama;                 /* index aktualnej klatki animacji bandy */ 
public:
  CStadion(char *filename);
  ~CStadion();
  void ProcessEvent(Event *event);
  void Update(void);
  void Render(CMatrix4 *pViewProj);
  void SwitchOrientation();
};

/*
class       : CSiatka
description : Klasa poswiecona obsudze siatki na stadionie (ladowanie, renderowanie, animacje, etc)
              Klasa wylonczona z stadionu poniweaz siatka musi byc renderowana ostatnia (
              z powodu Alfy ) oraz wykonywania specyficznych funkci w momecie trafienia przez pilke
methods     :
            CSiatka(...) - konstruktor (ladowanie)
            ~CSiatka();

            ProcessEvent(...) - obsluz eventy gry (planowane)
            Update()      - obsluga animacji (przeniesione do renderingu)
            Render(...)   - rysowanie oraz obsluga animacji tradienia
            SwitchOrientation() - rotacja o 90 stopni (zmiana polow po kazdym secie)
            RegisterHit(...)  - inicjializaczjia animacj trafienia przez pilke w danym :
                                punkcjie , czasie , i predkoscia
*/

class CSiatka : public SceneObject
{
  bool rotated;                /* status rotacji siatki przy zmianie polow (setów) */
  HMesh Mesh;                  /* handler na mesha siatki w MM */
  CVector3 HitPoint;           /* punkt udezenia pilki w siatke (jesli zgloszono) */
  float hitTime;               /* czas udezenia pilki w siatke (jesli zgloszono) */ 
  float maxOffset;             /* modyfikator wielkosci oscylacji w zaleznosci od sily trafienia */ 
  float duration;              /* czas trfania animacji udezenia pilki w siatke (jesli zgloszono) */ 
public:
  CSiatka(char *filename);
  ~CSiatka();
  void ProcessEvent(Event *event);
  void Update(void);
  void Render(CMatrix4 *pViewProj);
  void RegisterHit(float time,CVector3 *position,CVector3 *velocity);
  void SwitchOrientation();
};

/*
class       : CTarget
description : Klasa poswiecona obsudze aniacji celu pilki na stadionie (ladowanie, renderowanie, etc)
              Wyswietlane jest animwane kolko w miejscu gdzie teoretycznie spadnie pilka.
              Dodatkowo zmieniamy kolor textury wrza z miejscem renderowania.
               - Zielony (Nasza polowa)
               - Granatowy (Polowa przeciwnika)
methods     :
            CTarget()  - konstruktor (ladowanie)
            ~CTarget() - dekonstuktor
            GetPosition() - pobiez wskaznik na aktualna pozycjie animacji
            Show()        - zezwol na wyswietlanie animacji
            Hide()        - cofnij zezwolenie na wyswietlanie animacji
            Render(...)   - renderuj oraz obsluz zmiane klatek animacji
*/

class CTarget : public SceneObject
{
  HTexture link, green, blue;    /* handlery do uzytych textur */
  Animation *mAnimation;         /* wkaznik na sekwencje animacji */
  CVector3 mPosition;            /* pozycja wyswietlania/ aktualny cel pilki */
  bool mIsBeingShown;            /* status wyswietlania on/off */
public:
  CTarget();
  ~CTarget();
  CVector3 *GetPosition() {return &this->mPosition;};
  void Show() {this->mIsBeingShown = true;};
  void Hide() {this->mIsBeingShown = false;};
  void Render(CMatrix4 *pViewProj);
};

/*
class       : CBloker
description : Klasa poswiecona obsudze aniacji miejsca bloku na stadionie (ladowanie, renderowanie, etc)
              Teoria tego czegos muwi ze powinnien zaznaczac miejsce gdzie powinien stac nasz zawodnik
              do udanego bloku ale praktyka wygenerowala jakis blad , który powoduje nie wyswitlanie
              tej zabawki.
methods     :
            CBlocker()  - konstruktor (ladowanie)
            ~CBlocker() - dekonstuktor
            GetPosition() - pobiez wskaznik na aktualna pozycjie animacji
            Show()        - zezwol na wyswietlanie animacji
            Hide()        - cofnij zezwolenie na wyswietlanie animacji
            Render(...)   - renderuj oraz obsluz zmiane klatek animacji
*/

class CBlocker : public Singleton<CBlocker>, public SceneObject
{
  Animation *mAnimation;         /* wkaznik na sekwencje animacji */
  CVector3 mPosition;            /* pozycja wyswietlania */
  bool mIsBeingShown;            /* status wyswietlania on/off */
public:
  CBlocker();
  ~CBlocker();
  CVector3 *GetPosition() {return &this->mPosition;};
  void Show() {this->mIsBeingShown = true;};
  void Hide() {this->mIsBeingShown = false;};
  void Render(CMatrix4 *pViewProj);
};

/*
class       : CArrow
description : Klasa poswiecona obsudze aniacji strzalki przy zagrywce (ladowanie, renderowanie, etc)
methods     :
            CBlocker()  - konstruktor (ladowanie)
            ~CBlocker() - dekonstuktor
            GetPosition() - pobiez wskaznik na aktualna pozycjie animacji
            Show()        - zezwol na wyswietlanie animacji
            Hide()        - cofnij zezwolenie na wyswietlanie animacji
            Render(...)   - renderuj oraz obsluz zmiane klatek animacji
*/

class CArrow : public Singleton<CArrow>, public SceneObject
{
  Animation *mAnimation;         /* wkaznik na sekwencje animacji */
  CVector3 mPosition;            /* pozycja wyswietlania/ aktualny cel pilki */
  bool mIsBeingShown;            /* status wyswietlania on/off */
  float mScale;                  /* skalownaie dlugosci strzalki */
  float mAlfa;                   /* skalownaie dlugosci strzalki */
  float mGamma;                  /* skalownaie dlugosci strzalki */
public:
  CArrow();
  ~CArrow();
  void SetParameters(CVector3 *position, float scale, float alfa, float gamma);
  void Show() {this->mIsBeingShown = true;};
  void Hide() {this->mIsBeingShown = false;};
  void Render(CMatrix4 *pViewProj);
};

/*
class       : CStadion
description :

methods     :

*/

class CTargetPrzebicia : public Singleton<CTargetPrzebicia>,public SceneObject
{
  Animation *mAnimation;
  bool mIsBeingShown;
public:
  CTargetPrzebicia();
  ~CTargetPrzebicia();
  void SetPosition(CVector3 *position);
  bool IsShow(void) {return this->mIsBeingShown;};
  void Show();
  void Hide();
  void Render(CMatrix4 *pViewProj);
};

enum SedziaStates
{
  SG0_IDLE = 0,
  SG0_ZAGRYWKA_LEFT,
  SG0_ZAGRYWKA_RIGHT,
  SG0_PUNKT_LEFT,
  SG0_PUNKT_RIGHT,
  SG0_PILKA_OUT,
  SG0_STATE_COUNT
};

enum SedziaLiniowyStates
{
  SGL_IDLE = 0,
  SGL_PILKA_OUT,
  SGL_PILKA_W_BOISKU,
  SGL_STATE_COUNT
};

enum SedziaStates2
{
  SG1_IDLE = 0,
  SG1_LOOK_LEFT,
  SG1_LOOK_RIGHT,
  SG1_GOTO_LOOK_LEFT,
  SG1_GOTO_LOOK_RIGHT,
  SG1_GOTO_IDLE_FROM_LEFT,
  SG1_GOTO_IDLE_FROM_RIGHT,
  SG1_STATE_COUNT
};

/*
class       : CStadion
description :

methods     :

*/

class CSedzia :public SceneObject
{
  bool rotated;
  float mStateStartTime;
  SedziaStates mCurrentState;
  SedziaStates mNextState;
  HAnimation mAnimation[SG0_STATE_COUNT];
public:
  CSedzia();
  ~CSedzia();
  void Render(CMatrix4 *pViewProj);
  void ZezwalajZagrywkaLeft();
  void ZezwalajZagrywkaRight();
  void WygranaAkcjaLeft();
  void WygranaAkcjaRight();
  void Out();
  void SwitchOrientation();
};

class CSedziaStojacy :public SceneObject
{
  bool rotated;
  float mStateStartTime;
  SedziaStates2 mCurrentState;
  SedziaStates2 mNextState;
  SedziaStates2 mTargetState;
  HAnimation mAnimation[SG1_STATE_COUNT];
public:
  CSedziaStojacy();
  ~CSedziaStojacy();
  void Render(CMatrix4 *pViewProj);
  void GotoLeft();
  void GotoRight();
  void GotoHint();
  void SwitchOrientation();
};

/*
class       : CStadion
description :

methods     :

*/

class CSedziaLiniowy :public SceneObject
{
  float mStateStartTime;
  SedziaLiniowyStates mCurrentState;
  SedziaLiniowyStates mNextState;
  HAnimation mAnimation[SGL_STATE_COUNT];
public:
  CSedziaLiniowy(bool initial_rotated);
  ~CSedziaLiniowy();
  void Render(CMatrix4 *pViewProj);
  void Out();
  void PilkaWBoisko();
};


#endif /* _STADION_H */
E:\Project\Kopia (5) VBEngine\Graphics\Stadion.h
#include "..\config.h"

#include <assert.h>
#include <d3dx9effect.h>

#include "..\Utility\Misc.h"
#include "..\Utility\Singleton.h"
#include "..\utility\defines.h"
#include "..\utility\VBmath.h"
#include "..\utility\conf.h"
#include "..\utility\Tools.h"
#include "..\Utility\logger.h"
#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"
#include "..\utility\CTime.h"
#include "..\utility\profile.h"

#include "renderer.h"
#include "Shader.h"
#include "ShaderManager.h"
#include "Texture.h"
#include "TextureManager.h"
#include "MaterialManager.h"
#include "mesh.h"
#include "meshmanager.h"
#include "Animation.h"
#include "AnimationManager.h"

#include "SceneObject.h"
#include "Camera.h"
#include "SceneManager.h"

#include "..\Core\team.h"
#include "..\Core\Ball.h"
#include "..\Core\Game.h"
#include "..\Core\SetupManager.h"


#include "..\Utility\Event.h"
#include "..\utility\EventManager.h"
#include "..\utility\EventHandler.h"

#include "Stadion.h"

const char *PublikAnims[] =
{
  "a",
  "b",
  "c",
  "d",
  "e"
};

CStadion::CStadion(char *filename) : EventHandler(ET_STADION)
{
  this->Publicznosc = NULL;
  this->rotated = false;
  ConfFile Config;
  char *pstr, buffer[MAX_PATH];
  int i;

  this->mReklamyFlipTime= 0.0f;
  this->mAktywnaReklama =0;

  Last_Publika_Update_Time = NOW;
  for(i = 0; i < 14; i++)
  {
    Anim_Index[i] = myrand(1);
  }
  
  my_snprintf(buffer, MAX_PATH, "%s%s", DataPath, filename);

  if (SUCCEEDED(Config.Init(buffer)))
  {

    if (NULL != (pstr = Config.GET_STR("STADION_X_FILE")))
    {
      this->Meshes[STADION] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }
    else
    {
      LogError("Failed to add stadion mesh !!");
    }

    if (NULL != (pstr = Config.GET_STR("PARKIET_X_FILE")))
    {
      this->Meshes[PARKIET] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("SLUPKI_X_FILE")))
    {
      this->Meshes[SLUPKI] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("KRZESLO_X_FILE")))
    {
      this->Meshes[KRZESLO] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("BANDY_X_FILE")))
    {
      this->Meshes[BANDY] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("REKLAMY_X_FILE")))
    {
      this->Meshes[REKLAMY] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("MEBLE_X_FILE")))
    {
      this->Meshes[MEBLE] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (NULL != (pstr = Config.GET_STR("KAMERY_X_FILE")))
    {
      this->Meshes[KAMERY] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }
    
    if (NULL != (pstr = Config.GET_STR("FLAGI_X_FILE")))
    {
      this->Meshes[FLAGI] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }
    if (NULL != (pstr = Config.GET_STR("BARIERKI_X_FILE")))
    {
      this->Meshes[BARIERKI] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
      free(pstr);
    }

    if (SUCCEEDED(Config.GET_INT("NUMBER_OF_ROWS",&mRowCount)))
    {
      char buffer[128];
      this->Publicznosc = new HMesh [mRowCount];
      for (i = 0; i < mRowCount;i ++) 
      {
        my_snprintf(buffer,128, "ROW_%i_X_FILE",i);
        if (NULL != (pstr = Config.GET_STR(buffer)))
        {
          this->Publicznosc[i] = CMeshManager::Instance()->GetMeshHandlerLoad(pstr);
          CMeshManager::Instance()->SetAllShaders(this->Publicznosc[i], "publika.fx");
          free(pstr);
        }
      }
    }
	  this->SetLevel(3);
    SceneManager::Instance()->AddObject(this);
    Config.DeInit();
  }
  else
  {
    LogError("Failed to open stadion data !!");
  }

  
  char buf1[64];
  for( i = 1; i < 15; i++)
  {   
    my_snprintf(buf1, 64, "public%d.png", i);
    AnimLink[i-1] = CMeshManager::Instance()->GetTextureHandler(buf1);
    for ( int j=0; j < 5; j++ )
    {
      my_snprintf(buf1, 64, "public%d_%s.png", i, PublikAnims[j]);
      this->AnimTextures[i-1][j] = CMeshManager::Instance()->GetTextureHandlerLoad(buf1);
    }
    this->Anims[i-1][0] = this->AnimTextures[i-1][0];
    this->Anims[i-1][1] = this->AnimTextures[i-1][0];
  }


}

CStadion::~CStadion()
{
  SceneManager::Instance()->RemoveObject(this);

  if(Publicznosc)
  {
  delete[] Publicznosc;
  }

}

#define PUBLIKA_DELAY 1.0f/4.0f

void CStadion::Update(void)
{
  if(NOW - Last_Publika_Update_Time > PUBLIKA_DELAY)
  {
    for(int i = 0; i < 14; i++)
    {
      CMeshManager::Instance()->LinkTexture(this->AnimLink[i], this->Anims[i][Anim_Index[i]]);
      Anim_Index[i-1]++;
      if(Anim_Index[i-1] > 1)
      {
        Anim_Index[i-1] = 0;
      }
    }
    Last_Publika_Update_Time = NOW;
  }
  
}

void CStadion::ProcessEvent(Event *event)
{
  if (SetupManager::Instance()->GetVideo()->crawd)
  {
    switch (event->mID)
    {
      case GE_BALL_HIT_NET:
      case GE_BALL_HIT_FLOOR:
      case GE_BALL_PASS_UNDER_NET:
      {
        
        int i;
        if (CBall::Instance()->GetTeamOwner() == TEAM_0)
        {
          for(i = 0; i < 14; i+=2)
          {
            /* klaskanie siedzac */
            this->Anims[i][0] = this->AnimTextures[i][1];
            this->Anims[i][1] = this->AnimTextures[i][2];
          }
          for(i =1 ; i < 14; i+=2)
          {
            /* klaskanie stojac */
            this->Anims[i][0] = this->AnimTextures[i][3];
            this->Anims[i][1] = this->AnimTextures[i][4];
          }
        }
        else
        {
          for(i = 0; i < 14; i+=2)
          {
            /* klaskanie siedzac */
            this->Anims[i][0] = this->AnimTextures[i][3];
            this->Anims[i][1] = this->AnimTextures[i][4];
          }
          for(i=1; i < 14; i+=2)
          {
            /* klaskanie stojac */
            this->Anims[i][0] = this->AnimTextures[i][1];
            this->Anims[i][1] = this->AnimTextures[i][2];
          }
        }
      }
      break;

    //  case GE_BREAK_LIGHTS:
      case EFFECT_4:
      {
        for(int i = 0; i < 14; i++)
        {
            /* reset animacji */
            this->Anims[i][0] = this->AnimTextures[i][0];
            this->Anims[i][1] = this->AnimTextures[i][0];
        }
      }
    break;
    }
  }
  else
  {
    for(int i = 0; i < 14; i++)
    {
        /* reset animacji */
        this->Anims[i][0] = this->AnimTextures[i][0];
        this->Anims[i][1] = this->AnimTextures[i][0];
    }
  }
}
 
#define REKLAMY_TIME  2.0f
#define REKLAMY_DELAY 20.0f
#define REKLAMY_COUNT 8

void CStadion::Render(CMatrix4 *pViewProj)
{
  PROFILE(Stadion_Render);
  CMatrix4 matWorldViewProj, matWorld;

 // matWorldViewProj.SetRotateZ(PI/2);
  //matWorld.SetRotateX(PI/2);
  //matWorld *= matWorldViewProj;
   
  matWorldViewProj = worldMatrix * *pViewProj;

  //matWorldViewProj = matWorld * *pViewProj;
  //matWorldViewProj = this->worldMatrix * *pViewProj;
  
  CMeshManager::Instance()->Render(this->Meshes[PARKIET], &matWorldViewProj);

#if 1
  CMeshManager::Instance()->Render(this->Meshes[STADION], &matWorldViewProj);
  CMeshManager::Instance()->Render(this->Meshes[KRZESLO],this->Meshes[KRZESLO],1.0f, &matWorldViewProj);
  CMeshManager::Instance()->Render(this->Meshes[BANDY],   &matWorldViewProj);
  {
    PROFILE(Stadion_render_publika);
    for(int i = 0; i < mRowCount; i+=2)//i++)
    {
      CMeshManager::Instance()->Render(this->Publicznosc[i], &matWorldViewProj);
    }
  }
  CMeshManager::Instance()->Render(this->Meshes[MEBLE],   &matWorldViewProj);
  CMeshManager::Instance()->Render(this->Meshes[KAMERY],  &matWorldViewProj);
  CMeshManager::Instance()->Render(this->Meshes[BARIERKI],  &matWorldViewProj);
  CMeshManager::Instance()->Render(this->Meshes[FLAGI],  &matWorldViewProj);
#endif
/*
  matWorldViewProj.SetRotateZ(PI/2);
  matWorld.SetRotateX(PI/2);
  matWorld *= matWorldViewProj;

  matWorldViewProj = matWorld * *pViewProj;
  */
  CMeshManager::Instance()->Render(this->Meshes[SLUPKI], &matWorldViewProj);
  // reklamy na bandach
  if (NOW - this->mReklamyFlipTime > REKLAMY_DELAY)
  {
    this->mReklamyFlipTime = NOW;
    this->mAktywnaReklama++;
    if (this->mAktywnaReklama == REKLAMY_COUNT)
    {
      this->mAktywnaReklama = 0;
    }
  }
  float Offset = (float)this->mAktywnaReklama /(float) REKLAMY_COUNT;
  if (NOW - this->mReklamyFlipTime < REKLAMY_TIME)
  {
    Offset += (NOW - this->mReklamyFlipTime)/ (REKLAMY_TIME *REKLAMY_COUNT);
  }
  else
  {
    Offset += 1.0f/ (float) REKLAMY_COUNT;
  }
  CVector4 reklamy_offset(0.0f,Offset,0.0f,0.0f);
  CMeshManager::Instance()->SetVec4DataToAllShaders(this->Meshes[REKLAMY],"UVOffset",&reklamy_offset);
  CMeshManager::Instance()->Render(this->Meshes[REKLAMY], &matWorldViewProj);
}
 
void CStadion::SwitchOrientation()
{
  if (rotated)
  {
    rotated = false;
    worldMatrix.SetIdentity();
  }
  else
  {
    rotated = true;
    worldMatrix.SetRotateZ(PI);
  }
}
/* ============================================================================================ */

CSiatka::CSiatka(char *filename)
{
  this->rotated = false;
  this->hitTime= 0.0f;
  this->duration = -10000;
  if (filename && *filename != '\0')
  {
    this->Mesh = CMeshManager::Instance()->GetMeshHandlerLoad(filename);
    SceneManager::Instance()->AddObject(this);
  }
  else
  {
    LogError("Failed to add siatka Mesh !!");
  }
 }

CSiatka::~CSiatka()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CSiatka::Update(void)
{

}

void CSiatka::ProcessEvent(Event *event)
{

}

void CSiatka::SwitchOrientation()
{
  if (rotated)
  {
    rotated = false;
    worldMatrix.SetIdentity();
  }
  else
  {
    rotated = true;
    worldMatrix.SetRotateZ(PI);
  }
}
#define OSCILATION_TIME 1.8f
#define OSCILATION_COUNT 8

#define XMAX  5.234299f
#define XMIN -5.302017f
#define ZMIN  1.250443f
#define ZMAX  2.588953f

void CSiatka::Render(CMatrix4 *pViewProj)
{
  PROFILE(Siatka_render);
  CMatrix4 matWorldViewProj, matWorld;

  float current_time = NOW;
  CVector4 hit_point(0.0f,0.0f,0.0f,0.0f);
  
  if (current_time - this->hitTime < duration)
  {
     float oscilation_angle = OSCILATION_COUNT * (current_time - this->hitTime)/ duration * 2 * PI;
     float dampening_coeff = 1- (current_time - this->hitTime)/ duration;
     hit_point.x = this->HitPoint.x;
     hit_point.z = this->HitPoint.z;
     hit_point.y = this->maxOffset * dampening_coeff * sinf(oscilation_angle);
  }
  else
  {
    hit_point = CVector4(0.0f,0.0f,1.87f,0.0f);
  }


  CVector4 maxDeltas;
  CVector4 minDeltas;
  maxDeltas.x = 1.0f/(hit_point.x - XMAX);
  maxDeltas.z = 1.0f/(hit_point.z - ZMAX);
  minDeltas.x = 1.0f/(hit_point.x - XMIN);
  minDeltas.z = 1.0f/(hit_point.z - ZMIN);
  CMeshManager::Instance()->SetVec4DataToAllShaders(this->Mesh,"HitPoint",&hit_point);
  CMeshManager::Instance()->SetVec4DataToAllShaders(this->Mesh,"InvMinDeltas",&minDeltas);
  CMeshManager::Instance()->SetVec4DataToAllShaders(this->Mesh,"InvMaxDeltas",&maxDeltas);

  //matWorldViewProj = matWorld * *pViewProj;
  matWorldViewProj = worldMatrix * *pViewProj;

  CMeshManager::Instance()->Render(this->Mesh, &matWorldViewProj);
}

void CSiatka::RegisterHit(float time,CVector3 *position, CVector3 *velocity)
{
  this->hitTime = time;
  this->HitPoint.Set(position);
  HitPoint.y = 0;
  float len = velocity->Length()/20;
  this->maxOffset = MIN(len, 0.1f);
  this->maxOffset *= SGN(velocity->y);
  float coeff = expf(- HitPoint.x * HitPoint.x / (XMAX * XMAX) * logf(1.0f/1.5f) *logf(1.0f/1.5f)) * 1.5f;
  this->maxOffset *= coeff;
  this->duration = OSCILATION_TIME * coeff;
}

/* class CTarget */


CTarget::CTarget()
{
  this->mIsBeingShown = false;
  this->mPosition     = CVector3(0.0f,0.0f,0.0f);
  mAnimation = AnimationManager::Instance()->GetAnimation("cel\\cel_0.dat");
  this->SetLevel(4);
  SceneManager::Instance()->AddObject(this);
  this->link = CMeshManager::Instance()->GetTextureHandler("linktxr.png");
  this->green = CMeshManager::Instance()->GetTextureHandlerLoad("greentxr.png");
  this->blue = CMeshManager::Instance()->GetTextureHandlerLoad("bluetxr.png");
}

CTarget::~CTarget()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CTarget::Render(CMatrix4 *pViewProj)
{
  if (!this->mIsBeingShown) return;
  this->worldMatrix.SetTranslate(this->mPosition.x,
                                 this->mPosition.y,
                                 0.1f);
  this->worldMatrix *= *pViewProj;
  float delta_T = fmodf(NOW,mAnimation->GetDuration());
  Frame *first, *second;
  first  = mAnimation->GetFrameByTime(delta_T);
  second = mAnimation->GetFollowingFrameByTime(delta_T);
  if (!second)
  {
    second = mAnimation->GetFirstFrame();
  }
  float alpha = (delta_T - first->start_time) / first->duration;

  if(this->mPosition.y > 0)
  {
    CMeshManager::Instance()->LinkTexture(this->link, this->green);
  }
  else
  {
    CMeshManager::Instance()->LinkTexture(this->link, this->blue);
  }
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&this->worldMatrix);
}

/* ============================================================================== */


CBlocker::CBlocker()
{
  this->mIsBeingShown = false;
  this->mPosition     = CVector3(0.0f,0.0f,0.0f);
  mAnimation = AnimationManager::Instance()->GetAnimation("blocker\\blocker.dat");
  this->SetLevel(4);
  SceneManager::Instance()->AddObject(this);
}

CBlocker::~CBlocker()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CBlocker::Render(CMatrix4 *pViewProj)
{
  if (!this->mIsBeingShown) return;
  this->worldMatrix.SetTranslate(this->mPosition.x,
                                 0.0f,
                                 0.1f);
  
  float delta_T = fmodf(NOW,mAnimation->GetDuration());
  Frame *first, *second;
  first  = mAnimation->GetFrameByTime(delta_T);
  second = mAnimation->GetFollowingFrameByTime(delta_T);
  if (!second)
  {
    second = mAnimation->GetFirstFrame();
  }
  float alpha = (delta_T - first->start_time) / first->duration;

  if(this->mPosition.y > 0)
  {
    CMatrix4 rot;
    rot.SetRotateZ(PI);
    this->worldMatrix *= rot;
  }

  this->worldMatrix *= *pViewProj;
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&this->worldMatrix);  
}




CArrow::CArrow() 
{
  this->mIsBeingShown = false;
  this->mPosition     = CVector3(0.0f,0.0f,0.0f);
  mAnimation = AnimationManager::Instance()->GetAnimation("strzalka\\strzalka2.dat");
  this->SetLevel(4);
  SceneManager::Instance()->AddObject(this);
  mAlfa = mGamma = 0.0f;
  mScale = 0.0f;
}

CArrow::~CArrow()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CArrow::Render(CMatrix4 *pViewProj)
{
  if (!this->mIsBeingShown) return;
  
  this->worldMatrix *= *pViewProj;
  float delta_T = fmodf(NOW,mAnimation->GetDuration());
  Frame *first, *second;
  first  = mAnimation->GetFrameByTime(delta_T);
  second = mAnimation->GetFollowingFrameByTime(delta_T);
  if (!second)
  {
    second = mAnimation->GetFirstFrame();
  }
  float alpha = (delta_T - first->start_time) / first->duration;
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&this->worldMatrix);  
  mIsBeingShown = false;
}

void CArrow::SetParameters(CVector3 *position, float scale, float alfa, float gamma)
{
  mIsBeingShown = true;
  mPosition = *position;
  mAlfa = alfa;
  mGamma = gamma;
  mScale = scale;
  CMatrix4 tr, sc,rota,rotg;
  CMatrix4 temp1,temp2;
  sc.SetScale(1.0f, mScale,1.0f);
  rota.SetRotateX(-mAlfa);
  rotg.SetRotateZ(PI - mGamma);
  tr.SetTranslate(this->mPosition.x,this->mPosition.y, this->mPosition.z);
  temp1 = sc * rota;
  temp2 = rotg * tr;
  worldMatrix = temp1 * temp2;
  //sc *= rota;
  //sc *= rotg;
  //tr.SetTranslate(this->mPosition.x,this->mPosition.y, this->mPosition.z);
  //sc *= tr;
  //worldMatrix = sc;
}




CTargetPrzebicia::CTargetPrzebicia()
{
  this->mIsBeingShown = false;
  
  mAnimation = AnimationManager::Instance()->GetAnimation("celownik\\celownik_0.dat");
  this->SetLevel(4);
  SceneManager::Instance()->AddObject(this);
}

CTargetPrzebicia::~CTargetPrzebicia()
{
  SceneManager::Instance()->RemoveObject(this);
}


void CTargetPrzebicia::Show(void)
{
  this->mIsBeingShown = true;
};

void CTargetPrzebicia::Hide(void)
{
  this->mIsBeingShown = false;
};

void CTargetPrzebicia::SetPosition(CVector3 *position)
{
  this->worldMatrix.SetTranslate(position->x,
                                 position->y,
                                 0.2f);

}

void CTargetPrzebicia::Render(CMatrix4 *pViewProj)
{
  if (!this->mIsBeingShown) return;
  CMatrix4 temp = this->worldMatrix * (*pViewProj);
  float delta_T = fmodf(NOW,mAnimation->GetDuration());
  Frame *first, *second;
  first  = mAnimation->GetFrameByTime(delta_T);
  second = mAnimation->GetFollowingFrameByTime(delta_T);
  if (!second)
  {
    second = mAnimation->GetFirstFrame();
  }
  float alpha = (delta_T - first->start_time) / first->duration;
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&temp);  
}
/* ============================================================================= */

CSedzia::CSedzia()
{ 
  this->rotated = false;
  this->mAnimation[SG0_IDLE] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\hint_sedzia1_0.dat");
  this->mAnimation[SG0_ZAGRYWKA_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\zezwala_zagrywka_left_s1_0.dat");
  this->mAnimation[SG0_ZAGRYWKA_RIGHT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\zezwala_zagrywka_right_s1_0.dat");
  this->mAnimation[SG0_PUNKT_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\wygrana_akcja_left_s1.dat");
  this->mAnimation[SG0_PUNKT_RIGHT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\wygrana_akcja_right_s1.dat");
  this->mAnimation[SG0_PILKA_OUT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\pilka_autowa_s1_0.dat");
  this->SetLevel(5);
  SceneManager::Instance()->AddObject(this);
  this->worldMatrix.SetRotateZ(PI/2);
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_IDLE;
  this->mNextState  = SG0_IDLE;

}

CSedzia::~CSedzia()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CSedzia::Render(CMatrix4 *pViewProj)
{
  if (!SetupManager::Instance()->GetVideo()->referees) return; 
  CMatrix4 temp = this->worldMatrix * (*pViewProj);
  float CurrentTime = NOW;
  Animation *anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  float delta_t = CurrentTime - mStateStartTime;
  if (this->mCurrentState != SG0_IDLE && delta_t > anim->GetDuration())
  {
    mStateStartTime = mStateStartTime + anim->GetDuration();
    float delta_t = CurrentTime - mStateStartTime;

    mCurrentState = this->mNextState;
    this->mNextState = SG0_IDLE;
    anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  }

  if (mCurrentState == SG0_IDLE)
  {
    delta_t = fmodf(delta_t,anim->GetDuration());
  }
  
  Frame *first, *second;
  first  = anim->GetFrameByTime(delta_t);
  second = anim->GetFollowingFrameByTime(delta_t);
  if (!second)
  {
    second = anim->GetFirstFrame();
  }
  float alpha = (delta_t - first->start_time) / first->duration;
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&temp);  
}


void CSedzia::ZezwalajZagrywkaLeft()
{
  if (this->mCurrentState != SG0_IDLE)
  {
    this->mNextState = SG0_ZAGRYWKA_LEFT;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_ZAGRYWKA_LEFT;
  if (SetupManager::Instance()->GetSound()->referee)
  {
    POST_EVENT(ET_AUDIO, WAV_6, false, NULL);
  }
}
void CSedzia::ZezwalajZagrywkaRight()
{
  if (this->mCurrentState != SG0_IDLE)
  {
    this->mNextState = SG0_ZAGRYWKA_RIGHT;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_ZAGRYWKA_RIGHT;
  if (SetupManager::Instance()->GetSound()->referee)
  {
    POST_EVENT(ET_AUDIO, WAV_6, false, NULL);
  }
}

void CSedzia::WygranaAkcjaLeft()
{
  if (this->mCurrentState != SG0_IDLE)
  {
    this->mNextState = SG0_PUNKT_LEFT;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_PUNKT_LEFT;
  if (SetupManager::Instance()->GetSound()->referee)
  {
    POST_EVENT(ET_AUDIO, WAV_6, false, NULL);
  }
}
void CSedzia::WygranaAkcjaRight()
{
  if (this->mCurrentState != SG0_IDLE)
  {
    this->mNextState = SG0_PUNKT_RIGHT;
    return;
  }
  
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_PUNKT_RIGHT;
  if (SetupManager::Instance()->GetSound()->referee)
  {
    POST_EVENT(ET_AUDIO, WAV_6, false, NULL);
  }
}
void CSedzia::Out()
{
  if (this->mCurrentState != SG0_IDLE)
  {
    this->mNextState = SG0_PILKA_OUT;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SG0_PILKA_OUT;
  
}
/* ================================================================= */

CSedziaStojacy::CSedziaStojacy()
{ 
  this->rotated = false;
  this->mAnimation[SG1_IDLE] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\hint_sedzia2_0.dat");
  this->mAnimation[SG1_LOOK_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\hint_patrz_left_s2_0.dat");
  this->mAnimation[SG1_LOOK_RIGHT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\hint_patrz_right_s2_0.dat");
  this->mAnimation[SG1_GOTO_LOOK_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\patrz_left_s2_0.dat");
  this->mAnimation[SG1_GOTO_LOOK_RIGHT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\patrz_right_s2_0.dat");
  //this->mAnimation[SG1_GOTO_IDLE_FROM_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\end_patrz_left_s2_0.dat");
  this->mAnimation[SG1_GOTO_IDLE_FROM_LEFT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\end_patrz_right_s2_0.dat");
  this->mAnimation[SG1_GOTO_IDLE_FROM_RIGHT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\end_patrz_right_s2_0.dat");
  this->SetLevel(5);
  SceneManager::Instance()->AddObject(this);
 // this->worldMatrix.SetRotateZ(PI/2);
  this->mStateStartTime = NOW;
  this->mCurrentState = SG1_IDLE;
  this->mNextState  = SG1_IDLE;
  this->mTargetState = SG1_IDLE;
}

CSedziaStojacy::~CSedziaStojacy()
{
  SceneManager::Instance()->RemoveObject(this);
}


void CSedziaStojacy::Render(CMatrix4 *pViewProj)
{
  if (!SetupManager::Instance()->GetVideo()->referees) return; 
  CMatrix4 temp = this->worldMatrix * (*pViewProj);
  float CurrentTime = NOW;
  Animation *anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  float delta_t = CurrentTime - mStateStartTime;

  if (mCurrentState != SG1_IDLE && mCurrentState != SG1_LOOK_LEFT && mCurrentState != SG1_LOOK_RIGHT &&
      delta_t > anim->GetDuration())
  {
    mStateStartTime = mStateStartTime + anim->GetDuration();
    delta_t = CurrentTime - mStateStartTime;

    mCurrentState = this->mNextState;
    if(mCurrentState != this->mTargetState)
    {
      switch(this->mCurrentState)
      {
        case SG1_GOTO_LOOK_LEFT:
          if(this->mTargetState == SG1_LOOK_LEFT)
          {
            this->mNextState = SG1_LOOK_LEFT;
          }
          else
          {
            this->mNextState = SG1_GOTO_IDLE_FROM_LEFT;
          }
        break;
        case SG1_GOTO_LOOK_RIGHT:
          if(this->mTargetState == SG1_LOOK_RIGHT)
          {
            this->mNextState = SG1_LOOK_RIGHT;
          }
          else
          {
            this->mNextState = SG1_GOTO_IDLE_FROM_RIGHT;
          }
        break;
        default:
          switch(this->mTargetState)
          {
            case SG1_IDLE:
              this->mNextState = SG1_IDLE;
            break;
            case SG1_LOOK_LEFT:
              this->mNextState = SG1_GOTO_LOOK_LEFT;
            break;
            case SG1_LOOK_RIGHT:
              this->mNextState = SG1_GOTO_LOOK_RIGHT;
            break;
          }      
        break;
      }
    }
    else
    {
      this->mNextState = this->mTargetState;
    }
    anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  }

  if (mCurrentState == SG1_IDLE || mCurrentState == SG1_LOOK_LEFT || mCurrentState == SG1_LOOK_RIGHT)
  {
    delta_t = fmodf(delta_t,anim->GetDuration());
  }
  
  Frame *first, *second;
  first  = anim->GetFrameByTime(delta_t);
  second = anim->GetFollowingFrameByTime(delta_t);
  if (!second)
  {
    second = anim->GetFirstFrame();
  }
  float alpha = (delta_t - first->start_time) / first->duration;
  CMeshManager::Instance()->Render(first->mesh, second->mesh, alpha, &temp);
}

void CSedziaStojacy::GotoLeft()
{
  this->mTargetState = SG1_LOOK_LEFT;
  
  switch(this->mCurrentState)
  {
    case SG1_IDLE:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_LOOK_LEFT;
      this->mNextState = SG1_LOOK_LEFT;
    break;
    case SG1_LOOK_RIGHT:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_IDLE_FROM_RIGHT;
      this->mNextState = SG1_GOTO_LOOK_LEFT;
    break;
    default:
      break;
  }  
}

void CSedziaStojacy::GotoRight()
{
  this->mTargetState = SG1_LOOK_RIGHT;
  switch(this->mCurrentState)
  {
    case SG1_IDLE:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_LOOK_RIGHT;
      this->mNextState = SG1_LOOK_RIGHT;
    break;
    case SG1_LOOK_LEFT:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_IDLE_FROM_LEFT;
      this->mNextState = SG1_GOTO_LOOK_RIGHT;
    break;
    default:
      break;
  }
}

void CSedziaStojacy::GotoHint()
{
  this->mTargetState = SG1_IDLE;
  switch(this->mCurrentState)
  {
    case SG1_LOOK_LEFT:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_IDLE_FROM_LEFT;
      this->mNextState = SG1_IDLE;
    break;
    case SG1_LOOK_RIGHT:
      this->mStateStartTime = NOW;
      this->mCurrentState = SG1_GOTO_IDLE_FROM_RIGHT;
      this->mNextState = SG1_IDLE;
    break;
    default:
      break;
  }
}

void CSedziaStojacy::SwitchOrientation()
{
  HAnimation temp;
  temp = this->mAnimation[SG1_LOOK_LEFT];
  this->mAnimation[SG1_LOOK_LEFT] = this->mAnimation[SG1_LOOK_RIGHT];
  this->mAnimation[SG1_LOOK_RIGHT] = temp;
  temp = this->mAnimation[SG1_GOTO_LOOK_LEFT];
  this->mAnimation[SG1_GOTO_LOOK_LEFT] = this->mAnimation[SG1_GOTO_LOOK_RIGHT];
  this->mAnimation[SG1_GOTO_LOOK_RIGHT] = temp;
  temp = this->mAnimation[SG1_GOTO_IDLE_FROM_LEFT];
  this->mAnimation[SG1_GOTO_IDLE_FROM_LEFT] = this->mAnimation[SG1_GOTO_IDLE_FROM_RIGHT];
  this->mAnimation[SG1_GOTO_IDLE_FROM_RIGHT] = temp;

  if (rotated)
  {
    rotated = false;
    worldMatrix.SetIdentity();
  }
  else
  {
    rotated = true;
    worldMatrix.SetRotateZ(PI);
  }
}

void CSedzia::SwitchOrientation()
{
  HAnimation temp;
  temp = this->mAnimation[SG0_ZAGRYWKA_LEFT];
  this->mAnimation[SG0_ZAGRYWKA_LEFT] = this->mAnimation[SG0_ZAGRYWKA_RIGHT];
  this->mAnimation[SG0_ZAGRYWKA_RIGHT] = temp;
  this->mAnimation[SG0_PUNKT_LEFT];
  this->mAnimation[SG0_PUNKT_LEFT]  = this->mAnimation[SG0_PUNKT_RIGHT];
  this->mAnimation[SG0_PUNKT_RIGHT] = temp;
  if (rotated)
  {
    rotated = false;
    this->worldMatrix.SetRotateZ(PI/2);
  }
  else
  {
    rotated = true;
    this->worldMatrix.SetRotateZ(3*PI/2);
  }
}





CSedziaLiniowy::CSedziaLiniowy(bool rotated)
{ 
  this->mAnimation[SGL_IDLE] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\hint_sedzia3_0.dat");
  this->mAnimation[SGL_PILKA_OUT] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\pilka_autowa_s3_0.dat");
  this->mAnimation[SGL_PILKA_W_BOISKU] = AnimationManager::Instance()->GetAnimationHandlerLoad("sedzia1\\pilka_boisko_s3_0.dat");
  this->SetLevel(5);
  SceneManager::Instance()->AddObject(this);
  CMatrix4 rot,trans;
  rot.SetRotateZ(PI);
  trans.SetTranslate(4.5f, 11.5f, 0.0f);
  this->worldMatrix= rot * trans;
  if (rotated)
  {
    this->worldMatrix *= rot;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SGL_IDLE;
  this->mNextState  = SGL_IDLE;

}

CSedziaLiniowy::~CSedziaLiniowy()
{
  SceneManager::Instance()->RemoveObject(this);
}

void CSedziaLiniowy::Render(CMatrix4 *pViewProj)
{
  if (!SetupManager::Instance()->GetVideo()->referees) return; 
  CMatrix4 temp = this->worldMatrix * (*pViewProj);
  float CurrentTime = NOW;
  Animation *anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  float delta_t = CurrentTime - mStateStartTime;
  if (this->mCurrentState != SGL_IDLE && delta_t > anim->GetDuration())
  {
    mStateStartTime = mStateStartTime + anim->GetDuration();
    float delta_t = CurrentTime - mStateStartTime;

    mCurrentState = this->mNextState;
    this->mNextState = SGL_IDLE;
    anim = AnimationManager::Instance()->GetAnimation(mAnimation[mCurrentState]);
  }

  if (mCurrentState == SGL_IDLE)
  {
    delta_t = fmodf(delta_t,anim->GetDuration());
  }
  
  Frame *first, *second;
  first  = anim->GetFrameByTime(delta_t);
  second = anim->GetFollowingFrameByTime(delta_t);
  if (!second)
  {
    second = anim->GetFirstFrame();
  }
  float alpha = (delta_t - first->start_time) / first->duration;
  CMeshManager::Instance()->Render(first->mesh,second->mesh,alpha,&temp);  
}


void CSedziaLiniowy::Out()
{
  if (this->mCurrentState != SGL_IDLE)
  {
    this->mNextState = SGL_PILKA_OUT;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SGL_PILKA_OUT;
  
}

void CSedziaLiniowy::PilkaWBoisko()
{
 if (this->mCurrentState != SGL_IDLE)
  {
    this->mNextState = SGL_PILKA_W_BOISKU;
    return;
  }
  this->mStateStartTime = NOW;
  this->mCurrentState = SGL_PILKA_W_BOISKU;
}
E:\Project\Kopia (5) VBEngine\Graphics\Stadion.cpp
#ifndef _SHADER_MANAGER_H
#define _SHADER_MANAGER_H

/*
class       : CShaderManager
description : Zazadza plikami effectow poprzez tablice wskazników na classe CShader.
              Twozy tablice wskazników na Shadery i stopniowo zapełnia pola wraz z dodawaniem nowych
              elementów. Jesli ilosc ellemntów przekroczy "Shaders_Max_Count" do powiękrzamy
              rozmiar tablicy o 50%.
methods     :
            CShaderManager()      - konstruktor
	          ~CShaderManager()     - destruktor
            Init(...)             - okresla maxymalny dostepny poziom shaderów
	          GetShaderHandler(...) - Szuka wpisu w tablicy i jesli nie znajdzie to
                                    allokuje nowego CShader-a w tablicy (jesli jest miesce) lub
                                    najpierw powieksza tablice
            Clear()               - czysci cala tablice (usuwa cale classy)
            CleanList()           - wyładowywuje effecty z calej tablicy.
            Load(...)             - laduje effect do pamieci ( najpierw nalezy pobrac GetShaderHandler(...) do niego)
            Reload()              - laduje szadery z calej tablicy (ignoruje juz zaladowane)
	          GetShader(...)        - pobranie CShadera (moze zwrucic NULL)
            GetEffect(...)        - pobranie Effectu (moze zwrucic NULL)
	          SetDefaultTech(...)   - ustawia Defoltowa technike (zwylke LEVEL_0)
            SetCurrentTech(...)   - ustawia aktualny poziom shadera jako technike
            SetShaderLevel(...)   - zmienia aktualny poziom szaderów
            GetShaderLevel()      - porbranie aktualny poziom szaderów
            GetMaxShaderLevel()   - porbranie maksymalny poziom szaderów
            OnLostDevice()        - Wywolanie tej funcji na wszystkich szaderach w tablicy
            OnResetDevice()       - Wywolanie tej funcji na wszystkich szaderach w tablicy
*/

class CShader;
#define SHADER_NONE 0

class CShaderManager {
	CShader  **pShadersTab;              /* tablica shaderów */
  unsigned int  Shaders_Max_Count;              /* rozmiar tablicy (wraz z pustymi polami) */
	enum TechniqueType  ShaderLevel;     /* obecny poziom shaderów */
  enum TechniqueType  MaxShaderLevel;  /* maxymalny obslugiwany poziom shaderów */
public:
  CShaderManager(void);
	~CShaderManager(void);
  bool HasShader(HShader hd) { return (hd < this->Shaders_Max_Count && this->pShadersTab[hd]);};
  bool Init(LPDIRECT3DDEVICE9 device, enum TechniqueType shader_level);
	HShader GetShaderHandler(char *name);
  void Clear(void);
  void CleanList(void);
  void Reload(void);
  HRESULT Load(LPDIRECT3DDEVICE9 device, HShader hd);
	CShader * GetShader(HShader num);
  LPD3DXEFFECT GetEffect(HShader num);
	HRESULT SetDefaultTech(HShader num);
  HRESULT SetCurrentTech(HShader num);
  void SetShaderLevel(enum TechniqueType level);
  enum TechniqueType GetShaderLevel(void) {return this->ShaderLevel;};
  enum TechniqueType GetMaxShaderLevel(void) {return this->MaxShaderLevel;};
  void OnLostDevice();
  void OnResetDevice();
};


#endif /* _SHADER_MANAGER_H */
E:\Project\Kopia (5) VBEngine\Graphics\ShaderManager.h
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>
#include <string.h>

#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\Utility\logger.h"

#include "renderer.h"
#include "Shader.h"
#include "ShaderManager.h"

#include "..\core\SetupManager.h"

/* Konstuktor */
CShaderManager::CShaderManager()
{
  this->Shaders_Max_Count = 10;
  this->pShadersTab = (CShader **)calloc(this->Shaders_Max_Count, sizeof(CShader *));
  this->ShaderLevel = (enum TechniqueType)SetupManager::Instance()->GetVideo()->graphic_level;
  this->MaxShaderLevel = TECHNIQUE_DEFAULT;
}; /* end of : Konstruktor */

/* Dekonstuktor: czysci pamieæ */
CShaderManager::~CShaderManager()
{
  this->Clear();
  free(this->pShadersTab);
} /* end of : DeKonstruktor */


/*
 * Inicjalizator
 *
 * Ustawia obecny poziom shaderów (przycina do Maxymalnego Poziomu shaderów)
 * Okreslienie Maxymalneg poziomu szcaderów dostêpnego na posiadanym sprzêcie
 *  vs - vertex Shadery
 *  ps - pixel shadery
 *
 *  LEVEL_0	- normalny rendering
 *  LEVEL_1 - tylko vertex shadery (vs >= 1.1 && ps <= 1.1)
 *  LEVEL_2 - vertex i pixel shader (vs,ps >= 1.1 && vs,ps <= 2.0)
 *  LEVEL_3 - vertex i pixel shader (vs >= 2.0 && ps <= 2.0)
 *  LEVEL_4 - vertex i pixel shader (vs,ps >= 2.0)
 */
bool CShaderManager::Init(LPDIRECT3DDEVICE9 device, enum TechniqueType shader_level)
{
  D3DCAPS9 d3dCaps;
  
  if (!device)
  {
    return false;
  }

  /* Pobranie i sprawdzenie Mozliwsci sprzetu */
  device->GetDeviceCaps(&d3dCaps);	
  if ((d3dCaps.VertexShaderVersion >= D3DVS_VERSION(1, 1)))
  {
    if ((d3dCaps.VertexShaderVersion >= D3DVS_VERSION(2, 0)))
    {
     if ((d3dCaps.PixelShaderVersion >= D3DPS_VERSION(2, 0)))
     {
       this->MaxShaderLevel = LEVEL_4;
     }
     else
     {
       this->MaxShaderLevel = LEVEL_3;
     }
    }
    else
    {
     if ((d3dCaps.PixelShaderVersion >= D3DPS_VERSION(1, 1)))
     {
       this->MaxShaderLevel = LEVEL_2;
     }
     else
     {
       this->MaxShaderLevel = LEVEL_1;
     }
    }
  }
  else
  {
    this->MaxShaderLevel = LEVEL_0;
  }
  
  LogMessage("Set Max Shader Level to %d", this->MaxShaderLevel);

  /* ustawienie poziomu szaderów */
  if (shader_level > this->MaxShaderLevel)
  {
    LogWarning("Set Lower Shader Level from %d to %d", shader_level, this->MaxShaderLevel);
    this->ShaderLevel = this->MaxShaderLevel;
  }
  else
  {
    this->ShaderLevel =(enum TechniqueType)SetupManager::Instance()->GetVideo()->graphic_level;// shader_level;
    LogMessage("Set Shader Level to %d", this->ShaderLevel);
  }

	return true;
}/* end of : Init */


/*
 * Pobranie (nowego) handlera do shadera o danej nazwie pliku effectu
 * 
 * Jesli nie posiadamy jeszcze danego effectu to nowy element jest dodawany do tablicy
 * Shaderów (ale nie laduje go)
 */
HShader CShaderManager::GetShaderHandler(char *name)
{
  HShader hd = 1;

  /* szuka istniej¹cego effectu w tablicy */
  while(this->HasShader(hd))
  {
    if(this->pShadersTab[hd]->Cmp(name))
    {
      return hd;
    }
    hd++;
  }

  /*
   * Sprawdza czy nie przekroczylismy dopuszczalnej wielkosci tablicy
   * Jesli tak to realocujemy cala tablice po czym czyscimy nowe ellementy.
   */
  if(hd >= this->Shaders_Max_Count)
  {
    unsigned int i = this->Shaders_Max_Count;
    this->Shaders_Max_Count += this->Shaders_Max_Count / 2;
    this->pShadersTab = (CShader **)realloc(this->pShadersTab,
                                        this->Shaders_Max_Count * sizeof(CShader *));
    /* czusci nowe elementy */
    while(i < this->Shaders_Max_Count)
    {
      pShadersTab[i++] = NULL;
    }
  }
  
  /* dodanie nowego elementu do tablicy */
  this->pShadersTab[hd] = new CShader();
  this->pShadersTab[hd]->Init(name);
  
  return hd;
}/* end of : GetShaderHandler */

/*
 * Czysci ca³a tablice usuwajac z pamiêci jej elemêty (wy³adowywuje effecty z pamieci).
 */
void CShaderManager::Clear(void)
{
  HShader hd = 1;

  while(this->HasShader(hd))
  {
    delete this->pShadersTab[hd];
    this->pShadersTab[hd++] = NULL;
  }
};/* end of : Clear */

/*
 * Wy³adowywyje Effecty z ca³ej tablicy nie usuwajac z pamiêci jej elemêty.
 */
void CShaderManager::CleanList(void)
{
  HShader hd = 1;

  while(this->HasShader(hd))
  {
    this->pShadersTab[hd]->OnLostDevice();
    this->pShadersTab[hd++]->UnLoad();
  }
}/* end of : CleanList */

/*
 * Laduje cala tablice z aktualnym poziomem shadera (uzywane prze jego zmnianie wraz z CleanList)
 */
void CShaderManager::Reload(void)
{
  HShader hd = 1;

  while(this->HasShader(hd))
  {
    this->pShadersTab[hd++]->Load(Renderer::Instance()->GetDevice(), this->ShaderLevel);
  }
} /* end of : Reload */

/*
 * Pobranie wskaznika na CShader z tablicy.
 *
 * Moze zwrucic NULL w 2 przypadkach :
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy 
 */
CShader * CShaderManager::GetShader(HShader hd)
{
  return (hd < this->Shaders_Max_Count ? this->pShadersTab[hd] : NULL);
}; /* end of : GetShader */

/*
 * Pobranie wskaznika na Effect z tablicy Shaderów.
 *
 * Moze zwrucic NULL w 3 przypadkach :
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy 
 *  - Shader istnieje ale Effect nie zostal jeszcze wczytany (musisz rencznie wymuscic jego wczytanie)
 */
LPD3DXEFFECT CShaderManager::GetEffect(HShader hd)
{
  if(this->HasShader(hd))
  {
    return this->pShadersTab[hd]->GetEffect();
  }
  return NULL;
}/* end of : GetEffect */

/*
 * Ustawia Defoltowa technike (zwylke LEVEL_0) dla podanego shadera
 *
 * Moze zwrucic E_FAIL w 4 przypadkach :
 *  - Standardowym wyjsciu SetTechnique(...)
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy 
 *  - Shader istnieje ale Effect nie zostal jeszcze wczytany (musisz rencznie wymuscic jego wczytanie)
 */
HRESULT CShaderManager::SetDefaultTech(HShader hd)
{
  if(this->HasShader(hd) && this->pShadersTab[hd]->IsLoad())
  {
    return this->pShadersTab[hd]->SetTechnique(TECHNIQUE_DEFAULT);
  }
  return E_FAIL;
}/* end of : SetDefaultTech */

/*
 * Ustawia aktualny poziom shaderów jako technike podanego shadera
 *
 * Moze zwrucic E_FAIL w 4 przypadkach :
 *  - Standardowym wyjsciu SetTechnique(...)
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy 
 *  - Shader istnieje ale Effect nie zostal jeszcze wczytany (musisz rencznie wymuscic jego wczytanie)
 */
HRESULT CShaderManager::SetCurrentTech(HShader hd)
{
  if(this->HasShader(hd) && this->pShadersTab[hd]->IsLoad())
  {
    return this->pShadersTab[hd]->SetTechnique(this->ShaderLevel);
  }
  return E_FAIL;
};/* end of : SetCurrentTech */

/*
 * Za³adowanie pliku effectu danego shadera do pamiêci.
 *
 * Moze zwrucic E_FAIL w 4 przypadkach :
 *  - Bl¹d kazdej funcji sk³adowej odpowiadaj¹cej za fizyczne zaladowanuie effectu do pamieci.
 *  - Komurka tablicy istnieje ale jest pusta (NULL)
 *  - Podany Handler/Index przekracza wielkosc tablicy Shaderów
 *  - Nie podano "Device"
 */
HRESULT CShaderManager::Load(LPDIRECT3DDEVICE9 device, HShader hd)
{
  if(device && this->HasShader(hd))
  {
    return this->pShadersTab[hd]->Load(device, this->ShaderLevel);
  }
  return E_FAIL;
}/* end of : Load */

/*
 * Zmiana aktualnego poziomu szaderów na inny
 *
 * Funkcjia sprawdza czy nie przekroczylismy dopusczalnego poziomu szaderów 
 * a jesli tak to ustawia go(Dopuszczaklne Maximum) kazdemu wczytanemu Effectowi.
 * Jesli nowy poziom jest identyczny z obecnym to funkcjia wychodzi nic nie robiac.
 */
void CShaderManager::SetShaderLevel(enum TechniqueType level)
{
  if (level != this->ShaderLevel)
  {
    unsigned int i = 0;
    if(level > this->MaxShaderLevel)
    {
      if(this->MaxShaderLevel == this->ShaderLevel)
      {
        return;
      }
      level = this->MaxShaderLevel;
    }
    while(i < this->Shaders_Max_Count && this->pShadersTab[i] && this->pShadersTab[i]->IsLoad())
    {
      pShadersTab[i++]->SetTechnique(level);
    }
    this->ShaderLevel = level;
  }
}/* end of : SetShaderLevel */

/*
 *  Wywolanie na kazdym szadeze tej samej funkcji.
 */
void CShaderManager::OnLostDevice()
{
  HShader hd = 1;

  while(this->HasShader(hd))
  {
    this->pShadersTab[hd++]->OnLostDevice();
  }
}

/*
 *  Wywolanie na kazdym szadeze tej samej funkcji.
 */
void CShaderManager::OnResetDevice()
{
  HShader hd = 1;

  while(this->HasShader(hd))
  {
    this->pShadersTab[hd++]->GetEffect()->OnResetDevice();
  }
}
E:\Project\Kopia (5) VBEngine\Graphics\ShaderManager.cpp
#ifndef _SHADER_H
#define _SHADER_H

/*
class       : CShader
description : Klasa effectu shaderowego dajaca "pe³n¹" obsluge w kodzie (ladowanie, wyladowanie , etc.).
              Wykozystuje pliki effektów DirectX ale jest ³atwo portowalna na "Cg". W teori kazdy
              plik effectu powinien dysponowac 4 technikami dostosowujacymi renderowanie przy pomocy
              tego "shadera" do mozliwosci karty video (3D).
              Z definicji "LEVEL_0" jest normalnym renderingiem bez pomocy progrmowlnych "shaderow" a
              jedynie ustawienia stanów "maszyny" renderujacej sa przekazywane przez plik effectu.
              Jest to bardzo wygodne poniweaz jakie kolwiek zmiany w sposobie renderowanie "objektów"
              wykozystywujacych ten "shader" dodawane sa przez zmiane pliku (textowy) effectu bez
              koniecznosci kompilacji ca³ego projektu.

              LEVEL_0	- normalny rendering
              LEVEL_1 - tylko vertex shadery (vs >= 1.1 && ps <= 1.1)
              LEVEL_2 - vertex i pixel shader (vs,ps >= 1.1 && vs,ps <= 2.0)
              LEVEL_3 - vertex i pixel shader (vs >= 2.0 && ps <= 2.0)
              LEVEL_4 - vertex i pixel shader (vs,ps >= 2.0)

methods     :
             CShader()   - konstruktor  
             ~CShader()  - destruktor
             Init(...)   - kopiuje nazwe pliku z effectem do wlasnego buffora
             GetEffect() - Zwraca przechowywany effect
	           Load(...)   - £aduje effect z pliku (ustawionego przez Init(...))
             UnLoad()    - wy³adowywuje effect.
	           Cmp(...)    - porównanie szukaneej nazwy pliku z effectem z naszym bufforem nazwy.
             IsLoad()    - zwraca status zaladowania effectu
	           SetTechnique(...) - ustawia jedna z 4 (dostepnych) technik.
             SetMaterial(...)  - ustawia aktualnie uzywany material.
             SetWVP(...) - ustawia aktualnia maciez WordViewProj.
             OnLostDevice() - wraper na te sama funkcjie w effekcie.
*/

enum TechniqueType
{
  LEVEL_0	= 0,
  LEVEL_1 = 1,
  LEVEL_2 = 2,
  LEVEL_3 = 3,
  LEVEL_4 = 4,
  TECHNIQUE_COUNT = 5  //dummy entry - defines the size
};

#define TECHNIQUE_DEFAULT LEVEL_4

class CTexture;

class CMaterial;
class CTextureManager;
class CMatrix4;

class CShader {
  LPD3DXEFFECT pEffect;                          /* wskaznik na wczytany effect (shaderowy) */
	char name[MAX_FILE_NAME];                      /* nazwa pliku z effctem */
	D3DXHANDLE ShaderHandles[TECHNIQUE_COUNT];     /* tablica handlerow na techniki w danym effecie */
  D3DXHANDLE TexturesHandles[MAX_TEXTURES_IN_MATERIAL];     /* tablica handlerow na textury w danym effecie */
  D3DXHANDLE MatWVPHandler;                      /* handler na potrujna maciez WordViewProj w danym effecie */
#ifdef USE_MATERIAL
  D3DXHANDLE DiffuseHandler;                     /* handler na skladnik materjialu : Deffuse w danym effecie */
#ifdef USE_AMBIENT
  D3DXHANDLE AmbientHandler;                     /* handler na skladnik materjialu : Ambient w danym effecie */
#endif
#ifdef USE_SPECULAR
  D3DXHANDLE SpecularHandler;                    /* handler na skladnik materjialu : Specular w danym effecie */
#endif
#endif

  bool is_load;                                  /* status zaladowania effectu */
public:
  CShader();
  ~CShader();
  void Init(char *filename);
  LPD3DXEFFECT GetEffect(void) {return this->pEffect;};
	HRESULT Load(LPDIRECT3DDEVICE9 device, enum TechniqueType current);
  void UnLoad(void);
	bool Cmp(char *m_name);
  bool IsLoad(void)      {return (this->is_load);};
	HRESULT SetTechnique(TechniqueType tech);
  void SetMaterial(CMaterial *pMaterial, CTextureManager *pTM);
  void SetWVP(CMatrix4 *pMatWorldProjView);
  void OnLostDevice();
};


#endif /* _SHADER_H */
E:\Project\Kopia (5) VBEngine\Graphics\Shader.h
#include "..\config.h"

#include <d3d9.h>
#include <d3dx9effect.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>
#include "..\Utility\Defines.h"
#include "..\Utility\Tools.h"
#include "..\Utility\logger.h"
#include "..\utility\vbmath.h"

#include "..\FileSystem\FileSystem.h"
#include "Texture.h"
#include "TextureManager.h"

#include "Renderer.h"

#include "Shader.h"
#include "ShaderManager.h"

#include "Material.h"

/*
 * Nazwy technik w szaderach
 * - Zadbaci o to by te same nazwy byly w plikach effektów !
 * - Ilosc naz tutaj musi sie zgadac z iloscia technik w enum TechniqueType !!!!
 */
const char *ShaderTechnique[] =
{
  "Tech_Lvl_0",
  "Tech_Lvl_1",
  "Tech_Lvl_2",
  "Tech_Lvl_3",
  "Tech_Lvl_4"
};

/* Konstuktor */
CShader::CShader()
{
	this->pEffect = NULL;
	this->name[0] = '\0';
  this->is_load = false;
} /* end of : Konstruktor */

/* Dekonstuktor: wyladowywuje effect z pamieci */
CShader::~CShader()
{
  this->UnLoad();
} /* end of : DeKonstruktor */

/*
 * Inicjalizator
 * Skopiowanie nazwy pliku do wlasnego buffora z nazwa (nazwa moze miec max MAX_FILE_NAME znaków)
 */
void CShader::Init(char *filename)
{
  my_snprintf(this->name, MAX_FILE_NAME, "%s", filename);
} /* end of : Init */

/*
 * Ustwaia aktywna technike shadera
 * 
 * Dodatkowo sprawdza czy posiadamy handler dla danego poziomu techniki.
 * Jesli nie posiadamy obniza technike az do skutku.
 */
HRESULT CShader::SetTechnique(TechniqueType tech)
{
  HRESULT hr;
  int i = (int)tech;
  while(NULL == this->ShaderHandles[i] && i > LEVEL_0)
  {
    i--;
  }
  DIE((this->ShaderHandles[i] != NULL) && "Proba ustawienia nieistniejacej techniki");
    
  hr = this->pEffect->SetTechnique(ShaderHandles[i]);
  if(FAILED(hr))
  {
    LogError("Failed to set shader technique in file : %s (%s)", this->name);
  }
  else
  {
    if(i < (int)tech)
    {
      LogWarning("Set Lower (%d/%d) Technique for shader : %s", i, (int)tech, this->name);
    }
    else
    {
      LogMessage("Set %d Technique for shader : : %s", i, this->name);
    }
  }

	return hr;
} /* end of : SetTechnique */

/*
 * Prorwnaj zadan¹ nazwe z nazw¹ pliku naszego effectu  (funkcja pomocnicza dla shader menagera)
 * zwraza True jesli sa to te same nazwy.
 */
bool CShader::Cmp(char *m_name)
{
  return (m_name && (strcmp(m_name, this->name) == 0));
};/* end of : Cmp(...) */

/*
 * Wy³adowanie effectu z pamiêci.
 */
void CShader::UnLoad(void)
{
  if(this->is_load && this->pEffect != NULL)
	{
	  this->pEffect->Release();
    this->pEffect = NULL;
    this->is_load = false;
    LogMessage("Unload shader file : %s", this->name);
	}
}; /* end of : Unload shader */

/*
 * Za³adowanie pliku effectu do pamiêci.
 *
 * Najpierw effekt szukany jest na dysku i jesli nie znajdziemy to
 * przeszukujemy nasz wewnetrzny system plikow.
 *
 * Funkcjia pobiera "Handlery" z ladowanego shadera:
 *  - na domyslne techniki.
 *  - na "wszystkie" textury opslugiwane przez nasz sytem mateialów.
 *  - na maciez WordViewProj.
 *  - na skladnik materialu : Diffuse (jesli opsluzono).
 *  - na skladnik materialu : Ambient (jesli opsluzono).
 *  - na skladnik materialu : Specular (jesli opsluzono).
 *
 * Funkcjia zwraca direxowy tryb blêdu HRESULT
 *  - S_OK jesli jest juz zaladowany.
 *  - Bl¹d kazdej funcji sk³adowej odpowiadaj¹cej za fizyczne zaladowanuie shadera do pamieci.
 */
HRESULT CShader::Load(LPDIRECT3DDEVICE9 device, enum TechniqueType current)
{
  if(!this->is_load)
  {
    HRESULT hr;	
	  LPD3DXBUFFER pBufferErrors = NULL;
	  char path[MAX_PATH];

    my_snprintf(path, MAX_PATH, "%s%s", ShadersPath , this->name);
#ifdef DEBUG
    hr = D3DXCreateEffectFromFile(device, path, NULL, NULL, D3DXSHADER_DEBUG, NULL, &this->pEffect, &pBufferErrors );
#else
    hr = D3DXCreateEffectFromFile(device, path, NULL, NULL, D3DXSHADER_SKIPVALIDATION, NULL, &this->pEffect, &pBufferErrors );
#endif

    if (FAILED(hr))
    {
      /* szukaj w datafile */
      void *data;
      unsigned int size;
      data = FileSystem::Instance()->LoadFile(path,&size);
      if (data != NULL)
      {
#ifdef DEBUG
        hr = D3DXCreateEffect(device,data,size,NULL, NULL, D3DXSHADER_DEBUG, NULL, &this->pEffect, &pBufferErrors );
#else
        hr = D3DXCreateEffect(device,data,size,NULL, NULL, D3DXSHADER_SKIPVALIDATION, NULL, &this->pEffect, &pBufferErrors );
#endif
      }
    }
	  if (SUCCEEDED(hr))
	  {
      int i;
      /* wypelni tablice Handlerów */
		  for(i = 0; i < TECHNIQUE_COUNT ; i++)
		  {
			  this->ShaderHandles[i] = this->pEffect->GetTechniqueByName(ShaderTechnique[i]);
		  }
      this->SetTechnique(current);

      /* wypelni tablice Handlerów textur */
		  for(i = 0; i < MAX_TEXTURES_IN_MATERIAL ; i++)
		  {
        my_snprintf(path, MAX_PATH, "texture%d", i);
        this->TexturesHandles[i] = this->pEffect->GetParameterByName(NULL,path);
		  }

      /* wypelni Handler WorldViewProj */
      this->MatWVPHandler = this->pEffect->GetParameterByName(NULL,"WorldViewProj");

      /* wypelni Handlery materialów */
#ifdef USE_MATERIAL
      this->DiffuseHandler = this->pEffect->GetParameterByName(NULL,"Diffuse");

#ifdef USE_AMBIENT
      this->AmbientHandler = this->pEffect->GetParameterByName(NULL,"Ambient");
#endif

#ifdef USE_SPECULAR
      this->SpecularHandler = this->pEffect->GetParameterByName(NULL,"Specular");
#endif

#endif
      LogMessage("Load shader file : %s", this->name);
      this->is_load = true;
	  } 
	  else 
	  {
      this->is_load = false;
		  this->pEffect = NULL;
      if(pBufferErrors)
      {
        char *errors =  (char*)pBufferErrors->GetBufferPointer();
        LogError("Failed to load shader file : %s (%s)", this->name,errors);
      }
      else
        LogError("Failed to load shader file : %s ", this->name);
	  }

    if ( NULL != pBufferErrors )
	  {
	    pBufferErrors->Release();
	  }
    return hr;
  } /* end of : !is_load */
  return S_OK;
}/* end of : Load Mesh */


/*
 * Ustawia aktualna maciez WVP w naszym shadeze.
 */
void CShader::SetWVP(CMatrix4 *pMatWorldProjView)
{
  D3DXMATRIX WordViewProj;
  /* Konversja na macizez z DX3D */
  for (int i = 0; i < 16; i++)
  {
    WordViewProj[i] = pMatWorldProjView->M[i];
  }
  this->pEffect->SetMatrix( this->MatWVPHandler, &WordViewProj);
};/* end of : SetWVP */

/*
 * Ustawia aktualna Material naszym shadeze.
 * 
 * 1. Ustawiane sa wszystkie "stage" textury (z danego materialu)
 *   - spawdzanie zaladowania textury (autoload)
 * 2. Wsyztkie uzywane skladniki materialu (Deffuse, Ambient, Specular)
 *
 */
void CShader::SetMaterial(CMaterial *pMaterial, CTextureManager *pTM)
{
  if(pMaterial && pTM && this->pEffect)
  {
    CTexture *pTexture;
    /* Textury */
    for(unsigned int stage = 0; stage < pMaterial->GetStageNum(); stage++)
    {
      pTexture = pTM->GetTexture(pMaterial->GetTexture(stage));
      /* autoload textury */
      if(SUCCEEDED(pTexture->Load(Renderer::Instance()->GetDevice())))
      {

         /* pTexture->SetTexture(Renderer::Instance()->GetDevice(), stage); */
        this->pEffect->SetTexture( this->TexturesHandles[stage], pTexture->GetDXTexture() );
      }
    }/* End of : Textury */
      
#ifdef USE_MATERIAL
      /* Materia³ */
      this->pEffect->SetVector(this->DiffuseHandler, &(D3DXVECTOR4(pMaterial->GetDiffuse()->x,
                pMaterial->GetDiffuse()->y, pMaterial->GetDiffuse()->z, pMaterial->GetDiffuse()->w)));
#ifdef USE_AMBIENT
      this->pEffect->SetVector(this->AmbientHandler, &(D3DXVECTOR4(pMaterial->GetAmbient->x,
                pMaterial->GetAmbient->y, pMaterial->GetAmbient->z, pMaterial->GetAmbient()->w)));
#endif
#ifdef USE_SPECULAR
      this->pEffect->SetVector(this->SpecularHandler, &(D3DXVECTOR4(pMaterial->GetSpecular->x,
            pMaterial->GetSpecular()->y, pMaterial->GetSpecular()->z, pMaterial->GetSpecular()->w)));
#endif
      /* End Materia³ */
#endif
  }
}/* end of : SetMaterial */

/*
 * Wraper na ta sama funkcje w naszym shadeze.
 */
void CShader::OnLostDevice() 
{
  if (pEffect) 
  {
    HRESULT hr;
    hr = pEffect->OnLostDevice();
    assert(SUCCEEDED(hr));
  }
}/* end of : OnLostDevice */
E:\Project\Kopia (5) VBEngine\Graphics\Shader.cpp
#ifndef _SCENEOBJECT_H
#define _SCENEOBJECT_H

/*
class       : SceneObject
description : klasa podstawowa dla obiektow 3d w scenie

methods     : 

*/



class SceneObject
{
protected:
  int level;
  CMatrix4 worldMatrix;
public:
  SceneObject(void)
  {
    this->level = 0;
    this->worldMatrix.SetIdentity();
  }
  void SetLevel(int lvl) {this->level = lvl;};
  int  GetLevel(void) {return this->level;};

  CMatrix4 *GetWorldMatrix() { return &this->worldMatrix; };

  virtual void Render(CMatrix4 *pViewProj) = 0;
};

class MeshSceneObject :public SceneObject
{
protected:
  HMesh mesh;
public:
  MeshSceneObject(char *name);
  
  MeshSceneObject(int lvl, char *name);
  
  void Render(CMatrix4 *pViewProj);
  
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\SceneObject.h
#include "..\config.h"

#include <assert.h>

#include "..\Utility\Defines.h"
//#include "..\..\utility\misc.h"
#include "..\utility\singleton.h"
#include "..\utility\VBmath.h"
//#include "..\..\utility\ctime.h"
//#include "..\..\Utility\Event.h"
//#include "..\..\utility\EventManager.h"
//#include "..\..\utility\EventHandler.h"
#include "..\Utility\tools.h"

//#include "..\..\graphics\animation.h"
//#include "..\..\graphics\AnimationManager.h"

//#include "..\graphics\renderer.h"
#include "TextureManager.h"
#include "meshmanager.h"

#include "SceneObject.h"

MeshSceneObject::MeshSceneObject(char *name)
{
    this->mesh = CMeshManager::Instance()->GetMeshHandlerLoad(name);
 //   CMeshManager::Instance()->SetAllShaders(this->mesh, "test.fx");
}

MeshSceneObject::MeshSceneObject(int lvl, char *name)
{
    this->SetLevel(lvl);
    this->mesh = CMeshManager::Instance()->GetMeshHandlerLoad(name);
//    CMeshManager::Instance()->SetAllShaders(this->mesh, "test.fx");
}

void MeshSceneObject::Render(CMatrix4 *pViewProj)
{
  CMatrix4 WordViewProj;
    
  MatMat4Multiply(WordViewProj, this->worldMatrix, *pViewProj);
  CMeshManager::Instance()->Render(this->mesh, &WordViewProj);
}
E:\Project\Kopia (5) VBEngine\Graphics\SceneObject.cpp
#ifndef _SCENEMANAGER_H
#define _SCENEMANAGER_H

/*
class       : SceneManager
description : Singleton zarzadzajacy wszystkimi obiektami do renderowania

methods     : AddObject    - dodaje obiekt do sceny
              RemoveObject - usuwa obiekt ze sceny
              Render       - wywoluje metode render kazdego obiektu na liscie

*/

class SceneObject;

typedef ItemList<SceneObject> SceneObjectList;

class SceneManager :public Singleton<SceneManager>, EventHandler
{
// SceneObjectList mObjectList;
 
 typedef ItemNode<SceneObject> ListNode;
 ListNode *root;
 int mCameraType;
 CCamera camera;
public:

  SceneManager();
  ~SceneManager();

  void AddObject(SceneObject *object)   ;// {mObjectList.Attach(object);}
  void RemoveObject(SceneObject *object);// {mObjectList.Remove(object);}

  void Render(); 

  void ProcessEvent(Event *event);
  CCamera *GetCamera() { return &this->camera; }
  unsigned int ModifyInput(unsigned int keymask);
};

#endif
E:\Project\Kopia (5) VBEngine\Graphics\SceneManager.h
{

    if(!root)
    {
			root = new ListNode(object);
    }
		else
    {
      ListNode *temp = root, *next;
      SceneObject *obj;
      while (temp && (obj = temp->GetItem(&next)))
      {
        if(!next)
        {
          temp->Attach(new ListNode(object));
          return;
        }
        if(obj->GetLevel() < object->GetLevel())
        {
          next = temp->AttachPrev(new ListNode(object));
          if(temp == root)
          {
            root = next;
          }
          return;
        }
        temp = next;
      }
    }
}

void SceneManager::RemoveObject(SceneObject *object)
{
    ListNode *temp = root,*tempNext = NULL;
    while (temp && temp->GetItem(&tempNext) != object)
    { 
      temp = tempNext;
    }
    if (temp)
    {
        if (temp == root)
            root = temp->GetNext();
        temp->Remove();
    }
    
}

unsigned int SceneManager::ModifyInput(unsigned int KeyMask)
{
  unsigned int mask = 0;
  if (mCameraType == 0) return KeyMask;
  bool up     = (KeyMask & VBK_UP)   !=0;
  bool down   = (KeyMask & VBK_DOWN) !=0;
  bool left   = (KeyMask & VBK_LEFT) !=0;
  bool right  = (KeyMask & VBK_RIGHT)!=0;
  switch (mCameraType)
  {
  case 1: 
    {
      if (up)    mask |= VBK_DOWN;
      if (down)  mask |= VBK_UP;
      if (left)  mask |= VBK_RIGHT;
      if (right) mask |= VBK_LEFT;
      break;
    }
  case 2:
    {
      if (up)    mask |= VBK_RIGHT;
      if (down)  mask |= VBK_LEFT;
      if (left)  mask |= VBK_UP;
      if (right) mask |= VBK_DOWN;
      break;
    }
  case 3:
    {
      if (up)    mask |= VBK_LEFT;
      if (down)  mask |= VBK_RIGHT;
      if (left)  mask |= VBK_DOWN;
      if (right) mask |= VBK_UP;
      break;
    }
  }
  mask |= KeyMask & (~(VBK_UP | VBK_DOWN | VBK_LEFT | VBK_RIGHT));
  return mask;

}


